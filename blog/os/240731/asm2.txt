
build/kernel/kernel.elf.symbol:     file format elf64-x86-64


Disassembly of section .text:

ffff800000100000 <kernel_init>:
static bconfig_t bconfig;

#include <string.h>

void kernel_init (bconfig_t *config)
{
ffff800000100000:	55                   	push   rbp
ffff800000100001:	48 89 e5             	mov    rbp,rsp
ffff800000100004:	48 83 ec 10          	sub    rsp,0x10
ffff800000100008:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
    memcpy (&bconfig, config, sizeof(bconfig_t));
ffff80000010000c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000100010:	ba 40 00 00 00       	mov    edx,0x40
ffff800000100015:	48 89 c6             	mov    rsi,rax
ffff800000100018:	48 8d 05 e1 1f 01 00 	lea    rax,[rip+0x11fe1]        # ffff800000112000 <bconfig>
ffff80000010001f:	48 89 c7             	mov    rdi,rax
ffff800000100022:	e8 1a 15 00 00       	call   ffff800000101541 <memcpy>

    /*
       直接换栈会有丢失数据的风险, 比如 config 在 换栈之后会失效,
       这是由于编译器在调用它的时候把 rdi 寄存器送入了栈中
    */
    __kstack_init();
ffff800000100027:	b8 00 00 00 00       	mov    eax,0x0
ffff80000010002c:	e8 80 3d 00 00       	call   ffff800000103db1 <__kstack_init>

    __video_pre (&bconfig.video);
ffff800000100031:	48 8d 05 d0 1f 01 00 	lea    rax,[rip+0x11fd0]        # ffff800000112008 <bconfig+0x8>
ffff800000100038:	48 89 c7             	mov    rdi,rax
ffff80000010003b:	e8 57 37 00 00       	call   ffff800000103797 <__video_pre>
    __mm_pre (&bconfig.memory);
ffff800000100040:	48 8d 05 e1 1f 01 00 	lea    rax,[rip+0x11fe1]        # ffff800000112028 <bconfig+0x28>
ffff800000100047:	48 89 c7             	mov    rdi,rax
ffff80000010004a:	e8 ca 1e 00 00       	call   ffff800000101f19 <__mm_pre>
    __acpi_pre (bconfig.acpi);
ffff80000010004f:	48 8b 05 e2 1f 01 00 	mov    rax,QWORD PTR [rip+0x11fe2]        # ffff800000112038 <bconfig+0x38>
ffff800000100056:	48 89 c7             	mov    rdi,rax
ffff800000100059:	e8 1f 04 00 00       	call   ffff80000010047d <__acpi_pre>

    kernel_main();
ffff80000010005e:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100063:	e8 03 00 00 00       	call   ffff80000010006b <kernel_main>
}
ffff800000100068:	90                   	nop
ffff800000100069:	c9                   	leave
ffff80000010006a:	c3                   	ret

ffff80000010006b <kernel_main>:
extern void task_init();

#include <irq.h>

void kernel_main ()
{
ffff80000010006b:	55                   	push   rbp
ffff80000010006c:	48 89 e5             	mov    rbp,rsp
    serial_init();
ffff80000010006f:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100074:	e8 d3 3a 00 00       	call   ffff800000103b4c <serial_init>
    console_init();
ffff800000100079:	b8 00 00 00 00       	mov    eax,0x0
ffff80000010007e:	e8 d6 0b 00 00       	call   ffff800000100c59 <console_init>

    gdt_init();
ffff800000100083:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100088:	e8 7c 3e 00 00       	call   ffff800000103f09 <gdt_init>
    idt_init();
ffff80000010008d:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100092:	e8 8c 42 00 00       	call   ffff800000104323 <idt_init>

    acpi_init();
ffff800000100097:	b8 00 00 00 00       	mov    eax,0x0
ffff80000010009c:	e8 01 03 00 00       	call   ffff8000001003a2 <acpi_init>
    apic_init();
ffff8000001000a1:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001000a6:	e8 7d 07 00 00       	call   ffff800000100828 <apic_init>

    mm_init();
ffff8000001000ab:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001000b0:	e8 35 1e 00 00       	call   ffff800000101eea <mm_init>

    // keyboard_init();

    task_init();
ffff8000001000b5:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001000ba:	e8 0c 12 00 00       	call   ffff8000001012cb <task_init>

    intr_sti();
ffff8000001000bf:	fb                   	sti

    while (true);
ffff8000001000c0:	eb fe                	jmp    ffff8000001000c0 <kernel_main+0x55>

ffff8000001000c2 <debugk>:
        const char *file,
        const u64  line,
        const char *format,
        ...
        )
{
ffff8000001000c2:	55                   	push   rbp
ffff8000001000c3:	48 89 e5             	mov    rbp,rsp
ffff8000001000c6:	48 81 ec f0 00 00 00 	sub    rsp,0xf0
ffff8000001000cd:	48 89 bd 28 ff ff ff 	mov    QWORD PTR [rbp-0xd8],rdi
ffff8000001000d4:	48 89 b5 20 ff ff ff 	mov    QWORD PTR [rbp-0xe0],rsi
ffff8000001000db:	48 89 95 18 ff ff ff 	mov    QWORD PTR [rbp-0xe8],rdx
ffff8000001000e2:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
ffff8000001000e9:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
ffff8000001000f0:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
ffff8000001000f7:	84 c0                	test   al,al
ffff8000001000f9:	74 20                	je     ffff80000010011b <debugk+0x59>
ffff8000001000fb:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
ffff8000001000ff:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
ffff800000100103:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
ffff800000100107:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
ffff80000010010b:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
ffff80000010010f:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
ffff800000100113:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
ffff800000100117:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
    va_list args;
    va_start (args, format);
ffff80000010011b:	c7 85 38 ff ff ff 18 	mov    DWORD PTR [rbp-0xc8],0x18
ffff800000100122:	00 00 00 
ffff800000100125:	c7 85 3c ff ff ff 30 	mov    DWORD PTR [rbp-0xc4],0x30
ffff80000010012c:	00 00 00 
ffff80000010012f:	48 8d 45 10          	lea    rax,[rbp+0x10]
ffff800000100133:	48 89 85 40 ff ff ff 	mov    QWORD PTR [rbp-0xc0],rax
ffff80000010013a:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
ffff800000100141:	48 89 85 48 ff ff ff 	mov    QWORD PTR [rbp-0xb8],rax

    vsprintf (
ffff800000100148:	48 8d 95 38 ff ff ff 	lea    rdx,[rbp-0xc8]
ffff80000010014f:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
ffff800000100156:	48 89 c6             	mov    rsi,rax
ffff800000100159:	48 8d 05 e0 1e 01 00 	lea    rax,[rip+0x11ee0]        # ffff800000112040 <buf>
ffff800000100160:	48 89 c7             	mov    rdi,rax
ffff800000100163:	e8 a5 15 00 00       	call   ffff80000010170d <vsprintf>
            buf,
            format,
            args
        );

    printk ("[%s:%d] %s", file, line, buf);
ffff800000100168:	48 8b 95 20 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xe0]
ffff80000010016f:	48 8b 85 28 ff ff ff 	mov    rax,QWORD PTR [rbp-0xd8]
ffff800000100176:	48 8d 0d c3 1e 01 00 	lea    rcx,[rip+0x11ec3]        # ffff800000112040 <buf>
ffff80000010017d:	48 89 c6             	mov    rsi,rax
ffff800000100180:	48 8d 05 79 5e 00 00 	lea    rax,[rip+0x5e79]        # ffff800000106000 <intr_get+0xb80>
ffff800000100187:	48 89 c7             	mov    rdi,rax
ffff80000010018a:	b8 00 00 00 00       	mov    eax,0x0
ffff80000010018f:	e8 66 0b 00 00       	call   ffff800000100cfa <printk>

    va_end (args);
}
ffff800000100194:	90                   	nop
ffff800000100195:	c9                   	leave
ffff800000100196:	c3                   	ret

ffff800000100197 <assertk>:
        const char *file,
        const u64  line,
        const bool state,
        const char *expr
        )
{
ffff800000100197:	55                   	push   rbp
ffff800000100198:	48 89 e5             	mov    rbp,rsp
ffff80000010019b:	48 83 ec 20          	sub    rsp,0x20
ffff80000010019f:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
ffff8000001001a3:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
ffff8000001001a7:	89 d0                	mov    eax,edx
ffff8000001001a9:	48 89 4d e0          	mov    QWORD PTR [rbp-0x20],rcx
ffff8000001001ad:	88 45 ec             	mov    BYTE PTR [rbp-0x14],al
    if (!state) {
ffff8000001001b0:	80 7d ec 00          	cmp    BYTE PTR [rbp-0x14],0x0
ffff8000001001b4:	75 2f                	jne    ffff8000001001e5 <assertk+0x4e>
      printk ("[%s:%d] Assert failed!!! -> %s\n", file, line, expr);
ffff8000001001b6:	48 8b 4d e0          	mov    rcx,QWORD PTR [rbp-0x20]
ffff8000001001ba:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
ffff8000001001be:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001001c2:	48 89 c6             	mov    rsi,rax
ffff8000001001c5:	48 8d 05 44 5e 00 00 	lea    rax,[rip+0x5e44]        # ffff800000106010 <intr_get+0xb90>
ffff8000001001cc:	48 89 c7             	mov    rdi,rax
ffff8000001001cf:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001001d4:	e8 21 0b 00 00       	call   ffff800000100cfa <printk>
    } else {
      return;
    }

    while (true) halt(); // TODO : interrupt
ffff8000001001d9:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001001de:	e8 7d 3b 00 00       	call   ffff800000103d60 <halt>
ffff8000001001e3:	eb f4                	jmp    ffff8000001001d9 <assertk+0x42>
      return;
ffff8000001001e5:	90                   	nop
}
ffff8000001001e6:	c9                   	leave
ffff8000001001e7:	c3                   	ret

ffff8000001001e8 <panic>:
        const char *file,
        const u64  line,
        const char *format,
        ...
        )
{
ffff8000001001e8:	55                   	push   rbp
ffff8000001001e9:	48 89 e5             	mov    rbp,rsp
ffff8000001001ec:	48 81 ec f0 00 00 00 	sub    rsp,0xf0
ffff8000001001f3:	48 89 bd 28 ff ff ff 	mov    QWORD PTR [rbp-0xd8],rdi
ffff8000001001fa:	48 89 b5 20 ff ff ff 	mov    QWORD PTR [rbp-0xe0],rsi
ffff800000100201:	48 89 95 18 ff ff ff 	mov    QWORD PTR [rbp-0xe8],rdx
ffff800000100208:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
ffff80000010020f:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
ffff800000100216:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
ffff80000010021d:	84 c0                	test   al,al
ffff80000010021f:	74 20                	je     ffff800000100241 <panic+0x59>
ffff800000100221:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
ffff800000100225:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
ffff800000100229:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
ffff80000010022d:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
ffff800000100231:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
ffff800000100235:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
ffff800000100239:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
ffff80000010023d:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
    va_list args;
    va_start (args, format);
ffff800000100241:	c7 85 38 ff ff ff 18 	mov    DWORD PTR [rbp-0xc8],0x18
ffff800000100248:	00 00 00 
ffff80000010024b:	c7 85 3c ff ff ff 30 	mov    DWORD PTR [rbp-0xc4],0x30
ffff800000100252:	00 00 00 
ffff800000100255:	48 8d 45 10          	lea    rax,[rbp+0x10]
ffff800000100259:	48 89 85 40 ff ff ff 	mov    QWORD PTR [rbp-0xc0],rax
ffff800000100260:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
ffff800000100267:	48 89 85 48 ff ff ff 	mov    QWORD PTR [rbp-0xb8],rax

    vsprintf (buf, format, args);
ffff80000010026e:	48 8d 95 38 ff ff ff 	lea    rdx,[rbp-0xc8]
ffff800000100275:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
ffff80000010027c:	48 89 c6             	mov    rsi,rax
ffff80000010027f:	48 8d 05 3a 1e 01 00 	lea    rax,[rip+0x11e3a]        # ffff8000001120c0 <buf>
ffff800000100286:	48 89 c7             	mov    rdi,rax
ffff800000100289:	e8 7f 14 00 00       	call   ffff80000010170d <vsprintf>
    debugk (file, line, "Panic!!! -> %s",buf);
ffff80000010028e:	48 8b b5 20 ff ff ff 	mov    rsi,QWORD PTR [rbp-0xe0]
ffff800000100295:	48 8b 85 28 ff ff ff 	mov    rax,QWORD PTR [rbp-0xd8]
ffff80000010029c:	48 8d 15 1d 1e 01 00 	lea    rdx,[rip+0x11e1d]        # ffff8000001120c0 <buf>
ffff8000001002a3:	48 89 d1             	mov    rcx,rdx
ffff8000001002a6:	48 8d 15 83 5d 00 00 	lea    rdx,[rip+0x5d83]        # ffff800000106030 <intr_get+0xbb0>
ffff8000001002ad:	48 89 c7             	mov    rdi,rax
ffff8000001002b0:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001002b5:	e8 08 fe ff ff       	call   ffff8000001000c2 <debugk>

    va_end (args);

    while (true) halt();
ffff8000001002ba:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001002bf:	e8 9c 3a 00 00       	call   ffff800000103d60 <halt>
ffff8000001002c4:	eb f4                	jmp    ffff8000001002ba <panic+0xd2>

ffff8000001002c6 <_chksum>:
#include <string.h>

xsdt_t *__xsdt;

static bool _chksum (void * buf, size_t siz)
{
ffff8000001002c6:	55                   	push   rbp
ffff8000001002c7:	48 89 e5             	mov    rbp,rsp
ffff8000001002ca:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
ffff8000001002ce:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
    u8 s = 0;
ffff8000001002d2:	c6 45 ff 00          	mov    BYTE PTR [rbp-0x1],0x0
    for (size_t i = 0; i < siz; i++)
ffff8000001002d6:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
ffff8000001002dd:	00 
ffff8000001002de:	eb 16                	jmp    ffff8000001002f6 <_chksum+0x30>
        s += ((char *)buf)[i];
ffff8000001002e0:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
ffff8000001002e4:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff8000001002e8:	48 01 d0             	add    rax,rdx
ffff8000001002eb:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff8000001002ee:	00 45 ff             	add    BYTE PTR [rbp-0x1],al
    for (size_t i = 0; i < siz; i++)
ffff8000001002f1:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
ffff8000001002f6:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff8000001002fa:	48 3b 45 e0          	cmp    rax,QWORD PTR [rbp-0x20]
ffff8000001002fe:	72 e0                	jb     ffff8000001002e0 <_chksum+0x1a>

    return (s == 0);
ffff800000100300:	80 7d ff 00          	cmp    BYTE PTR [rbp-0x1],0x0
ffff800000100304:	0f 94 c0             	sete   al
}
ffff800000100307:	5d                   	pop    rbp
ffff800000100308:	c3                   	ret

ffff800000100309 <_entryget>:

static void *_entryget (u32 sign)
{
ffff800000100309:	55                   	push   rbp
ffff80000010030a:	48 89 e5             	mov    rbp,rsp
ffff80000010030d:	48 83 ec 28          	sub    rsp,0x28
ffff800000100311:	89 7d dc             	mov    DWORD PTR [rbp-0x24],edi
    size_t num = (__xsdt->hdr.len - sizeof(xsdt_t)) / 8;
ffff800000100314:	48 8b 05 25 1e 01 00 	mov    rax,QWORD PTR [rip+0x11e25]        # ffff800000112140 <__xsdt>
ffff80000010031b:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
ffff80000010031e:	89 c0                	mov    eax,eax
ffff800000100320:	48 83 e8 24          	sub    rax,0x24
ffff800000100324:	48 c1 e8 03          	shr    rax,0x3
ffff800000100328:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax

    hdr_t *ptr;
    u64 *addrs = (void *)__xsdt + sizeof(xsdt_t);
ffff80000010032c:	48 8b 05 0d 1e 01 00 	mov    rax,QWORD PTR [rip+0x11e0d]        # ffff800000112140 <__xsdt>
ffff800000100333:	48 83 c0 24          	add    rax,0x24
ffff800000100337:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax

    for (size_t i = 0; i < num ;i++) {
ffff80000010033b:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
ffff800000100342:	00 
ffff800000100343:	eb 4c                	jmp    ffff800000100391 <_entryget+0x88>
        ptr = (hdr_t *)(addrs[i]);
ffff800000100345:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000100349:	48 8d 14 c5 00 00 00 	lea    rdx,[rax*8+0x0]
ffff800000100350:	00 
ffff800000100351:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000100355:	48 01 d0             	add    rax,rdx
ffff800000100358:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff80000010035b:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
        if (ptr->sign == sign) {
ffff80000010035f:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000100363:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000100365:	39 45 dc             	cmp    DWORD PTR [rbp-0x24],eax
ffff800000100368:	75 22                	jne    ffff80000010038c <_entryget+0x83>
            if (_chksum(ptr, ptr->len))
ffff80000010036a:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff80000010036e:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
ffff800000100371:	89 c2                	mov    edx,eax
ffff800000100373:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000100377:	48 89 d6             	mov    rsi,rdx
ffff80000010037a:	48 89 c7             	mov    rdi,rax
ffff80000010037d:	e8 44 ff ff ff       	call   ffff8000001002c6 <_chksum>
ffff800000100382:	84 c0                	test   al,al
ffff800000100384:	74 06                	je     ffff80000010038c <_entryget+0x83>
                return ptr;
ffff800000100386:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff80000010038a:	eb 14                	jmp    ffff8000001003a0 <_entryget+0x97>
    for (size_t i = 0; i < num ;i++) {
ffff80000010038c:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
ffff800000100391:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000100395:	48 3b 45 f0          	cmp    rax,QWORD PTR [rbp-0x10]
ffff800000100399:	72 aa                	jb     ffff800000100345 <_entryget+0x3c>
        }
    }
    return NULL;
ffff80000010039b:	b8 00 00 00 00       	mov    eax,0x0
}
ffff8000001003a0:	c9                   	leave
ffff8000001003a1:	c3                   	ret

ffff8000001003a2 <acpi_init>:
void fadt_parser ();

static rsdp_t *rsdp_phy;

void acpi_init ()
{
ffff8000001003a2:	55                   	push   rbp
ffff8000001003a3:	48 89 e5             	mov    rbp,rsp
ffff8000001003a6:	48 83 ec 10          	sub    rsp,0x10
    rsdp_t *rsdp = rsdp_phy;
ffff8000001003aa:	48 8b 05 97 1d 01 00 	mov    rax,QWORD PTR [rip+0x11d97]        # ffff800000112148 <rsdp_phy>
ffff8000001003b1:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

    /* This includes only the first 20 bytes of this Rsdp,
       including the checksum field. These bytes must sum
       to zero. 
       NOTE : Overflow to zero. (char/unsigned char/u8)   */
    if (rsdp->sign != RSDP_SIG || !_chksum(rsdp, 20))
ffff8000001003b5:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001003b9:	48 8b 10             	mov    rdx,QWORD PTR [rax]
ffff8000001003bc:	48 b8 52 53 44 20 50 	movabs rax,0x2052545020445352
ffff8000001003c3:	54 52 20 
ffff8000001003c6:	48 39 c2             	cmp    rdx,rax
ffff8000001003c9:	75 15                	jne    ffff8000001003e0 <acpi_init+0x3e>
ffff8000001003cb:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001003cf:	be 14 00 00 00       	mov    esi,0x14
ffff8000001003d4:	48 89 c7             	mov    rdi,rax
ffff8000001003d7:	e8 ea fe ff ff       	call   ffff8000001002c6 <_chksum>
ffff8000001003dc:	84 c0                	test   al,al
ffff8000001003de:	75 23                	jne    ffff800000100403 <acpi_init+0x61>
        PANIC ("bad RSDP!!!\n");
ffff8000001003e0:	48 8d 05 59 5c 00 00 	lea    rax,[rip+0x5c59]        # ffff800000106040 <intr_get+0xbc0>
ffff8000001003e7:	48 89 c2             	mov    rdx,rax
ffff8000001003ea:	be 54 00 00 00       	mov    esi,0x54
ffff8000001003ef:	48 8d 05 57 5c 00 00 	lea    rax,[rip+0x5c57]        # ffff80000010604d <intr_get+0xbcd>
ffff8000001003f6:	48 89 c7             	mov    rdi,rax
ffff8000001003f9:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001003fe:	e8 e5 fd ff ff       	call   ffff8000001001e8 <panic>

    xsdt_t *xsdt = (xsdt_t *)rsdp->xsdt_addr;
ffff800000100403:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000100407:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
ffff80000010040b:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
    if (xsdt->hdr.sign != XSDT_SIG || !_chksum(xsdt, xsdt->hdr.len))
ffff80000010040f:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000100413:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000100415:	3d 58 53 44 54       	cmp    eax,0x54445358
ffff80000010041a:	75 1c                	jne    ffff800000100438 <acpi_init+0x96>
ffff80000010041c:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000100420:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
ffff800000100423:	89 c2                	mov    edx,eax
ffff800000100425:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000100429:	48 89 d6             	mov    rsi,rdx
ffff80000010042c:	48 89 c7             	mov    rdi,rax
ffff80000010042f:	e8 92 fe ff ff       	call   ffff8000001002c6 <_chksum>
ffff800000100434:	84 c0                	test   al,al
ffff800000100436:	75 23                	jne    ffff80000010045b <acpi_init+0xb9>
        PANIC ("bad Xsdt!!!");
ffff800000100438:	48 8d 05 15 5c 00 00 	lea    rax,[rip+0x5c15]        # ffff800000106054 <intr_get+0xbd4>
ffff80000010043f:	48 89 c2             	mov    rdx,rax
ffff800000100442:	be 58 00 00 00       	mov    esi,0x58
ffff800000100447:	48 8d 05 ff 5b 00 00 	lea    rax,[rip+0x5bff]        # ffff80000010604d <intr_get+0xbcd>
ffff80000010044e:	48 89 c7             	mov    rdi,rax
ffff800000100451:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100456:	e8 8d fd ff ff       	call   ffff8000001001e8 <panic>
    __xsdt = xsdt;
ffff80000010045b:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff80000010045f:	48 89 05 da 1c 01 00 	mov    QWORD PTR [rip+0x11cda],rax        # ffff800000112140 <__xsdt>

    madt_parser();
ffff800000100466:	b8 00 00 00 00       	mov    eax,0x0
ffff80000010046b:	e8 5a 00 00 00       	call   ffff8000001004ca <madt_parser>
    fadt_parser();
ffff800000100470:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100475:	e8 04 02 00 00       	call   ffff80000010067e <fadt_parser>
}
ffff80000010047a:	90                   	nop
ffff80000010047b:	c9                   	leave
ffff80000010047c:	c3                   	ret

ffff80000010047d <__acpi_pre>:

void __acpi_pre (void *acpi)
{
ffff80000010047d:	55                   	push   rbp
ffff80000010047e:	48 89 e5             	mov    rbp,rsp
ffff800000100481:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
    rsdp_phy = acpi;
ffff800000100485:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000100489:	48 89 05 b8 1c 01 00 	mov    QWORD PTR [rip+0x11cb8],rax        # ffff800000112148 <rsdp_phy>
}
ffff800000100490:	90                   	nop
ffff800000100491:	5d                   	pop    rbp
ffff800000100492:	c3                   	ret

ffff800000100493 <__gsiget>:

static u8 _gsi[24];

/* Src 到 Gsi 的过程类似于一个重定向的过程 */
u8 __gsiget (u8 src)
{
ffff800000100493:	55                   	push   rbp
ffff800000100494:	48 89 e5             	mov    rbp,rsp
ffff800000100497:	89 f8                	mov    eax,edi
ffff800000100499:	88 45 fc             	mov    BYTE PTR [rbp-0x4],al
    return _gsi[src] != 0xFF ? _gsi[src] : src;
ffff80000010049c:	0f b6 45 fc          	movzx  eax,BYTE PTR [rbp-0x4]
ffff8000001004a0:	48 98                	cdqe
ffff8000001004a2:	48 8d 15 a7 1c 01 00 	lea    rdx,[rip+0x11ca7]        # ffff800000112150 <_gsi>
ffff8000001004a9:	0f b6 04 10          	movzx  eax,BYTE PTR [rax+rdx*1]
ffff8000001004ad:	3c ff                	cmp    al,0xff
ffff8000001004af:	74 13                	je     ffff8000001004c4 <__gsiget+0x31>
ffff8000001004b1:	0f b6 45 fc          	movzx  eax,BYTE PTR [rbp-0x4]
ffff8000001004b5:	48 98                	cdqe
ffff8000001004b7:	48 8d 15 92 1c 01 00 	lea    rdx,[rip+0x11c92]        # ffff800000112150 <_gsi>
ffff8000001004be:	0f b6 04 10          	movzx  eax,BYTE PTR [rax+rdx*1]
ffff8000001004c2:	eb 04                	jmp    ffff8000001004c8 <__gsiget+0x35>
ffff8000001004c4:	0f b6 45 fc          	movzx  eax,BYTE PTR [rbp-0x4]
}
ffff8000001004c8:	5d                   	pop    rbp
ffff8000001004c9:	c3                   	ret

ffff8000001004ca <madt_parser>:

void madt_parser ()
{
ffff8000001004ca:	55                   	push   rbp
ffff8000001004cb:	48 89 e5             	mov    rbp,rsp
ffff8000001004ce:	48 83 ec 30          	sub    rsp,0x30
    madt_t *madt = _entryget (APIC_SIG);
ffff8000001004d2:	bf 41 50 49 43       	mov    edi,0x43495041
ffff8000001004d7:	e8 2d fe ff ff       	call   ffff800000100309 <_entryget>
ffff8000001004dc:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
    if (madt == NULL)
ffff8000001004e0:	48 83 7d e8 00       	cmp    QWORD PTR [rbp-0x18],0x0
ffff8000001004e5:	75 23                	jne    ffff80000010050a <madt_parser+0x40>
        PANIC ("can not find madt!!!");
ffff8000001004e7:	48 8d 05 72 5b 00 00 	lea    rax,[rip+0x5b72]        # ffff800000106060 <intr_get+0xbe0>
ffff8000001004ee:	48 89 c2             	mov    rdx,rax
ffff8000001004f1:	be 9f 00 00 00       	mov    esi,0x9f
ffff8000001004f6:	48 8d 05 50 5b 00 00 	lea    rax,[rip+0x5b50]        # ffff80000010604d <intr_get+0xbcd>
ffff8000001004fd:	48 89 c7             	mov    rdi,rax
ffff800000100500:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100505:	e8 de fc ff ff       	call   ffff8000001001e8 <panic>
    
    int64 len = madt->hdr.len - sizeof(madt_t);
ffff80000010050a:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff80000010050e:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
ffff800000100511:	89 c0                	mov    eax,eax
ffff800000100513:	48 83 e8 2c          	sub    rax,0x2c
ffff800000100517:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    madt_ics_t *ics = OFFSET (madt, sizeof(madt_t));
ffff80000010051b:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff80000010051f:	48 83 c0 2c          	add    rax,0x2c
ffff800000100523:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
    
    memset (_gsi, 0xFF, 24);
ffff800000100527:	ba 18 00 00 00       	mov    edx,0x18
ffff80000010052c:	be ff 00 00 00       	mov    esi,0xff
ffff800000100531:	48 8d 05 18 1c 01 00 	lea    rax,[rip+0x11c18]        # ffff800000112150 <_gsi>
ffff800000100538:	48 89 c7             	mov    rdi,rax
ffff80000010053b:	e8 c0 0f 00 00       	call   ffff800000101500 <memset>

    while (len > 0) {
ffff800000100540:	e9 1b 01 00 00       	jmp    ffff800000100660 <madt_parser+0x196>
        switch (ics->type)
ffff800000100545:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000100549:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff80000010054c:	0f b6 c0             	movzx  eax,al
ffff80000010054f:	83 f8 02             	cmp    eax,0x2
ffff800000100552:	0f 84 a0 00 00 00    	je     ffff8000001005f8 <madt_parser+0x12e>
ffff800000100558:	83 f8 02             	cmp    eax,0x2
ffff80000010055b:	0f 8f e1 00 00 00    	jg     ffff800000100642 <madt_parser+0x178>
ffff800000100561:	85 c0                	test   eax,eax
ffff800000100563:	74 0a                	je     ffff80000010056f <madt_parser+0xa5>
ffff800000100565:	83 f8 01             	cmp    eax,0x1
ffff800000100568:	74 45                	je     ffff8000001005af <madt_parser+0xe5>
ffff80000010056a:	e9 d3 00 00 00       	jmp    ffff800000100642 <madt_parser+0x178>
        {
        case ICS_LAPIC:
            // 写 `{}` 是明确变量的 life circle
            {
                ics_lapic_t *_lapic = (ics_lapic_t *)ics;
ffff80000010056f:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000100573:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
                printk ("local Apic -> acpi processor uid : %u\n"
ffff800000100577:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff80000010057b:	8b 48 04             	mov    ecx,DWORD PTR [rax+0x4]
                        "              apic id : %u\n"
                        "              flags :   %x\n",
                        _lapic->apic_uid,_lapic->apic_id,_lapic->flgs);
ffff80000010057e:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff800000100582:	0f b6 40 03          	movzx  eax,BYTE PTR [rax+0x3]
                printk ("local Apic -> acpi processor uid : %u\n"
ffff800000100586:	0f b6 d0             	movzx  edx,al
                        _lapic->apic_uid,_lapic->apic_id,_lapic->flgs);
ffff800000100589:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff80000010058d:	0f b6 40 02          	movzx  eax,BYTE PTR [rax+0x2]
                printk ("local Apic -> acpi processor uid : %u\n"
ffff800000100591:	0f b6 c0             	movzx  eax,al
ffff800000100594:	89 c6                	mov    esi,eax
ffff800000100596:	48 8d 05 db 5a 00 00 	lea    rax,[rip+0x5adb]        # ffff800000106078 <intr_get+0xbf8>
ffff80000010059d:	48 89 c7             	mov    rdi,rax
ffff8000001005a0:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001005a5:	e8 50 07 00 00       	call   ffff800000100cfa <printk>
            }
        break;
ffff8000001005aa:	e9 93 00 00 00       	jmp    ffff800000100642 <madt_parser+0x178>
        
        case ICS_IOAPIC:
            {
                ics_ioapic_t *_ioapic = (ics_ioapic_t *)ics;
ffff8000001005af:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff8000001005b3:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
                printk ("i/o apic -> i/o apic id : %u\n"
ffff8000001005b7:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001005bb:	8b 48 08             	mov    ecx,DWORD PTR [rax+0x8]
ffff8000001005be:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001005c2:	8b 50 04             	mov    edx,DWORD PTR [rax+0x4]
                        "            i/o apic addr : %#x\n"
                        "            global system interrupt base : %#x\n",
                        _ioapic->ioapic_id,_ioapic->ioapic_addr,_ioapic->gsi_base);
ffff8000001005c5:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001005c9:	0f b6 40 02          	movzx  eax,BYTE PTR [rax+0x2]
                printk ("i/o apic -> i/o apic id : %u\n"
ffff8000001005cd:	0f b6 c0             	movzx  eax,al
ffff8000001005d0:	89 c6                	mov    esi,eax
ffff8000001005d2:	48 8d 05 ff 5a 00 00 	lea    rax,[rip+0x5aff]        # ffff8000001060d8 <intr_get+0xc58>
ffff8000001005d9:	48 89 c7             	mov    rdi,rax
ffff8000001005dc:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001005e1:	e8 14 07 00 00       	call   ffff800000100cfa <printk>
                ioapic = (void *)(u64)_ioapic->ioapic_addr;
ffff8000001005e6:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001005ea:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
ffff8000001005ed:	89 c0                	mov    eax,eax
ffff8000001005ef:	48 89 05 7a 1b 01 00 	mov    QWORD PTR [rip+0x11b7a],rax        # ffff800000112170 <ioapic>
            }
        break;
ffff8000001005f6:	eb 4a                	jmp    ffff800000100642 <madt_parser+0x178>

        /* Interrupt Source Override */
        case ICS_ISO:
            {
                ics_iso_t *_iso = (ics_iso_t *)ics;
ffff8000001005f8:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff8000001005fc:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
                printk ("intr src override -> bus : %u, src : %u, flgs : %x\n"
ffff800000100600:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000100604:	8b 70 04             	mov    esi,DWORD PTR [rax+0x4]
                        "                     global sys intr : %u\n",
                        _iso->bus,_iso->src,_iso->flgs,_iso->gsi);
ffff800000100607:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff80000010060b:	0f b7 40 08          	movzx  eax,WORD PTR [rax+0x8]
                printk ("intr src override -> bus : %u, src : %u, flgs : %x\n"
ffff80000010060f:	0f b7 c8             	movzx  ecx,ax
                        _iso->bus,_iso->src,_iso->flgs,_iso->gsi);
ffff800000100612:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000100616:	0f b6 40 03          	movzx  eax,BYTE PTR [rax+0x3]
                printk ("intr src override -> bus : %u, src : %u, flgs : %x\n"
ffff80000010061a:	0f b6 d0             	movzx  edx,al
                        _iso->bus,_iso->src,_iso->flgs,_iso->gsi);
ffff80000010061d:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000100621:	0f b6 40 02          	movzx  eax,BYTE PTR [rax+0x2]
                printk ("intr src override -> bus : %u, src : %u, flgs : %x\n"
ffff800000100625:	0f b6 c0             	movzx  eax,al
ffff800000100628:	41 89 f0             	mov    r8d,esi
ffff80000010062b:	89 c6                	mov    esi,eax
ffff80000010062d:	48 8d 05 14 5b 00 00 	lea    rax,[rip+0x5b14]        # ffff800000106148 <intr_get+0xcc8>
ffff800000100634:	48 89 c7             	mov    rdi,rax
ffff800000100637:	b8 00 00 00 00       	mov    eax,0x0
ffff80000010063c:	e8 b9 06 00 00       	call   ffff800000100cfa <printk>
            }
        break;
ffff800000100641:	90                   	nop
        }
        len -= ics->len;
ffff800000100642:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000100646:	0f b6 40 01          	movzx  eax,BYTE PTR [rax+0x1]
ffff80000010064a:	0f b6 c0             	movzx  eax,al
ffff80000010064d:	48 29 45 f8          	sub    QWORD PTR [rbp-0x8],rax
        ics = OFFSET (ics, ics->len);
ffff800000100651:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000100655:	0f b6 40 01          	movzx  eax,BYTE PTR [rax+0x1]
ffff800000100659:	0f b6 c0             	movzx  eax,al
ffff80000010065c:	48 01 45 f0          	add    QWORD PTR [rbp-0x10],rax
    while (len > 0) {
ffff800000100660:	48 83 7d f8 00       	cmp    QWORD PTR [rbp-0x8],0x0
ffff800000100665:	0f 8f da fe ff ff    	jg     ffff800000100545 <madt_parser+0x7b>
    }

    lapic = (void *)(u64)madt->lapic_addr;
ffff80000010066b:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff80000010066f:	8b 40 24             	mov    eax,DWORD PTR [rax+0x24]
ffff800000100672:	89 c0                	mov    eax,eax
ffff800000100674:	48 89 05 ed 1a 01 00 	mov    QWORD PTR [rip+0x11aed],rax        # ffff800000112168 <lapic>
}
ffff80000010067b:	90                   	nop
ffff80000010067c:	c9                   	leave
ffff80000010067d:	c3                   	ret

ffff80000010067e <fadt_parser>:
} fadt_t;

#define FADT_SIG SIGN_32('F','A','C','P')

void fadt_parser ()
{
ffff80000010067e:	55                   	push   rbp
ffff80000010067f:	48 89 e5             	mov    rbp,rsp
ffff800000100682:	48 83 ec 10          	sub    rsp,0x10
    fadt_t *fadt = _entryget (FADT_SIG);
ffff800000100686:	bf 46 41 43 50       	mov    edi,0x50434146
ffff80000010068b:	e8 79 fc ff ff       	call   ffff800000100309 <_entryget>
ffff800000100690:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
}
ffff800000100694:	90                   	nop
ffff800000100695:	c9                   	leave
ffff800000100696:	c3                   	ret

ffff800000100697 <__apic_tovmm>:
#define TM_ONESHOT  0b00 // One-Shot Mode
#define TM_PERIODIC 0b01 // Periodic Mode 周期模式
#define TM_TSCDLN   0b10 // TSC-Deadline Mode

void __apic_tovmm ()
{
ffff800000100697:	55                   	push   rbp
ffff800000100698:	48 89 e5             	mov    rbp,rsp
    vmap_map ((u64)lapic, LAPIC_VA, 1, PE_RW | PE_P | PE_PCD | PE_PWT, MAP_4K);
ffff80000010069b:	48 8b 05 c6 1a 01 00 	mov    rax,QWORD PTR [rip+0x11ac6]        # ffff800000112168 <lapic>
ffff8000001006a2:	48 89 c7             	mov    rdi,rax
ffff8000001006a5:	41 b8 01 00 00 00    	mov    r8d,0x1
ffff8000001006ab:	b9 1b 00 00 00       	mov    ecx,0x1b
ffff8000001006b0:	ba 01 00 00 00       	mov    edx,0x1
ffff8000001006b5:	48 b8 00 80 00 00 00 	movabs rax,0xffffff0000008000
ffff8000001006bc:	ff ff ff 
ffff8000001006bf:	48 89 c6             	mov    rsi,rax
ffff8000001006c2:	e8 dc 27 00 00       	call   ffff800000102ea3 <vmap_map>
    vmap_map ((u64)ioapic, IOAPIC_VA, 1, PE_RW | PE_P | PE_PCD | PE_PWT, MAP_4K);
ffff8000001006c7:	48 8b 05 a2 1a 01 00 	mov    rax,QWORD PTR [rip+0x11aa2]        # ffff800000112170 <ioapic>
ffff8000001006ce:	48 89 c7             	mov    rdi,rax
ffff8000001006d1:	41 b8 01 00 00 00    	mov    r8d,0x1
ffff8000001006d7:	b9 1b 00 00 00       	mov    ecx,0x1b
ffff8000001006dc:	ba 01 00 00 00       	mov    edx,0x1
ffff8000001006e1:	48 b8 00 00 00 00 00 	movabs rax,0xffffff0000000000
ffff8000001006e8:	ff ff ff 
ffff8000001006eb:	48 89 c6             	mov    rsi,rax
ffff8000001006ee:	e8 b0 27 00 00       	call   ffff800000102ea3 <vmap_map>

    lapic = (void *)LAPIC_VA;
ffff8000001006f3:	48 b8 00 80 00 00 00 	movabs rax,0xffffff0000008000
ffff8000001006fa:	ff ff ff 
ffff8000001006fd:	48 89 05 64 1a 01 00 	mov    QWORD PTR [rip+0x11a64],rax        # ffff800000112168 <lapic>
    ioapic = (void *)IOAPIC_VA;
ffff800000100704:	48 b8 00 00 00 00 00 	movabs rax,0xffffff0000000000
ffff80000010070b:	ff ff ff 
ffff80000010070e:	48 89 05 5b 1a 01 00 	mov    QWORD PTR [rip+0x11a5b],rax        # ffff800000112170 <ioapic>
}
ffff800000100715:	90                   	nop
ffff800000100716:	5d                   	pop    rbp
ffff800000100717:	c3                   	ret

ffff800000100718 <lapic_errhandler>:

void lapic_errhandler () { PANIC ("apic handler is not supported!!!"); }
ffff800000100718:	55                   	push   rbp
ffff800000100719:	48 89 e5             	mov    rbp,rsp
ffff80000010071c:	48 8d 05 85 5a 00 00 	lea    rax,[rip+0x5a85]        # ffff8000001061a8 <intr_get+0xd28>
ffff800000100723:	48 89 c2             	mov    rdx,rax
ffff800000100726:	be 3d 00 00 00       	mov    esi,0x3d
ffff80000010072b:	48 8d 05 97 5a 00 00 	lea    rax,[rip+0x5a97]        # ffff8000001061c9 <intr_get+0xd49>
ffff800000100732:	48 89 c7             	mov    rdi,rax
ffff800000100735:	b8 00 00 00 00       	mov    eax,0x0
ffff80000010073a:	e8 a9 fa ff ff       	call   ffff8000001001e8 <panic>
ffff80000010073f:	90                   	nop
ffff800000100740:	5d                   	pop    rbp
ffff800000100741:	c3                   	ret

ffff800000100742 <lapic_spshandler>:
void lapic_spshandler () { ; }
ffff800000100742:	55                   	push   rbp
ffff800000100743:	48 89 e5             	mov    rbp,rsp
ffff800000100746:	90                   	nop
ffff800000100747:	5d                   	pop    rbp
ffff800000100748:	c3                   	ret

ffff800000100749 <timer_handler>:
extern void task_schedule();

#include <textos/printk.h>

_ofp __INTR_HANDLER(timer_handler)
{
ffff800000100749:	48 83 ec 28          	sub    rsp,0x28
ffff80000010074d:	89 f8                	mov    eax,edi
ffff80000010074f:	48 89 74 24 10       	mov    QWORD PTR [rsp+0x10],rsi
ffff800000100754:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
ffff800000100759:	88 44 24 1c          	mov    BYTE PTR [rsp+0x1c],al
    lapic_sendeoi();
ffff80000010075d:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100762:	e8 44 02 00 00       	call   ffff8000001009ab <lapic_sendeoi>

    task_schedule();
ffff800000100767:	b8 00 00 00 00       	mov    eax,0x0
ffff80000010076c:	e8 12 0a 00 00       	call   ffff800000101183 <task_schedule>
}
ffff800000100771:	90                   	nop
ffff800000100772:	48 83 c4 28          	add    rsp,0x28
ffff800000100776:	c3                   	ret

ffff800000100777 <lapic_set>:

#include <textos/dev/pit.h>

void lapic_set (int x, u32 v)
{
ffff800000100777:	55                   	push   rbp
ffff800000100778:	48 89 e5             	mov    rbp,rsp
ffff80000010077b:	48 83 ec 10          	sub    rsp,0x10
ffff80000010077f:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
ffff800000100782:	89 75 f8             	mov    DWORD PTR [rbp-0x8],esi
    write_msr(x, v);
ffff800000100785:	8b 55 f8             	mov    edx,DWORD PTR [rbp-0x8]
ffff800000100788:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff80000010078b:	48 89 d6             	mov    rsi,rdx
ffff80000010078e:	89 c7                	mov    edi,eax
ffff800000100790:	e8 0f 36 00 00       	call   ffff800000103da4 <write_msr>
}
ffff800000100795:	90                   	nop
ffff800000100796:	c9                   	leave
ffff800000100797:	c3                   	ret

ffff800000100798 <lapic_get>:

u32 lapic_get (int x)
{
ffff800000100798:	55                   	push   rbp
ffff800000100799:	48 89 e5             	mov    rbp,rsp
ffff80000010079c:	48 83 ec 10          	sub    rsp,0x10
ffff8000001007a0:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
    return read_msr(x);
ffff8000001007a3:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff8000001007a6:	89 c7                	mov    edi,eax
ffff8000001007a8:	e8 eb 35 00 00       	call   ffff800000103d98 <read_msr>
}
ffff8000001007ad:	c9                   	leave
ffff8000001007ae:	c3                   	ret

ffff8000001007af <cpuid>:

void cpuid (int leaf, u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)
{
ffff8000001007af:	55                   	push   rbp
ffff8000001007b0:	48 89 e5             	mov    rbp,rsp
ffff8000001007b3:	53                   	push   rbx
ffff8000001007b4:	89 7d f4             	mov    DWORD PTR [rbp-0xc],edi
ffff8000001007b7:	48 89 75 e8          	mov    QWORD PTR [rbp-0x18],rsi
ffff8000001007bb:	48 89 55 e0          	mov    QWORD PTR [rbp-0x20],rdx
ffff8000001007bf:	48 89 4d d8          	mov    QWORD PTR [rbp-0x28],rcx
ffff8000001007c3:	4c 89 45 d0          	mov    QWORD PTR [rbp-0x30],r8
    __asm__ volatile(
ffff8000001007c7:	8b 45 f4             	mov    eax,DWORD PTR [rbp-0xc]
ffff8000001007ca:	ba 00 00 00 00       	mov    edx,0x0
ffff8000001007cf:	89 d1                	mov    ecx,edx
ffff8000001007d1:	0f a2                	cpuid
ffff8000001007d3:	89 de                	mov    esi,ebx
ffff8000001007d5:	89 c7                	mov    edi,eax
ffff8000001007d7:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001007db:	89 38                	mov    DWORD PTR [rax],edi
ffff8000001007dd:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff8000001007e1:	89 30                	mov    DWORD PTR [rax],esi
ffff8000001007e3:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001007e7:	89 08                	mov    DWORD PTR [rax],ecx
ffff8000001007e9:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff8000001007ed:	89 10                	mov    DWORD PTR [rax],edx
        "cpuid"
        : "=a"(*eax), "=b"(*ebx), "=c"(*ecx), "=d"(*edx)
        : "a"(leaf), "c"(0) : "memory"
    );
}
ffff8000001007ef:	90                   	nop
ffff8000001007f0:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
ffff8000001007f4:	c9                   	leave
ffff8000001007f5:	c3                   	ret

ffff8000001007f6 <x2apic_detect>:

int x2apic_detect ()
{
ffff8000001007f6:	55                   	push   rbp
ffff8000001007f7:	48 89 e5             	mov    rbp,rsp
ffff8000001007fa:	48 83 ec 10          	sub    rsp,0x10
    u32 eax, ebx, ecx, edx;
    cpuid(1, &eax, &ebx, &ecx, &edx);
ffff8000001007fe:	48 8d 75 f0          	lea    rsi,[rbp-0x10]
ffff800000100802:	48 8d 4d f4          	lea    rcx,[rbp-0xc]
ffff800000100806:	48 8d 55 f8          	lea    rdx,[rbp-0x8]
ffff80000010080a:	48 8d 45 fc          	lea    rax,[rbp-0x4]
ffff80000010080e:	49 89 f0             	mov    r8,rsi
ffff800000100811:	48 89 c6             	mov    rsi,rax
ffff800000100814:	bf 01 00 00 00       	mov    edi,0x1
ffff800000100819:	e8 91 ff ff ff       	call   ffff8000001007af <cpuid>
    return (ecx & (1 << 21));
ffff80000010081e:	8b 45 f4             	mov    eax,DWORD PTR [rbp-0xc]
ffff800000100821:	25 00 00 20 00       	and    eax,0x200000
}
ffff800000100826:	c9                   	leave
ffff800000100827:	c3                   	ret

ffff800000100828 <apic_init>:

/* Apic 不可以启动再禁用后再启动, 除非重启机器 */
void apic_init ()
{
ffff800000100828:	55                   	push   rbp
ffff800000100829:	48 89 e5             	mov    rbp,rsp
ffff80000010082c:	48 83 ec 10          	sub    rsp,0x10
    if (lapic == NULL || ioapic == NULL)
ffff800000100830:	48 8b 05 31 19 01 00 	mov    rax,QWORD PTR [rip+0x11931]        # ffff800000112168 <lapic>
ffff800000100837:	48 85 c0             	test   rax,rax
ffff80000010083a:	74 0c                	je     ffff800000100848 <apic_init+0x20>
ffff80000010083c:	48 8b 05 2d 19 01 00 	mov    rax,QWORD PTR [rip+0x1192d]        # ffff800000112170 <ioapic>
ffff800000100843:	48 85 c0             	test   rax,rax
ffff800000100846:	75 23                	jne    ffff80000010086b <apic_init+0x43>
        PANIC ("invalid lapic or ioapic. not detected\n");
ffff800000100848:	48 8d 05 81 59 00 00 	lea    rax,[rip+0x5981]        # ffff8000001061d0 <intr_get+0xd50>
ffff80000010084f:	48 89 c2             	mov    rdx,rax
ffff800000100852:	be 6b 00 00 00       	mov    esi,0x6b
ffff800000100857:	48 8d 05 6b 59 00 00 	lea    rax,[rip+0x596b]        # ffff8000001061c9 <intr_get+0xd49>
ffff80000010085e:	48 89 c7             	mov    rdi,rax
ffff800000100861:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100866:	e8 7d f9 ff ff       	call   ffff8000001001e8 <panic>

    pic_disable(); // 某种意义上,这是废话,大家不要理它...
ffff80000010086b:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100870:	e8 37 31 00 00       	call   ffff8000001039ac <pic_disable>

    if (x2apic_detect())
ffff800000100875:	b8 00 00 00 00       	mov    eax,0x0
ffff80000010087a:	e8 77 ff ff ff       	call   ffff8000001007f6 <x2apic_detect>
ffff80000010087f:	85 c0                	test   eax,eax
ffff800000100881:	74 14                	je     ffff800000100897 <apic_init+0x6f>
        printk("x2apic is supported!\n");
ffff800000100883:	48 8d 05 6d 59 00 00 	lea    rax,[rip+0x596d]        # ffff8000001061f7 <intr_get+0xd77>
ffff80000010088a:	48 89 c7             	mov    rdi,rax
ffff80000010088d:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100892:	e8 63 04 00 00       	call   ffff800000100cfa <printk>

    // write_msr (IA32_APIC_BASE, ((u64)lapic << 12) | (1 << 11));
    u64 msr = read_msr(IA32_APIC_BASE) | (1 << 10);
ffff800000100897:	bf 1b 00 00 00       	mov    edi,0x1b
ffff80000010089c:	e8 f7 34 00 00       	call   ffff800000103d98 <read_msr>
ffff8000001008a1:	80 cc 04             	or     ah,0x4
ffff8000001008a4:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

    write_msr(IA32_APIC_BASE, msr);
ffff8000001008a8:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001008ac:	48 89 c6             	mov    rsi,rax
ffff8000001008af:	bf 1b 00 00 00       	mov    edi,0x1b
ffff8000001008b4:	e8 eb 34 00 00       	call   ffff800000103da4 <write_msr>

    intr_register (INT_APIC_ERR, (ihandler_t)lapic_errhandler);
ffff8000001008b9:	48 8d 05 58 fe ff ff 	lea    rax,[rip+0xfffffffffffffe58]        # ffff800000100718 <lapic_errhandler>
ffff8000001008c0:	48 89 c6             	mov    rsi,rax
ffff8000001008c3:	bf 81 00 00 00       	mov    edi,0x81
ffff8000001008c8:	e8 11 3b 00 00       	call   ffff8000001043de <intr_register>
    intr_register (INT_APIC_SPS, (ihandler_t)lapic_spshandler);
ffff8000001008cd:	48 8d 05 6e fe ff ff 	lea    rax,[rip+0xfffffffffffffe6e]        # ffff800000100742 <lapic_spshandler>
ffff8000001008d4:	48 89 c6             	mov    rsi,rax
ffff8000001008d7:	bf 82 00 00 00       	mov    edi,0x82
ffff8000001008dc:	e8 fd 3a 00 00       	call   ffff8000001043de <intr_register>

    lapic_set(MSR_LERR, INT_APIC_ERR);
ffff8000001008e1:	be 81 00 00 00       	mov    esi,0x81
ffff8000001008e6:	bf 37 08 00 00       	mov    edi,0x837
ffff8000001008eb:	e8 87 fe ff ff       	call   ffff800000100777 <lapic_set>

    lapic_set(MSR_ESR, 0);
ffff8000001008f0:	be 00 00 00 00       	mov    esi,0x0
ffff8000001008f5:	bf 28 08 00 00       	mov    edi,0x828
ffff8000001008fa:	e8 78 fe ff ff       	call   ffff800000100777 <lapic_set>
    lapic_set(MSR_ESR, 0);
ffff8000001008ff:	be 00 00 00 00       	mov    esi,0x0
ffff800000100904:	bf 28 08 00 00       	mov    edi,0x828
ffff800000100909:	e8 69 fe ff ff       	call   ffff800000100777 <lapic_set>

    lapic_set(MSR_TPR, S_TPR(0, 0));
ffff80000010090e:	be 00 00 00 00       	mov    esi,0x0
ffff800000100913:	bf 08 08 00 00       	mov    edi,0x808
ffff800000100918:	e8 5a fe ff ff       	call   ffff800000100777 <lapic_set>
    lapic_set(MSR_SVR, S_SVR(true, INT_APIC_SPS));      // 软启用 Apic / APIC Software Enable
ffff80000010091d:	be 82 01 00 00       	mov    esi,0x182
ffff800000100922:	bf 0f 08 00 00       	mov    edi,0x80f
ffff800000100927:	e8 4b fe ff ff       	call   ffff800000100777 <lapic_set>
    
    lapic_set(MSR_TM, S_TM(TM_ONESHOT, 0) | LVT_MASK);  // 屏蔽 Apic Timer 的本地中断
ffff80000010092c:	be 00 00 01 00       	mov    esi,0x10000
ffff800000100931:	bf 32 08 00 00       	mov    edi,0x832
ffff800000100936:	e8 3c fe ff ff       	call   ffff800000100777 <lapic_set>
    lapic_set(MSR_TDCR, 0b0000);                        // 设置 除数 (因子) 为 2
ffff80000010093b:	be 00 00 00 00       	mov    esi,0x0
ffff800000100940:	bf 3e 08 00 00       	mov    edi,0x83e
ffff800000100945:	e8 2d fe ff ff       	call   ffff800000100777 <lapic_set>
    lapic_set(MSR_TICR, 0xffffffff);                    // 设置 初始计数到最大 (-1)
ffff80000010094a:	be ff ff ff ff       	mov    esi,0xffffffff
ffff80000010094f:	bf 38 08 00 00       	mov    edi,0x838
ffff800000100954:	e8 1e fe ff ff       	call   ffff800000100777 <lapic_set>

    pit_sleepms (1);
ffff800000100959:	bf 01 00 00 00       	mov    edi,0x1
ffff80000010095e:	e8 b8 30 00 00       	call   ffff800000103a1b <pit_sleepms>
    // __asm__ volatile ("nop" : : : "memory");

    lapic_set(MSR_TICR, 0xffffffff - lapic_get(MSR_TCCR)); // 计算 100ms 的 ticks
ffff800000100963:	bf 39 08 00 00       	mov    edi,0x839
ffff800000100968:	e8 2b fe ff ff       	call   ffff800000100798 <lapic_get>
ffff80000010096d:	f7 d0                	not    eax
ffff80000010096f:	89 c6                	mov    esi,eax
ffff800000100971:	bf 38 08 00 00       	mov    edi,0x838
ffff800000100976:	e8 fc fd ff ff       	call   ffff800000100777 <lapic_set>
    lapic_set(MSR_TM, S_TM(TM_PERIODIC, INT_TIMER));       // 步入正轨, 每 100ms 产生一次时钟中断
ffff80000010097b:	be 20 00 02 00       	mov    esi,0x20020
ffff800000100980:	bf 32 08 00 00       	mov    edi,0x832
ffff800000100985:	e8 ed fd ff ff       	call   ffff800000100777 <lapic_set>
    intr_register(INT_TIMER, timer_handler);               // 注册中断函数
ffff80000010098a:	48 8d 05 b8 fd ff ff 	lea    rax,[rip+0xfffffffffffffdb8]        # ffff800000100749 <timer_handler>
ffff800000100991:	48 89 c6             	mov    rsi,rax
ffff800000100994:	bf 20 00 00 00       	mov    edi,0x20
ffff800000100999:	e8 40 3a 00 00       	call   ffff8000001043de <intr_register>

    lapic_sendeoi();
ffff80000010099e:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001009a3:	e8 03 00 00 00       	call   ffff8000001009ab <lapic_sendeoi>
}
ffff8000001009a8:	90                   	nop
ffff8000001009a9:	c9                   	leave
ffff8000001009aa:	c3                   	ret

ffff8000001009ab <lapic_sendeoi>:

void lapic_sendeoi ()
{
ffff8000001009ab:	55                   	push   rbp
ffff8000001009ac:	48 89 e5             	mov    rbp,rsp
    lapic_set (MSR_EOI, 0);
ffff8000001009af:	be 00 00 00 00       	mov    esi,0x0
ffff8000001009b4:	bf 0b 08 00 00       	mov    edi,0x80b
ffff8000001009b9:	e8 b9 fd ff ff       	call   ffff800000100777 <lapic_set>
}
ffff8000001009be:	90                   	nop
ffff8000001009bf:	5d                   	pop    rbp
ffff8000001009c0:	c3                   	ret

ffff8000001009c1 <ioapic_write>:
#define IOAPICVER   0x01
#define IOAPICARB   0x02
#define IOREDTBL    0x10

void ioapic_write (int x, u32 v)
{
ffff8000001009c1:	55                   	push   rbp
ffff8000001009c2:	48 89 e5             	mov    rbp,rsp
ffff8000001009c5:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
ffff8000001009c8:	89 75 f8             	mov    DWORD PTR [rbp-0x8],esi
    *(u32 *)IOREGSEL = x;
ffff8000001009cb:	48 8b 05 9e 17 01 00 	mov    rax,QWORD PTR [rip+0x1179e]        # ffff800000112170 <ioapic>
ffff8000001009d2:	8b 55 fc             	mov    edx,DWORD PTR [rbp-0x4]
ffff8000001009d5:	89 10                	mov    DWORD PTR [rax],edx
    *(u32 *)IOWIN = v;
ffff8000001009d7:	48 8b 05 92 17 01 00 	mov    rax,QWORD PTR [rip+0x11792]        # ffff800000112170 <ioapic>
ffff8000001009de:	48 8d 50 10          	lea    rdx,[rax+0x10]
ffff8000001009e2:	8b 45 f8             	mov    eax,DWORD PTR [rbp-0x8]
ffff8000001009e5:	89 02                	mov    DWORD PTR [rdx],eax
}
ffff8000001009e7:	90                   	nop
ffff8000001009e8:	5d                   	pop    rbp
ffff8000001009e9:	c3                   	ret

ffff8000001009ea <ioapic_read>:

u32 ioapic_read (int x)
{
ffff8000001009ea:	55                   	push   rbp
ffff8000001009eb:	48 89 e5             	mov    rbp,rsp
ffff8000001009ee:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
    *(u32 *)IOREGSEL = x;
ffff8000001009f1:	48 8b 05 78 17 01 00 	mov    rax,QWORD PTR [rip+0x11778]        # ffff800000112170 <ioapic>
ffff8000001009f8:	8b 55 fc             	mov    edx,DWORD PTR [rbp-0x4]
ffff8000001009fb:	89 10                	mov    DWORD PTR [rax],edx
    return *(u32 *)IOWIN;
ffff8000001009fd:	48 8b 05 6c 17 01 00 	mov    rax,QWORD PTR [rip+0x1176c]        # ffff800000112170 <ioapic>
ffff800000100a04:	8b 40 10             	mov    eax,DWORD PTR [rax+0x10]
}
ffff800000100a07:	5d                   	pop    rbp
ffff800000100a08:	c3                   	ret

ffff800000100a09 <ioapic_rteset>:

extern u8 __gsiget (u8 src);

void ioapic_rteset (u8 irq, u64 rte)
{
ffff800000100a09:	55                   	push   rbp
ffff800000100a0a:	48 89 e5             	mov    rbp,rsp
ffff800000100a0d:	48 83 ec 20          	sub    rsp,0x20
ffff800000100a11:	89 f8                	mov    eax,edi
ffff800000100a13:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
ffff800000100a17:	88 45 ec             	mov    BYTE PTR [rbp-0x14],al
    irq = __gsiget (irq);  // 向 Acpi 查询是否存在 Src -> Gsi
ffff800000100a1a:	0f b6 45 ec          	movzx  eax,BYTE PTR [rbp-0x14]
ffff800000100a1e:	89 c7                	mov    edi,eax
ffff800000100a20:	e8 6e fa ff ff       	call   ffff800000100493 <__gsiget>
ffff800000100a25:	88 45 ec             	mov    BYTE PTR [rbp-0x14],al
    
    int reg = irq * 2 + IOREDTBL;
ffff800000100a28:	0f b6 45 ec          	movzx  eax,BYTE PTR [rbp-0x14]
ffff800000100a2c:	83 c0 08             	add    eax,0x8
ffff800000100a2f:	01 c0                	add    eax,eax
ffff800000100a31:	89 45 fc             	mov    DWORD PTR [rbp-0x4],eax
    ioapic_write(reg, rte & 0xffffffff);
ffff800000100a34:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000100a38:	89 c2                	mov    edx,eax
ffff800000100a3a:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff800000100a3d:	89 d6                	mov    esi,edx
ffff800000100a3f:	89 c7                	mov    edi,eax
ffff800000100a41:	e8 7b ff ff ff       	call   ffff8000001009c1 <ioapic_write>
    ioapic_write(reg + 1, rte >> 32);
ffff800000100a46:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000100a4a:	48 c1 e8 20          	shr    rax,0x20
ffff800000100a4e:	89 c2                	mov    edx,eax
ffff800000100a50:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff800000100a53:	83 c0 01             	add    eax,0x1
ffff800000100a56:	89 d6                	mov    esi,edx
ffff800000100a58:	89 c7                	mov    edi,eax
ffff800000100a5a:	e8 62 ff ff ff       	call   ffff8000001009c1 <ioapic_write>
}
ffff800000100a5f:	90                   	nop
ffff800000100a60:	c9                   	leave
ffff800000100a61:	c3                   	ret

ffff800000100a62 <console_clear>:
#include <textos/video.h>

console_t con;

void console_clear ()
{
ffff800000100a62:	55                   	push   rbp
ffff800000100a63:	48 89 e5             	mov    rbp,rsp
    con.cur_x = 0;
ffff800000100a66:	66 c7 05 1d 17 01 00 	mov    WORD PTR [rip+0x1171d],0x0        # ffff80000011218c <con+0xc>
ffff800000100a6d:	00 00 
    con.cur_y = 0;
ffff800000100a6f:	66 c7 05 16 17 01 00 	mov    WORD PTR [rip+0x11716],0x0        # ffff80000011218e <con+0xe>
ffff800000100a76:	00 00 
    
    screen_clear();
ffff800000100a78:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100a7d:	e8 a6 2c 00 00       	call   ffff800000103728 <screen_clear>
}
ffff800000100a82:	90                   	nop
ffff800000100a83:	5d                   	pop    rbp
ffff800000100a84:	c3                   	ret

ffff800000100a85 <console_putc>:

static int console_putc (char c)
{
ffff800000100a85:	55                   	push   rbp
ffff800000100a86:	48 89 e5             	mov    rbp,rsp
ffff800000100a89:	48 83 ec 20          	sub    rsp,0x20
ffff800000100a8d:	89 f8                	mov    eax,edi
ffff800000100a8f:	88 45 ec             	mov    BYTE PTR [rbp-0x14],al
    switch (c)
ffff800000100a92:	0f be 45 ec          	movsx  eax,BYTE PTR [rbp-0x14]
ffff800000100a96:	83 f8 0d             	cmp    eax,0xd
ffff800000100a99:	74 61                	je     ffff800000100afc <console_putc+0x77>
ffff800000100a9b:	83 f8 0d             	cmp    eax,0xd
ffff800000100a9e:	0f 8f 8f 00 00 00    	jg     ffff800000100b33 <console_putc+0xae>
ffff800000100aa4:	83 f8 0c             	cmp    eax,0xc
ffff800000100aa7:	74 1c                	je     ffff800000100ac5 <console_putc+0x40>
ffff800000100aa9:	83 f8 0c             	cmp    eax,0xc
ffff800000100aac:	0f 8f 81 00 00 00    	jg     ffff800000100b33 <console_putc+0xae>
ffff800000100ab2:	83 f8 08             	cmp    eax,0x8
ffff800000100ab5:	74 57                	je     ffff800000100b0e <console_putc+0x89>
ffff800000100ab7:	83 f8 0a             	cmp    eax,0xa
ffff800000100aba:	75 77                	jne    ffff800000100b33 <console_putc+0xae>
    {
        case '\n': // 回车,将指针移动到 (0,CurY+1)
            con.cur_x = 0;
ffff800000100abc:	66 c7 05 c7 16 01 00 	mov    WORD PTR [rip+0x116c7],0x0        # ffff80000011218c <con+0xc>
ffff800000100ac3:	00 00 
        case '\f': // 进纸符
            if (++con.cur_y >= con.col) {
ffff800000100ac5:	0f b7 05 c2 16 01 00 	movzx  eax,WORD PTR [rip+0x116c2]        # ffff80000011218e <con+0xe>
ffff800000100acc:	83 c0 01             	add    eax,0x1
ffff800000100acf:	66 89 05 b8 16 01 00 	mov    WORD PTR [rip+0x116b8],ax        # ffff80000011218e <con+0xe>
ffff800000100ad6:	0f b7 15 b1 16 01 00 	movzx  edx,WORD PTR [rip+0x116b1]        # ffff80000011218e <con+0xe>
ffff800000100add:	0f b7 05 a6 16 01 00 	movzx  eax,WORD PTR [rip+0x116a6]        # ffff80000011218a <con+0xa>
ffff800000100ae4:	66 39 c2             	cmp    dx,ax
ffff800000100ae7:	72 0a                	jb     ffff800000100af3 <console_putc+0x6e>
                console_clear();
ffff800000100ae9:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100aee:	e8 6f ff ff ff       	call   ffff800000100a62 <console_clear>
            }
            return c;
ffff800000100af3:	0f be 45 ec          	movsx  eax,BYTE PTR [rbp-0x14]
ffff800000100af7:	e9 fe 00 00 00       	jmp    ffff800000100bfa <console_putc+0x175>
        case '\r': // 将指针移动到 (0,CurY)
            con.cur_x = 0;
ffff800000100afc:	66 c7 05 87 16 01 00 	mov    WORD PTR [rip+0x11687],0x0        # ffff80000011218c <con+0xc>
ffff800000100b03:	00 00 
            return c;
ffff800000100b05:	0f be 45 ec          	movsx  eax,BYTE PTR [rbp-0x14]
ffff800000100b09:	e9 ec 00 00 00       	jmp    ffff800000100bfa <console_putc+0x175>
        case '\b': // 将指针移动到 (CurX-1,CurY)
            con.cur_x = MAX (con.cur_x - 1, 0);
ffff800000100b0e:	0f b7 05 77 16 01 00 	movzx  eax,WORD PTR [rip+0x11677]        # ffff80000011218c <con+0xc>
ffff800000100b15:	ba 01 00 00 00       	mov    edx,0x1
ffff800000100b1a:	66 85 c0             	test   ax,ax
ffff800000100b1d:	0f 44 c2             	cmove  eax,edx
ffff800000100b20:	83 e8 01             	sub    eax,0x1
ffff800000100b23:	66 89 05 62 16 01 00 	mov    WORD PTR [rip+0x11662],ax        # ffff80000011218c <con+0xc>
            return c;
ffff800000100b2a:	0f be 45 ec          	movsx  eax,BYTE PTR [rbp-0x14]
ffff800000100b2e:	e9 c7 00 00 00       	jmp    ffff800000100bfa <console_putc+0x175>
    }

    u16 x = con.cur_x * con.font->w;
ffff800000100b33:	0f b7 15 52 16 01 00 	movzx  edx,WORD PTR [rip+0x11652]        # ffff80000011218c <con+0xc>
ffff800000100b3a:	48 8b 05 57 16 01 00 	mov    rax,QWORD PTR [rip+0x11657]        # ffff800000112198 <con+0x18>
ffff800000100b41:	0f b6 40 08          	movzx  eax,BYTE PTR [rax+0x8]
ffff800000100b45:	0f b6 c0             	movzx  eax,al
ffff800000100b48:	0f af c2             	imul   eax,edx
ffff800000100b4b:	66 89 45 fe          	mov    WORD PTR [rbp-0x2],ax
    u16 y = con.cur_y * con.font->h;
ffff800000100b4f:	0f b7 15 38 16 01 00 	movzx  edx,WORD PTR [rip+0x11638]        # ffff80000011218e <con+0xe>
ffff800000100b56:	48 8b 05 3b 16 01 00 	mov    rax,QWORD PTR [rip+0x1163b]        # ffff800000112198 <con+0x18>
ffff800000100b5d:	0f b6 40 09          	movzx  eax,BYTE PTR [rax+0x9]
ffff800000100b61:	0f b6 c0             	movzx  eax,al
ffff800000100b64:	0f af c2             	imul   eax,edx
ffff800000100b67:	66 89 45 fc          	mov    WORD PTR [rbp-0x4],ax

    font_show (
ffff800000100b6b:	44 8b 05 22 16 01 00 	mov    r8d,DWORD PTR [rip+0x11622]        # ffff800000112194 <con+0x14>
ffff800000100b72:	8b 3d 18 16 01 00    	mov    edi,DWORD PTR [rip+0x11618]        # ffff800000112190 <con+0x10>
ffff800000100b78:	0f b7 4d fc          	movzx  ecx,WORD PTR [rbp-0x4]
ffff800000100b7c:	0f b7 55 fe          	movzx  edx,WORD PTR [rbp-0x2]
ffff800000100b80:	48 8b 35 11 16 01 00 	mov    rsi,QWORD PTR [rip+0x11611]        # ffff800000112198 <con+0x18>
ffff800000100b87:	0f b6 45 ec          	movzx  eax,BYTE PTR [rbp-0x14]
ffff800000100b8b:	0f b6 c0             	movzx  eax,al
ffff800000100b8e:	45 89 c1             	mov    r9d,r8d
ffff800000100b91:	41 89 f8             	mov    r8d,edi
ffff800000100b94:	89 c7                	mov    edi,eax
ffff800000100b96:	e8 9f 2c 00 00       	call   ffff80000010383a <font_show>
        c,
        con.font,
        x, y, con.fg, con.bg
        );
    
    if (++con.cur_x >= con.row) {
ffff800000100b9b:	0f b7 05 ea 15 01 00 	movzx  eax,WORD PTR [rip+0x115ea]        # ffff80000011218c <con+0xc>
ffff800000100ba2:	83 c0 01             	add    eax,0x1
ffff800000100ba5:	66 89 05 e0 15 01 00 	mov    WORD PTR [rip+0x115e0],ax        # ffff80000011218c <con+0xc>
ffff800000100bac:	0f b7 15 d9 15 01 00 	movzx  edx,WORD PTR [rip+0x115d9]        # ffff80000011218c <con+0xc>
ffff800000100bb3:	0f b7 05 ce 15 01 00 	movzx  eax,WORD PTR [rip+0x115ce]        # ffff800000112188 <con+0x8>
ffff800000100bba:	66 39 c2             	cmp    dx,ax
ffff800000100bbd:	72 37                	jb     ffff800000100bf6 <console_putc+0x171>
        if (++con.cur_y >= con.col) {
ffff800000100bbf:	0f b7 05 c8 15 01 00 	movzx  eax,WORD PTR [rip+0x115c8]        # ffff80000011218e <con+0xe>
ffff800000100bc6:	83 c0 01             	add    eax,0x1
ffff800000100bc9:	66 89 05 be 15 01 00 	mov    WORD PTR [rip+0x115be],ax        # ffff80000011218e <con+0xe>
ffff800000100bd0:	0f b7 15 b7 15 01 00 	movzx  edx,WORD PTR [rip+0x115b7]        # ffff80000011218e <con+0xe>
ffff800000100bd7:	0f b7 05 ac 15 01 00 	movzx  eax,WORD PTR [rip+0x115ac]        # ffff80000011218a <con+0xa>
ffff800000100bde:	66 39 c2             	cmp    dx,ax
ffff800000100be1:	72 0a                	jb     ffff800000100bed <console_putc+0x168>
            console_clear();
ffff800000100be3:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100be8:	e8 75 fe ff ff       	call   ffff800000100a62 <console_clear>
        }
        con.cur_x = 0;
ffff800000100bed:	66 c7 05 96 15 01 00 	mov    WORD PTR [rip+0x11596],0x0        # ffff80000011218c <con+0xc>
ffff800000100bf4:	00 00 
    }

    return c;
ffff800000100bf6:	0f be 45 ec          	movsx  eax,BYTE PTR [rbp-0x14]
}
ffff800000100bfa:	c9                   	leave
ffff800000100bfb:	c3                   	ret

ffff800000100bfc <console_write>:

#include <irq.h>

size_t console_write (char *s)
{
ffff800000100bfc:	55                   	push   rbp
ffff800000100bfd:	48 89 e5             	mov    rbp,rsp
ffff800000100c00:	48 83 ec 20          	sub    rsp,0x20
ffff800000100c04:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
    char *p;

    UNINTR_AREA({
ffff800000100c08:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100c0d:	e8 6e 48 00 00       	call   ffff800000105480 <intr_get>
ffff800000100c12:	88 45 f7             	mov    BYTE PTR [rbp-0x9],al
ffff800000100c15:	fa                   	cli
ffff800000100c16:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000100c1a:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
ffff800000100c1e:	eb 16                	jmp    ffff800000100c36 <console_write+0x3a>
ffff800000100c20:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000100c24:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000100c27:	0f be c0             	movsx  eax,al
ffff800000100c2a:	89 c7                	mov    edi,eax
ffff800000100c2c:	e8 54 fe ff ff       	call   ffff800000100a85 <console_putc>
ffff800000100c31:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
ffff800000100c36:	48 83 7d f8 00       	cmp    QWORD PTR [rbp-0x8],0x0
ffff800000100c3b:	74 0b                	je     ffff800000100c48 <console_write+0x4c>
ffff800000100c3d:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000100c41:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000100c44:	84 c0                	test   al,al
ffff800000100c46:	75 d8                	jne    ffff800000100c20 <console_write+0x24>
ffff800000100c48:	80 7d f7 00          	cmp    BYTE PTR [rbp-0x9],0x0
ffff800000100c4c:	74 01                	je     ffff800000100c4f <console_write+0x53>
ffff800000100c4e:	fb                   	sti
        for (p = s ; p && *p ; p++)
            console_putc (*p);
    });

    return (size_t)(p - s);
ffff800000100c4f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000100c53:	48 2b 45 e8          	sub    rax,QWORD PTR [rbp-0x18]
}
ffff800000100c57:	c9                   	leave
ffff800000100c58:	c3                   	ret

ffff800000100c59 <console_init>:

void console_init ()
{
ffff800000100c59:	55                   	push   rbp
ffff800000100c5a:	48 89 e5             	mov    rbp,rsp
ffff800000100c5d:	48 83 ec 10          	sub    rsp,0x10
    screen_info (&con.hor, &con.ver);
ffff800000100c61:	48 8d 05 1c 15 01 00 	lea    rax,[rip+0x1151c]        # ffff800000112184 <con+0x4>
ffff800000100c68:	48 89 c6             	mov    rsi,rax
ffff800000100c6b:	48 8d 05 0e 15 01 00 	lea    rax,[rip+0x1150e]        # ffff800000112180 <con>
ffff800000100c72:	48 89 c7             	mov    rdi,rax
ffff800000100c75:	e8 f6 2a 00 00       	call   ffff800000103770 <screen_info>

    con.cur_x = 0;
ffff800000100c7a:	66 c7 05 09 15 01 00 	mov    WORD PTR [rip+0x11509],0x0        # ffff80000011218c <con+0xc>
ffff800000100c81:	00 00 
    con.cur_y = 0;
ffff800000100c83:	66 c7 05 02 15 01 00 	mov    WORD PTR [rip+0x11502],0x0        # ffff80000011218e <con+0xe>
ffff800000100c8a:	00 00 

    font_t *font = font_get(0);
ffff800000100c8c:	bf 00 00 00 00       	mov    edi,0x0
ffff800000100c91:	e8 e5 2c 00 00       	call   ffff80000010397b <font_get>
ffff800000100c96:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    con.font = font;
ffff800000100c9a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000100c9e:	48 89 05 f3 14 01 00 	mov    QWORD PTR [rip+0x114f3],rax        # ffff800000112198 <con+0x18>

    con.row = con.hor / font->w;
ffff800000100ca5:	8b 05 d5 14 01 00    	mov    eax,DWORD PTR [rip+0x114d5]        # ffff800000112180 <con>
ffff800000100cab:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
ffff800000100caf:	0f b6 52 08          	movzx  edx,BYTE PTR [rdx+0x8]
ffff800000100cb3:	0f b6 ca             	movzx  ecx,dl
ffff800000100cb6:	ba 00 00 00 00       	mov    edx,0x0
ffff800000100cbb:	f7 f1                	div    ecx
ffff800000100cbd:	66 89 05 c4 14 01 00 	mov    WORD PTR [rip+0x114c4],ax        # ffff800000112188 <con+0x8>
    con.col = con.ver / font->h;
ffff800000100cc4:	8b 05 ba 14 01 00    	mov    eax,DWORD PTR [rip+0x114ba]        # ffff800000112184 <con+0x4>
ffff800000100cca:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
ffff800000100cce:	0f b6 52 09          	movzx  edx,BYTE PTR [rdx+0x9]
ffff800000100cd2:	0f b6 f2             	movzx  esi,dl
ffff800000100cd5:	ba 00 00 00 00       	mov    edx,0x0
ffff800000100cda:	f7 f6                	div    esi
ffff800000100cdc:	66 89 05 a7 14 01 00 	mov    WORD PTR [rip+0x114a7],ax        # ffff80000011218a <con+0xa>

    con.bg = 0x00000000;
ffff800000100ce3:	c7 05 a7 14 01 00 00 	mov    DWORD PTR [rip+0x114a7],0x0        # ffff800000112194 <con+0x14>
ffff800000100cea:	00 00 00 
    con.fg = 0x00ffffff;
ffff800000100ced:	c7 05 99 14 01 00 ff 	mov    DWORD PTR [rip+0x11499],0xffffff        # ffff800000112190 <con+0x10>
ffff800000100cf4:	ff ff 00 
}
ffff800000100cf7:	90                   	nop
ffff800000100cf8:	c9                   	leave
ffff800000100cf9:	c3                   	ret

ffff800000100cfa <printk>:
#include <textos/klib/vsprintf.h>

#define PRINTK_BUFFER_MAX 256

size_t printk (const char *Format, ...)
{
ffff800000100cfa:	55                   	push   rbp
ffff800000100cfb:	48 89 e5             	mov    rbp,rsp
ffff800000100cfe:	48 81 ec e0 01 00 00 	sub    rsp,0x1e0
ffff800000100d05:	48 89 bd 28 fe ff ff 	mov    QWORD PTR [rbp-0x1d8],rdi
ffff800000100d0c:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
ffff800000100d13:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
ffff800000100d1a:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
ffff800000100d21:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
ffff800000100d28:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
ffff800000100d2f:	84 c0                	test   al,al
ffff800000100d31:	74 20                	je     ffff800000100d53 <printk+0x59>
ffff800000100d33:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
ffff800000100d37:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
ffff800000100d3b:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
ffff800000100d3f:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
ffff800000100d43:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
ffff800000100d47:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
ffff800000100d4b:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
ffff800000100d4f:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
    va_list args;
    va_start (args, Format);
ffff800000100d53:	c7 85 30 ff ff ff 08 	mov    DWORD PTR [rbp-0xd0],0x8
ffff800000100d5a:	00 00 00 
ffff800000100d5d:	c7 85 34 ff ff ff 30 	mov    DWORD PTR [rbp-0xcc],0x30
ffff800000100d64:	00 00 00 
ffff800000100d67:	48 8d 45 10          	lea    rax,[rbp+0x10]
ffff800000100d6b:	48 89 85 38 ff ff ff 	mov    QWORD PTR [rbp-0xc8],rax
ffff800000100d72:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
ffff800000100d79:	48 89 85 40 ff ff ff 	mov    QWORD PTR [rbp-0xc0],rax

    char buf[PRINTK_BUFFER_MAX] = {0};
ffff800000100d80:	48 c7 85 30 fe ff ff 	mov    QWORD PTR [rbp-0x1d0],0x0
ffff800000100d87:	00 00 00 00 
ffff800000100d8b:	48 c7 85 38 fe ff ff 	mov    QWORD PTR [rbp-0x1c8],0x0
ffff800000100d92:	00 00 00 00 
ffff800000100d96:	48 c7 85 40 fe ff ff 	mov    QWORD PTR [rbp-0x1c0],0x0
ffff800000100d9d:	00 00 00 00 
ffff800000100da1:	48 c7 85 48 fe ff ff 	mov    QWORD PTR [rbp-0x1b8],0x0
ffff800000100da8:	00 00 00 00 
ffff800000100dac:	48 c7 85 50 fe ff ff 	mov    QWORD PTR [rbp-0x1b0],0x0
ffff800000100db3:	00 00 00 00 
ffff800000100db7:	48 c7 85 58 fe ff ff 	mov    QWORD PTR [rbp-0x1a8],0x0
ffff800000100dbe:	00 00 00 00 
ffff800000100dc2:	48 c7 85 60 fe ff ff 	mov    QWORD PTR [rbp-0x1a0],0x0
ffff800000100dc9:	00 00 00 00 
ffff800000100dcd:	48 c7 85 68 fe ff ff 	mov    QWORD PTR [rbp-0x198],0x0
ffff800000100dd4:	00 00 00 00 
ffff800000100dd8:	48 c7 85 70 fe ff ff 	mov    QWORD PTR [rbp-0x190],0x0
ffff800000100ddf:	00 00 00 00 
ffff800000100de3:	48 c7 85 78 fe ff ff 	mov    QWORD PTR [rbp-0x188],0x0
ffff800000100dea:	00 00 00 00 
ffff800000100dee:	48 c7 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],0x0
ffff800000100df5:	00 00 00 00 
ffff800000100df9:	48 c7 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],0x0
ffff800000100e00:	00 00 00 00 
ffff800000100e04:	48 c7 85 90 fe ff ff 	mov    QWORD PTR [rbp-0x170],0x0
ffff800000100e0b:	00 00 00 00 
ffff800000100e0f:	48 c7 85 98 fe ff ff 	mov    QWORD PTR [rbp-0x168],0x0
ffff800000100e16:	00 00 00 00 
ffff800000100e1a:	48 c7 85 a0 fe ff ff 	mov    QWORD PTR [rbp-0x160],0x0
ffff800000100e21:	00 00 00 00 
ffff800000100e25:	48 c7 85 a8 fe ff ff 	mov    QWORD PTR [rbp-0x158],0x0
ffff800000100e2c:	00 00 00 00 
ffff800000100e30:	48 c7 85 b0 fe ff ff 	mov    QWORD PTR [rbp-0x150],0x0
ffff800000100e37:	00 00 00 00 
ffff800000100e3b:	48 c7 85 b8 fe ff ff 	mov    QWORD PTR [rbp-0x148],0x0
ffff800000100e42:	00 00 00 00 
ffff800000100e46:	48 c7 85 c0 fe ff ff 	mov    QWORD PTR [rbp-0x140],0x0
ffff800000100e4d:	00 00 00 00 
ffff800000100e51:	48 c7 85 c8 fe ff ff 	mov    QWORD PTR [rbp-0x138],0x0
ffff800000100e58:	00 00 00 00 
ffff800000100e5c:	48 c7 85 d0 fe ff ff 	mov    QWORD PTR [rbp-0x130],0x0
ffff800000100e63:	00 00 00 00 
ffff800000100e67:	48 c7 85 d8 fe ff ff 	mov    QWORD PTR [rbp-0x128],0x0
ffff800000100e6e:	00 00 00 00 
ffff800000100e72:	48 c7 85 e0 fe ff ff 	mov    QWORD PTR [rbp-0x120],0x0
ffff800000100e79:	00 00 00 00 
ffff800000100e7d:	48 c7 85 e8 fe ff ff 	mov    QWORD PTR [rbp-0x118],0x0
ffff800000100e84:	00 00 00 00 
ffff800000100e88:	48 c7 85 f0 fe ff ff 	mov    QWORD PTR [rbp-0x110],0x0
ffff800000100e8f:	00 00 00 00 
ffff800000100e93:	48 c7 85 f8 fe ff ff 	mov    QWORD PTR [rbp-0x108],0x0
ffff800000100e9a:	00 00 00 00 
ffff800000100e9e:	48 c7 85 00 ff ff ff 	mov    QWORD PTR [rbp-0x100],0x0
ffff800000100ea5:	00 00 00 00 
ffff800000100ea9:	48 c7 85 08 ff ff ff 	mov    QWORD PTR [rbp-0xf8],0x0
ffff800000100eb0:	00 00 00 00 
ffff800000100eb4:	48 c7 85 10 ff ff ff 	mov    QWORD PTR [rbp-0xf0],0x0
ffff800000100ebb:	00 00 00 00 
ffff800000100ebf:	48 c7 85 18 ff ff ff 	mov    QWORD PTR [rbp-0xe8],0x0
ffff800000100ec6:	00 00 00 00 
ffff800000100eca:	48 c7 85 20 ff ff ff 	mov    QWORD PTR [rbp-0xe0],0x0
ffff800000100ed1:	00 00 00 00 
ffff800000100ed5:	48 c7 85 28 ff ff ff 	mov    QWORD PTR [rbp-0xd8],0x0
ffff800000100edc:	00 00 00 00 

    size_t i = vsprintf (buf, Format, args);
ffff800000100ee0:	48 8d 95 30 ff ff ff 	lea    rdx,[rbp-0xd0]
ffff800000100ee7:	48 8b 8d 28 fe ff ff 	mov    rcx,QWORD PTR [rbp-0x1d8]
ffff800000100eee:	48 8d 85 30 fe ff ff 	lea    rax,[rbp-0x1d0]
ffff800000100ef5:	48 89 ce             	mov    rsi,rcx
ffff800000100ef8:	48 89 c7             	mov    rdi,rax
ffff800000100efb:	e8 0d 08 00 00       	call   ffff80000010170d <vsprintf>
ffff800000100f00:	48 89 85 48 ff ff ff 	mov    QWORD PTR [rbp-0xb8],rax
    console_write (buf);
ffff800000100f07:	48 8d 85 30 fe ff ff 	lea    rax,[rbp-0x1d0]
ffff800000100f0e:	48 89 c7             	mov    rdi,rax
ffff800000100f11:	e8 e6 fc ff ff       	call   ffff800000100bfc <console_write>
    serial_write (buf, -1);
ffff800000100f16:	48 8d 85 30 fe ff ff 	lea    rax,[rbp-0x1d0]
ffff800000100f1d:	48 c7 c6 ff ff ff ff 	mov    rsi,0xffffffffffffffff
ffff800000100f24:	48 89 c7             	mov    rdi,rax
ffff800000100f27:	e8 c0 2b 00 00       	call   ffff800000103aec <serial_write>

    va_end (args);
    return i;
ffff800000100f2c:	48 8b 85 48 ff ff ff 	mov    rax,QWORD PTR [rbp-0xb8]
}
ffff800000100f33:	c9                   	leave
ffff800000100f34:	c3                   	ret

ffff800000100f35 <_getfree>:
task_t *table[TASK_MAX];

#define TASK_FREE NULL

static int _getfree ()
{
ffff800000100f35:	55                   	push   rbp
ffff800000100f36:	48 89 e5             	mov    rbp,rsp
    for (int i = 0; i < TASK_MAX ;i++)
ffff800000100f39:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
ffff800000100f40:	eb 26                	jmp    ffff800000100f68 <_getfree+0x33>
        if (table[i] == TASK_FREE)
ffff800000100f42:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff800000100f45:	48 98                	cdqe
ffff800000100f47:	48 8d 14 c5 00 00 00 	lea    rdx,[rax*8+0x0]
ffff800000100f4e:	00 
ffff800000100f4f:	48 8d 05 4a 12 01 00 	lea    rax,[rip+0x1124a]        # ffff8000001121a0 <table>
ffff800000100f56:	48 8b 04 02          	mov    rax,QWORD PTR [rdx+rax*1]
ffff800000100f5a:	48 85 c0             	test   rax,rax
ffff800000100f5d:	75 05                	jne    ffff800000100f64 <_getfree+0x2f>
            return i;
ffff800000100f5f:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff800000100f62:	eb 0f                	jmp    ffff800000100f73 <_getfree+0x3e>
    for (int i = 0; i < TASK_MAX ;i++)
ffff800000100f64:	83 45 fc 01          	add    DWORD PTR [rbp-0x4],0x1
ffff800000100f68:	83 7d fc 0f          	cmp    DWORD PTR [rbp-0x4],0xf
ffff800000100f6c:	7e d4                	jle    ffff800000100f42 <_getfree+0xd>

    return -1;
ffff800000100f6e:	b8 ff ff ff ff       	mov    eax,0xffffffff
}
ffff800000100f73:	5d                   	pop    rbp
ffff800000100f74:	c3                   	ret

ffff800000100f75 <_task_create>:

/* Register tasks into table */
static task_t *_task_create ()
{
ffff800000100f75:	55                   	push   rbp
ffff800000100f76:	48 89 e5             	mov    rbp,rsp
ffff800000100f79:	48 83 ec 10          	sub    rsp,0x10
    int pid;
    task_t *tsk;

    if ((pid = _getfree()) < 0)
ffff800000100f7d:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100f82:	e8 ae ff ff ff       	call   ffff800000100f35 <_getfree>
ffff800000100f87:	89 45 fc             	mov    DWORD PTR [rbp-0x4],eax
ffff800000100f8a:	83 7d fc 00          	cmp    DWORD PTR [rbp-0x4],0x0
ffff800000100f8e:	79 07                	jns    ffff800000100f97 <_task_create+0x22>
        return NULL;
ffff800000100f90:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100f95:	eb 3c                	jmp    ffff800000100fd3 <_task_create+0x5e>

    tsk = vmm_allocpages (TASK_PAGE, PE_P | PE_RW);
ffff800000100f97:	be 03 00 00 00       	mov    esi,0x3
ffff800000100f9c:	bf 01 00 00 00       	mov    edi,0x1
ffff800000100fa1:	e8 be 1b 00 00       	call   ffff800000102b64 <vmm_allocpages>
ffff800000100fa6:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
    tsk->pid = pid;
ffff800000100faa:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000100fae:	8b 55 fc             	mov    edx,DWORD PTR [rbp-0x4]
ffff800000100fb1:	89 10                	mov    DWORD PTR [rax],edx

    table[pid] = tsk;
ffff800000100fb3:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff800000100fb6:	48 98                	cdqe
ffff800000100fb8:	48 8d 0c c5 00 00 00 	lea    rcx,[rax*8+0x0]
ffff800000100fbf:	00 
ffff800000100fc0:	48 8d 15 d9 11 01 00 	lea    rdx,[rip+0x111d9]        # ffff8000001121a0 <table>
ffff800000100fc7:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000100fcb:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax

    return tsk;
ffff800000100fcf:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
}
ffff800000100fd3:	c9                   	leave
ffff800000100fd4:	c3                   	ret

ffff800000100fd5 <task_create>:

#include <gdt.h>
#include <intr.h>

task_t *task_create (void *main)
{
ffff800000100fd5:	55                   	push   rbp
ffff800000100fd6:	48 89 e5             	mov    rbp,rsp
ffff800000100fd9:	48 83 ec 30          	sub    rsp,0x30
ffff800000100fdd:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
    task_t *tsk = _task_create();
ffff800000100fe1:	b8 00 00 00 00       	mov    eax,0x0
ffff800000100fe6:	e8 8a ff ff ff       	call   ffff800000100f75 <_task_create>
ffff800000100feb:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

    void *stack = (void *)tsk + TASK_SIZ;
ffff800000100fef:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000100ff3:	48 05 00 10 00 00    	add    rax,0x1000
ffff800000100ff9:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
    intr_frame_t *iframe = stack - sizeof(intr_frame_t);
ffff800000100ffd:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101001:	48 2d b0 00 00 00    	sub    rax,0xb0
ffff800000101007:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
    
    iframe->rip = (u64)main;
ffff80000010100b:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
ffff80000010100f:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000101013:	48 89 90 88 00 00 00 	mov    QWORD PTR [rax+0x88],rdx
    iframe->rflags = (1 << 9);
ffff80000010101a:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff80000010101e:	48 c7 80 98 00 00 00 	mov    QWORD PTR [rax+0x98],0x200
ffff800000101025:	00 02 00 00 
    iframe->cs = KERN_CODE_SEG << 3;
ffff800000101029:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff80000010102d:	48 c7 80 90 00 00 00 	mov    QWORD PTR [rax+0x90],0x8
ffff800000101034:	08 00 00 00 
    iframe->rbp = (u64)stack;
ffff800000101038:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
ffff80000010103c:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000101040:	48 89 50 50          	mov    QWORD PTR [rax+0x50],rdx
    iframe->rsp = (u64)stack;
ffff800000101044:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
ffff800000101048:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff80000010104c:	48 89 90 a0 00 00 00 	mov    QWORD PTR [rax+0xa0],rdx

    task_frame_t *frame = stack - sizeof(intr_frame_t) - sizeof(task_frame_t);
ffff800000101053:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101057:	48 2d e8 00 00 00    	sub    rax,0xe8
ffff80000010105d:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
    frame->rip = (u64)intr_exit;
ffff800000101061:	48 8b 05 80 00 01 00 	mov    rax,QWORD PTR [rip+0x10080]        # ffff8000001110e8 <cnt+0x8>
ffff800000101068:	48 89 c2             	mov    rdx,rax
ffff80000010106b:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff80000010106f:	48 89 50 30          	mov    QWORD PTR [rax+0x30],rdx

    tsk->frame = frame;
ffff800000101073:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101077:	48 8b 55 e0          	mov    rdx,QWORD PTR [rbp-0x20]
ffff80000010107b:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
    tsk->stat  = TASK_PRE;
ffff80000010107f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101083:	c7 40 04 01 00 00 00 	mov    DWORD PTR [rax+0x4],0x1

    return tsk;
ffff80000010108a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
}
ffff80000010108e:	c9                   	leave
ffff80000010108f:	c3                   	ret

ffff800000101090 <_task_kern>:

static void _task_kern ()
{
ffff800000101090:	55                   	push   rbp
ffff800000101091:	48 89 e5             	mov    rbp,rsp
    task_create (NULL)->stat = TASK_RUN;
ffff800000101094:	bf 00 00 00 00       	mov    edi,0x0
ffff800000101099:	e8 37 ff ff ff       	call   ffff800000100fd5 <task_create>
ffff80000010109e:	c7 40 04 02 00 00 00 	mov    DWORD PTR [rax+0x4],0x2
}
ffff8000001010a5:	90                   	nop
ffff8000001010a6:	5d                   	pop    rbp
ffff8000001010a7:	c3                   	ret

ffff8000001010a8 <_getnext>:

static int _curr;

static inline task_t *_getnext ()
{
ffff8000001010a8:	55                   	push   rbp
ffff8000001010a9:	48 89 e5             	mov    rbp,rsp
    task_t *tsk = NULL;
ffff8000001010ac:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
ffff8000001010b3:	00 

    for (int i = _curr, j = 0; i < TASK_MAX && j < _curr + TASK_MAX
ffff8000001010b4:	8b 05 6a 11 01 00    	mov    eax,DWORD PTR [rip+0x1116a]        # ffff800000112224 <_curr>
ffff8000001010ba:	89 45 fc             	mov    DWORD PTR [rbp-0x4],eax
ffff8000001010bd:	c7 45 f8 00 00 00 00 	mov    DWORD PTR [rbp-0x8],0x0
ffff8000001010c4:	eb 7d                	jmp    ffff800000101143 <_getnext+0x9b>
            ;i = (i + 1) % TASK_MAX, j++)
    {
        if (table[i] == TASK_FREE)
ffff8000001010c6:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff8000001010c9:	48 98                	cdqe
ffff8000001010cb:	48 8d 14 c5 00 00 00 	lea    rdx,[rax*8+0x0]
ffff8000001010d2:	00 
ffff8000001010d3:	48 8d 05 c6 10 01 00 	lea    rax,[rip+0x110c6]        # ffff8000001121a0 <table>
ffff8000001010da:	48 8b 04 02          	mov    rax,QWORD PTR [rdx+rax*1]
ffff8000001010de:	48 85 c0             	test   rax,rax
ffff8000001010e1:	74 43                	je     ffff800000101126 <_getnext+0x7e>
            continue;
        if (table[i]->stat == TASK_PRE) {
ffff8000001010e3:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff8000001010e6:	48 98                	cdqe
ffff8000001010e8:	48 8d 14 c5 00 00 00 	lea    rdx,[rax*8+0x0]
ffff8000001010ef:	00 
ffff8000001010f0:	48 8d 05 a9 10 01 00 	lea    rax,[rip+0x110a9]        # ffff8000001121a0 <table>
ffff8000001010f7:	48 8b 04 02          	mov    rax,QWORD PTR [rdx+rax*1]
ffff8000001010fb:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
ffff8000001010fe:	83 f8 01             	cmp    eax,0x1
ffff800000101101:	75 24                	jne    ffff800000101127 <_getnext+0x7f>
            _curr = i;
ffff800000101103:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff800000101106:	89 05 18 11 01 00    	mov    DWORD PTR [rip+0x11118],eax        # ffff800000112224 <_curr>
            return table[i];
ffff80000010110c:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff80000010110f:	48 98                	cdqe
ffff800000101111:	48 8d 14 c5 00 00 00 	lea    rdx,[rax*8+0x0]
ffff800000101118:	00 
ffff800000101119:	48 8d 05 80 10 01 00 	lea    rax,[rip+0x11080]        # ffff8000001121a0 <table>
ffff800000101120:	48 8b 04 02          	mov    rax,QWORD PTR [rdx+rax*1]
ffff800000101124:	eb 3a                	jmp    ffff800000101160 <_getnext+0xb8>
            continue;
ffff800000101126:	90                   	nop
            ;i = (i + 1) % TASK_MAX, j++)
ffff800000101127:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff80000010112a:	8d 50 01             	lea    edx,[rax+0x1]
ffff80000010112d:	89 d0                	mov    eax,edx
ffff80000010112f:	c1 f8 1f             	sar    eax,0x1f
ffff800000101132:	c1 e8 1c             	shr    eax,0x1c
ffff800000101135:	01 c2                	add    edx,eax
ffff800000101137:	83 e2 0f             	and    edx,0xf
ffff80000010113a:	29 c2                	sub    edx,eax
ffff80000010113c:	89 55 fc             	mov    DWORD PTR [rbp-0x4],edx
ffff80000010113f:	83 45 f8 01          	add    DWORD PTR [rbp-0x8],0x1
    for (int i = _curr, j = 0; i < TASK_MAX && j < _curr + TASK_MAX
ffff800000101143:	83 7d fc 0f          	cmp    DWORD PTR [rbp-0x4],0xf
ffff800000101147:	7f 12                	jg     ffff80000010115b <_getnext+0xb3>
ffff800000101149:	8b 05 d5 10 01 00    	mov    eax,DWORD PTR [rip+0x110d5]        # ffff800000112224 <_curr>
ffff80000010114f:	83 c0 0f             	add    eax,0xf
ffff800000101152:	39 45 f8             	cmp    DWORD PTR [rbp-0x8],eax
ffff800000101155:	0f 8e 6b ff ff ff    	jle    ffff8000001010c6 <_getnext+0x1e>
        }
    }

    return NULL;
ffff80000010115b:	b8 00 00 00 00       	mov    eax,0x0
}
ffff800000101160:	5d                   	pop    rbp
ffff800000101161:	c3                   	ret

ffff800000101162 <task_current>:

task_t *task_current ()
{
ffff800000101162:	55                   	push   rbp
ffff800000101163:	48 89 e5             	mov    rbp,rsp
    return table[_curr];
ffff800000101166:	8b 05 b8 10 01 00    	mov    eax,DWORD PTR [rip+0x110b8]        # ffff800000112224 <_curr>
ffff80000010116c:	48 98                	cdqe
ffff80000010116e:	48 8d 14 c5 00 00 00 	lea    rdx,[rax*8+0x0]
ffff800000101175:	00 
ffff800000101176:	48 8d 05 23 10 01 00 	lea    rax,[rip+0x11023]        # ffff8000001121a0 <table>
ffff80000010117d:	48 8b 04 02          	mov    rax,QWORD PTR [rdx+rax*1]
}
ffff800000101181:	5d                   	pop    rbp
ffff800000101182:	c3                   	ret

ffff800000101183 <task_schedule>:

#include <irq.h>
#include <textos/printk.h>

void task_schedule ()
{
ffff800000101183:	55                   	push   rbp
ffff800000101184:	48 89 e5             	mov    rbp,rsp
ffff800000101187:	48 83 ec 10          	sub    rsp,0x10
    task_t *curr = task_current(); /* Get curr first becase _getnext() will change `_curr` */
ffff80000010118b:	b8 00 00 00 00       	mov    eax,0x0
ffff800000101190:	e8 cd ff ff ff       	call   ffff800000101162 <task_current>
ffff800000101195:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    if (!curr)
ffff800000101199:	48 83 7d f8 00       	cmp    QWORD PTR [rbp-0x8],0x0
ffff80000010119e:	74 59                	je     ffff8000001011f9 <task_schedule+0x76>
        return;

    task_t *next = _getnext();
ffff8000001011a0:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001011a5:	e8 fe fe ff ff       	call   ffff8000001010a8 <_getnext>
ffff8000001011aa:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
    if (!next)
ffff8000001011ae:	48 83 7d f0 00       	cmp    QWORD PTR [rbp-0x10],0x0
ffff8000001011b3:	74 47                	je     ffff8000001011fc <task_schedule+0x79>
        return;

    curr->stat = TASK_PRE;
ffff8000001011b5:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001011b9:	c7 40 04 01 00 00 00 	mov    DWORD PTR [rax+0x4],0x1
    next->stat = TASK_RUN;
ffff8000001011c0:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff8000001011c4:	c7 40 04 02 00 00 00 	mov    DWORD PTR [rax+0x4],0x2
    next->schd++;
ffff8000001011cb:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff8000001011cf:	8b 40 08             	mov    eax,DWORD PTR [rax+0x8]
ffff8000001011d2:	8d 50 01             	lea    edx,[rax+0x1]
ffff8000001011d5:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff8000001011d9:	89 50 08             	mov    DWORD PTR [rax+0x8],edx

    __task_switch (next->frame, &curr->frame);
ffff8000001011dc:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001011e0:	48 8d 50 10          	lea    rdx,[rax+0x10]
ffff8000001011e4:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff8000001011e8:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff8000001011ec:	48 89 d6             	mov    rsi,rdx
ffff8000001011ef:	48 89 c7             	mov    rdi,rax
ffff8000001011f2:	e8 39 01 00 00       	call   ffff800000101330 <__task_switch>
ffff8000001011f7:	eb 04                	jmp    ffff8000001011fd <task_schedule+0x7a>
        return;
ffff8000001011f9:	90                   	nop
ffff8000001011fa:	eb 01                	jmp    ffff8000001011fd <task_schedule+0x7a>
        return;
ffff8000001011fc:	90                   	nop
}
ffff8000001011fd:	c9                   	leave
ffff8000001011fe:	c3                   	ret

ffff8000001011ff <__task_setif>:

void __task_setif (void *frame)
{
ffff8000001011ff:	55                   	push   rbp
ffff800000101200:	48 89 e5             	mov    rbp,rsp
ffff800000101203:	48 83 ec 08          	sub    rsp,0x8
ffff800000101207:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
    task_current()->iframe = frame;
ffff80000010120b:	b8 00 00 00 00       	mov    eax,0x0
ffff800000101210:	e8 4d ff ff ff       	call   ffff800000101162 <task_current>
ffff800000101215:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
ffff800000101219:	48 89 50 18          	mov    QWORD PTR [rax+0x18],rdx
}
ffff80000010121d:	90                   	nop
ffff80000010121e:	c9                   	leave
ffff80000010121f:	c3                   	ret

ffff800000101220 <task_yield>:

void task_yield ()
{
ffff800000101220:	55                   	push   rbp
ffff800000101221:	48 89 e5             	mov    rbp,rsp
    task_schedule();
ffff800000101224:	b8 00 00 00 00       	mov    eax,0x0
ffff800000101229:	e8 55 ff ff ff       	call   ffff800000101183 <task_schedule>
}
ffff80000010122e:	90                   	nop
ffff80000010122f:	5d                   	pop    rbp
ffff800000101230:	c3                   	ret

ffff800000101231 <proc_a>:
#define N 200000

volatile int a = 0;

void proc_a ()
{
ffff800000101231:	55                   	push   rbp
ffff800000101232:	48 89 e5             	mov    rbp,rsp
ffff800000101235:	48 83 ec 10          	sub    rsp,0x10
    for (int i = 0 ; i < N ; i++) {
ffff800000101239:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
ffff800000101240:	eb 31                	jmp    ffff800000101273 <proc_a+0x42>
        printk ("PROC[#%d] a = %d\n", _curr, a++);
ffff800000101242:	8b 05 d8 0f 01 00    	mov    eax,DWORD PTR [rip+0x10fd8]        # ffff800000112220 <a>
ffff800000101248:	8d 50 01             	lea    edx,[rax+0x1]
ffff80000010124b:	89 15 cf 0f 01 00    	mov    DWORD PTR [rip+0x10fcf],edx        # ffff800000112220 <a>
ffff800000101251:	8b 0d cd 0f 01 00    	mov    ecx,DWORD PTR [rip+0x10fcd]        # ffff800000112224 <_curr>
ffff800000101257:	89 c2                	mov    edx,eax
ffff800000101259:	89 ce                	mov    esi,ecx
ffff80000010125b:	48 8d 05 ab 4f 00 00 	lea    rax,[rip+0x4fab]        # ffff80000010620d <intr_get+0xd8d>
ffff800000101262:	48 89 c7             	mov    rdi,rax
ffff800000101265:	b8 00 00 00 00       	mov    eax,0x0
ffff80000010126a:	e8 8b fa ff ff       	call   ffff800000100cfa <printk>
    for (int i = 0 ; i < N ; i++) {
ffff80000010126f:	83 45 fc 01          	add    DWORD PTR [rbp-0x4],0x1
ffff800000101273:	81 7d fc 3f 0d 03 00 	cmp    DWORD PTR [rbp-0x4],0x30d3f
ffff80000010127a:	7e c6                	jle    ffff800000101242 <proc_a+0x11>
    }
    while (true) {}
ffff80000010127c:	eb fe                	jmp    ffff80000010127c <proc_a+0x4b>

ffff80000010127e <proc_b>:
}

void proc_b ()
{
ffff80000010127e:	55                   	push   rbp
ffff80000010127f:	48 89 e5             	mov    rbp,rsp
ffff800000101282:	48 83 ec 10          	sub    rsp,0x10
    for (int i = 0 ; i < N ; i++) {
ffff800000101286:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
ffff80000010128d:	eb 31                	jmp    ffff8000001012c0 <proc_b+0x42>
        printk ("PROC[#%d] a = %d\n", _curr, a++);
ffff80000010128f:	8b 05 8b 0f 01 00    	mov    eax,DWORD PTR [rip+0x10f8b]        # ffff800000112220 <a>
ffff800000101295:	8d 50 01             	lea    edx,[rax+0x1]
ffff800000101298:	89 15 82 0f 01 00    	mov    DWORD PTR [rip+0x10f82],edx        # ffff800000112220 <a>
ffff80000010129e:	8b 0d 80 0f 01 00    	mov    ecx,DWORD PTR [rip+0x10f80]        # ffff800000112224 <_curr>
ffff8000001012a4:	89 c2                	mov    edx,eax
ffff8000001012a6:	89 ce                	mov    esi,ecx
ffff8000001012a8:	48 8d 05 5e 4f 00 00 	lea    rax,[rip+0x4f5e]        # ffff80000010620d <intr_get+0xd8d>
ffff8000001012af:	48 89 c7             	mov    rdi,rax
ffff8000001012b2:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001012b7:	e8 3e fa ff ff       	call   ffff800000100cfa <printk>
    for (int i = 0 ; i < N ; i++) {
ffff8000001012bc:	83 45 fc 01          	add    DWORD PTR [rbp-0x4],0x1
ffff8000001012c0:	81 7d fc 3f 0d 03 00 	cmp    DWORD PTR [rbp-0x4],0x30d3f
ffff8000001012c7:	7e c6                	jle    ffff80000010128f <proc_b+0x11>
    }
    while (true) {}
ffff8000001012c9:	eb fe                	jmp    ffff8000001012c9 <proc_b+0x4b>

ffff8000001012cb <task_init>:
}

void task_init ()
{
ffff8000001012cb:	55                   	push   rbp
ffff8000001012cc:	48 89 e5             	mov    rbp,rsp
ffff8000001012cf:	48 83 ec 10          	sub    rsp,0x10
    for (int i = 0; i < TASK_MAX ;i++)
ffff8000001012d3:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
ffff8000001012da:	eb 20                	jmp    ffff8000001012fc <task_init+0x31>
    {
        table[i] = TASK_FREE;
ffff8000001012dc:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff8000001012df:	48 98                	cdqe
ffff8000001012e1:	48 8d 14 c5 00 00 00 	lea    rdx,[rax*8+0x0]
ffff8000001012e8:	00 
ffff8000001012e9:	48 8d 05 b0 0e 01 00 	lea    rax,[rip+0x10eb0]        # ffff8000001121a0 <table>
ffff8000001012f0:	48 c7 04 02 00 00 00 	mov    QWORD PTR [rdx+rax*1],0x0
ffff8000001012f7:	00 
    for (int i = 0; i < TASK_MAX ;i++)
ffff8000001012f8:	83 45 fc 01          	add    DWORD PTR [rbp-0x4],0x1
ffff8000001012fc:	83 7d fc 0f          	cmp    DWORD PTR [rbp-0x4],0xf
ffff800000101300:	7e da                	jle    ffff8000001012dc <task_init+0x11>
    }

    _task_kern();
ffff800000101302:	b8 00 00 00 00       	mov    eax,0x0
ffff800000101307:	e8 84 fd ff ff       	call   ffff800000101090 <_task_kern>

    _curr = 0;
ffff80000010130c:	c7 05 0e 0f 01 00 00 	mov    DWORD PTR [rip+0x10f0e],0x0        # ffff800000112224 <_curr>
ffff800000101313:	00 00 00 

    task_create (proc_a);
ffff800000101316:	48 8d 05 14 ff ff ff 	lea    rax,[rip+0xffffffffffffff14]        # ffff800000101231 <proc_a>
ffff80000010131d:	48 89 c7             	mov    rdi,rax
ffff800000101320:	e8 b0 fc ff ff       	call   ffff800000100fd5 <task_create>
    // task_create (proc_b);
}
ffff800000101325:	90                   	nop
ffff800000101326:	c9                   	leave
ffff800000101327:	c3                   	ret
ffff800000101328:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
ffff80000010132f:	00 

ffff800000101330 <__task_switch>:
[bits 64]

global __task_switch
__task_switch:
    push rbp
ffff800000101330:	55                   	push   rbp
    mov  rbp, rsp
ffff800000101331:	48 89 e5             	mov    rbp,rsp
    
    push  rbx
ffff800000101334:	53                   	push   rbx
    push  r12
ffff800000101335:	41 54                	push   r12
    push  r13
ffff800000101337:	41 55                	push   r13
    push  r14
ffff800000101339:	41 56                	push   r14
    push  r15
ffff80000010133b:	41 57                	push   r15
    
    mov  [rsi], rsp
ffff80000010133d:	48 89 26             	mov    QWORD PTR [rsi],rsp
    mov  rsp, rdi
ffff800000101340:	48 89 fc             	mov    rsp,rdi
    
    pop  r15
ffff800000101343:	41 5f                	pop    r15
    pop  r14
ffff800000101345:	41 5e                	pop    r14
    pop  r13
ffff800000101347:	41 5d                	pop    r13
    pop  r12
ffff800000101349:	41 5c                	pop    r12
    pop  rbx
ffff80000010134b:	5b                   	pop    rbx

    pop  rbp
ffff80000010134c:	5d                   	pop    rbp
    ret
ffff80000010134d:	c3                   	ret

ffff80000010134e <qemu_exit>:
    * -device isa-debug-exit,iobase=0xf4,iosize=0x4
   
   they choose an abnormal port which is not used normally
*/
void qemu_exit ()
{
ffff80000010134e:	55                   	push   rbp
ffff80000010134f:	48 89 e5             	mov    rbp,rsp
    outw(0xf4, 0x00);
ffff800000101352:	be 00 00 00 00       	mov    esi,0x0
ffff800000101357:	bf f4 00 00 00       	mov    edi,0xf4
ffff80000010135c:	e8 90 2a 00 00       	call   ffff800000103df1 <outw>
}
ffff800000101361:	90                   	nop
ffff800000101362:	5d                   	pop    rbp
ffff800000101363:	c3                   	ret

ffff800000101364 <cpu_reset>:

/* 8042 controller */
void cpu_reset ()
{
ffff800000101364:	55                   	push   rbp
ffff800000101365:	48 89 e5             	mov    rbp,rsp
    outb(0x64, 0xfe);
ffff800000101368:	be fe 00 00 00       	mov    esi,0xfe
ffff80000010136d:	bf 64 00 00 00       	mov    edi,0x64
ffff800000101372:	e8 72 2a 00 00       	call   ffff800000103de9 <outb>
}
ffff800000101377:	90                   	nop
ffff800000101378:	5d                   	pop    rbp
ffff800000101379:	c3                   	ret

ffff80000010137a <poweroff>:

void poweroff()
{
ffff80000010137a:	55                   	push   rbp
ffff80000010137b:	48 89 e5             	mov    rbp,rsp
    qemu_exit();
ffff80000010137e:	b8 00 00 00 00       	mov    eax,0x0
ffff800000101383:	e8 c6 ff ff ff       	call   ffff80000010134e <qemu_exit>
}
ffff800000101388:	90                   	nop
ffff800000101389:	5d                   	pop    rbp
ffff80000010138a:	c3                   	ret

ffff80000010138b <strlen>:
  The strlen() function calculates the 
  length of the string pointed to by `str`,
  excluding the terminating null byte ('\0')
*/
size_t strlen (char *str)
{
ffff80000010138b:	55                   	push   rbp
ffff80000010138c:	48 89 e5             	mov    rbp,rsp
ffff80000010138f:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
    size_t i =0;
ffff800000101393:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
ffff80000010139a:	00 
    
    while (str && *str++)
ffff80000010139b:	eb 05                	jmp    ffff8000001013a2 <strlen+0x17>
        i++;
ffff80000010139d:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
    while (str && *str++)
ffff8000001013a2:	48 83 7d e8 00       	cmp    QWORD PTR [rbp-0x18],0x0
ffff8000001013a7:	74 13                	je     ffff8000001013bc <strlen+0x31>
ffff8000001013a9:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001013ad:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff8000001013b1:	48 89 55 e8          	mov    QWORD PTR [rbp-0x18],rdx
ffff8000001013b5:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff8000001013b8:	84 c0                	test   al,al
ffff8000001013ba:	75 e1                	jne    ffff80000010139d <strlen+0x12>
    return i;
ffff8000001013bc:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
}
ffff8000001013c0:	5d                   	pop    rbp
ffff8000001013c1:	c3                   	ret

ffff8000001013c2 <strcpy>:
  The strcpy() function  copies  the  string
  pointed to by `src`, including the  terminating
  null byte ('\0')
*/
char *strcpy (char *dest, const char *src)
{
ffff8000001013c2:	55                   	push   rbp
ffff8000001013c3:	48 89 e5             	mov    rbp,rsp
ffff8000001013c6:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
ffff8000001013ca:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
    char *p = dest;
ffff8000001013ce:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001013d2:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    while (p && src && *src++)
ffff8000001013d6:	eb 1d                	jmp    ffff8000001013f5 <strcpy+0x33>
        *p++ = *src++;
ffff8000001013d8:	48 8b 55 e0          	mov    rdx,QWORD PTR [rbp-0x20]
ffff8000001013dc:	48 8d 42 01          	lea    rax,[rdx+0x1]
ffff8000001013e0:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
ffff8000001013e4:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001013e8:	48 8d 48 01          	lea    rcx,[rax+0x1]
ffff8000001013ec:	48 89 4d f8          	mov    QWORD PTR [rbp-0x8],rcx
ffff8000001013f0:	0f b6 12             	movzx  edx,BYTE PTR [rdx]
ffff8000001013f3:	88 10                	mov    BYTE PTR [rax],dl
    while (p && src && *src++)
ffff8000001013f5:	48 83 7d f8 00       	cmp    QWORD PTR [rbp-0x8],0x0
ffff8000001013fa:	74 1a                	je     ffff800000101416 <strcpy+0x54>
ffff8000001013fc:	48 83 7d e0 00       	cmp    QWORD PTR [rbp-0x20],0x0
ffff800000101401:	74 13                	je     ffff800000101416 <strcpy+0x54>
ffff800000101403:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000101407:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff80000010140b:	48 89 55 e0          	mov    QWORD PTR [rbp-0x20],rdx
ffff80000010140f:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000101412:	84 c0                	test   al,al
ffff800000101414:	75 c2                	jne    ffff8000001013d8 <strcpy+0x16>
    *p++ = *src++; // copy '\0'
ffff800000101416:	48 8b 55 e0          	mov    rdx,QWORD PTR [rbp-0x20]
ffff80000010141a:	48 8d 42 01          	lea    rax,[rdx+0x1]
ffff80000010141e:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
ffff800000101422:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101426:	48 8d 48 01          	lea    rcx,[rax+0x1]
ffff80000010142a:	48 89 4d f8          	mov    QWORD PTR [rbp-0x8],rcx
ffff80000010142e:	0f b6 12             	movzx  edx,BYTE PTR [rdx]
ffff800000101431:	88 10                	mov    BYTE PTR [rax],dl

    return dest;
ffff800000101433:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
}
ffff800000101437:	5d                   	pop    rbp
ffff800000101438:	c3                   	ret

ffff800000101439 <strcmp>:

/* The  strcmp() function compares the two strings `str1` and `str2` */
int strcmp (const char* str1,const char *str2)
{
ffff800000101439:	55                   	push   rbp
ffff80000010143a:	48 89 e5             	mov    rbp,rsp
ffff80000010143d:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
ffff800000101441:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
    while (*str1 && *str2 && *str1 == *str2) {
ffff800000101445:	eb 0a                	jmp    ffff800000101451 <strcmp+0x18>
        str1++;
ffff800000101447:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
        str2++;
ffff80000010144c:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
    while (*str1 && *str2 && *str1 == *str2) {
ffff800000101451:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101455:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000101458:	84 c0                	test   al,al
ffff80000010145a:	74 1d                	je     ffff800000101479 <strcmp+0x40>
ffff80000010145c:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101460:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000101463:	84 c0                	test   al,al
ffff800000101465:	74 12                	je     ffff800000101479 <strcmp+0x40>
ffff800000101467:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010146b:	0f b6 10             	movzx  edx,BYTE PTR [rax]
ffff80000010146e:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101472:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000101475:	38 c2                	cmp    dl,al
ffff800000101477:	74 ce                	je     ffff800000101447 <strcmp+0xe>
    }
    return *str1 == *str2 ? 0
ffff800000101479:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010147d:	0f b6 10             	movzx  edx,BYTE PTR [rax]
ffff800000101480:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101484:	0f b6 00             	movzx  eax,BYTE PTR [rax]
         : *str1 >  *str2 ? 1 : -1;
ffff800000101487:	38 c2                	cmp    dl,al
ffff800000101489:	74 20                	je     ffff8000001014ab <strcmp+0x72>
ffff80000010148b:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010148f:	0f b6 10             	movzx  edx,BYTE PTR [rax]
ffff800000101492:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101496:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000101499:	38 c2                	cmp    dl,al
ffff80000010149b:	7e 07                	jle    ffff8000001014a4 <strcmp+0x6b>
ffff80000010149d:	b8 01 00 00 00       	mov    eax,0x1
ffff8000001014a2:	eb 0c                	jmp    ffff8000001014b0 <strcmp+0x77>
ffff8000001014a4:	b8 ff ff ff ff       	mov    eax,0xffffffff
ffff8000001014a9:	eb 05                	jmp    ffff8000001014b0 <strcmp+0x77>
ffff8000001014ab:	b8 00 00 00 00       	mov    eax,0x0
}
ffff8000001014b0:	5d                   	pop    rbp
ffff8000001014b1:	c3                   	ret

ffff8000001014b2 <strchr>:
/*
  The strchr() function returns a pointer to the first
  occurrence of the character `c` in the string `str`
*/
char *strchr (const char *str, int c)
{
ffff8000001014b2:	55                   	push   rbp
ffff8000001014b3:	48 89 e5             	mov    rbp,rsp
ffff8000001014b6:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
ffff8000001014ba:	89 75 f4             	mov    DWORD PTR [rbp-0xc],esi
    while (str && *str) {
ffff8000001014bd:	eb 1c                	jmp    ffff8000001014db <strchr+0x29>
        if (*str++ == (char)c)
ffff8000001014bf:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001014c3:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff8000001014c7:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
ffff8000001014cb:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff8000001014ce:	8b 55 f4             	mov    edx,DWORD PTR [rbp-0xc]
ffff8000001014d1:	38 d0                	cmp    al,dl
ffff8000001014d3:	75 06                	jne    ffff8000001014db <strchr+0x29>
            return (char *)str;
ffff8000001014d5:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001014d9:	eb 23                	jmp    ffff8000001014fe <strchr+0x4c>
    while (str && *str) {
ffff8000001014db:	48 83 7d f8 00       	cmp    QWORD PTR [rbp-0x8],0x0
ffff8000001014e0:	74 0b                	je     ffff8000001014ed <strchr+0x3b>
ffff8000001014e2:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001014e6:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff8000001014e9:	84 c0                	test   al,al
ffff8000001014eb:	75 d2                	jne    ffff8000001014bf <strchr+0xd>
    }
    if (c == '\0') {
ffff8000001014ed:	83 7d f4 00          	cmp    DWORD PTR [rbp-0xc],0x0
ffff8000001014f1:	75 06                	jne    ffff8000001014f9 <strchr+0x47>
        return (char *)str;
ffff8000001014f3:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001014f7:	eb 05                	jmp    ffff8000001014fe <strchr+0x4c>
    }

    return NULL;
ffff8000001014f9:	b8 00 00 00 00       	mov    eax,0x0
}
ffff8000001014fe:	5d                   	pop    rbp
ffff8000001014ff:	c3                   	ret

ffff800000101500 <memset>:

/*
  The  memset()  function  fills  the first `n`  bytes  of the
  memory area pointed to by `` with the constant byte `c`
*/
void *memset (void *dest, int c, size_t n) {
ffff800000101500:	55                   	push   rbp
ffff800000101501:	48 89 e5             	mov    rbp,rsp
ffff800000101504:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
ffff800000101508:	89 75 e4             	mov    DWORD PTR [rbp-0x1c],esi
ffff80000010150b:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
    u8 *p = dest;
ffff80000010150f:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000101513:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    while (n-- > 0)
ffff800000101517:	eb 11                	jmp    ffff80000010152a <memset+0x2a>
        *p++ = (u8) c;
ffff800000101519:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010151d:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff800000101521:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
ffff800000101525:	8b 55 e4             	mov    edx,DWORD PTR [rbp-0x1c]
ffff800000101528:	88 10                	mov    BYTE PTR [rax],dl
    while (n-- > 0)
ffff80000010152a:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff80000010152e:	48 8d 50 ff          	lea    rdx,[rax-0x1]
ffff800000101532:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
ffff800000101536:	48 85 c0             	test   rax,rax
ffff800000101539:	75 de                	jne    ffff800000101519 <memset+0x19>

    return dest;
ffff80000010153b:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
}
ffff80000010153f:	5d                   	pop    rbp
ffff800000101540:	c3                   	ret

ffff800000101541 <memcpy>:
/*
  The  memcpy() function  copies n  bytes
  from memory area `src` to memory area `dest`
*/
void *memcpy (void *dest, const void *src, size_t n)
{
ffff800000101541:	55                   	push   rbp
ffff800000101542:	48 89 e5             	mov    rbp,rsp
ffff800000101545:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
ffff800000101549:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
ffff80000010154d:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
    char *p = dest;
ffff800000101551:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000101555:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    while (n--) {
ffff800000101559:	eb 1d                	jmp    ffff800000101578 <memcpy+0x37>
        *p++ = *(char*)src++;
ffff80000010155b:	48 8b 55 e0          	mov    rdx,QWORD PTR [rbp-0x20]
ffff80000010155f:	48 8d 42 01          	lea    rax,[rdx+0x1]
ffff800000101563:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
ffff800000101567:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010156b:	48 8d 48 01          	lea    rcx,[rax+0x1]
ffff80000010156f:	48 89 4d f8          	mov    QWORD PTR [rbp-0x8],rcx
ffff800000101573:	0f b6 12             	movzx  edx,BYTE PTR [rdx]
ffff800000101576:	88 10                	mov    BYTE PTR [rax],dl
    while (n--) {
ffff800000101578:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff80000010157c:	48 8d 50 ff          	lea    rdx,[rax-0x1]
ffff800000101580:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
ffff800000101584:	48 85 c0             	test   rax,rax
ffff800000101587:	75 d2                	jne    ffff80000010155b <memcpy+0x1a>
    }

    return dest;
ffff800000101589:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
}
ffff80000010158d:	5d                   	pop    rbp
ffff80000010158e:	c3                   	ret

ffff80000010158f <_int>:
};

#define is_digit(c) ('0' <= (char)c && (char)c <= '9')

static int _int (char *ptr, int *width)
{
ffff80000010158f:	55                   	push   rbp
ffff800000101590:	48 89 e5             	mov    rbp,rsp
ffff800000101593:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
ffff800000101597:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
    int i = 0;
ffff80000010159b:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
    int l = 0;
ffff8000001015a2:	c7 45 f8 00 00 00 00 	mov    DWORD PTR [rbp-0x8],0x0

    while (is_digit (*ptr)) {
ffff8000001015a9:	eb 2c                	jmp    ffff8000001015d7 <_int+0x48>
        i = i * 10 + *ptr++ - '0';
ffff8000001015ab:	8b 55 fc             	mov    edx,DWORD PTR [rbp-0x4]
ffff8000001015ae:	89 d0                	mov    eax,edx
ffff8000001015b0:	c1 e0 02             	shl    eax,0x2
ffff8000001015b3:	01 d0                	add    eax,edx
ffff8000001015b5:	01 c0                	add    eax,eax
ffff8000001015b7:	89 c1                	mov    ecx,eax
ffff8000001015b9:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001015bd:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff8000001015c1:	48 89 55 e8          	mov    QWORD PTR [rbp-0x18],rdx
ffff8000001015c5:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff8000001015c8:	0f be c0             	movsx  eax,al
ffff8000001015cb:	01 c8                	add    eax,ecx
ffff8000001015cd:	83 e8 30             	sub    eax,0x30
ffff8000001015d0:	89 45 fc             	mov    DWORD PTR [rbp-0x4],eax
        l++;
ffff8000001015d3:	83 45 f8 01          	add    DWORD PTR [rbp-0x8],0x1
    while (is_digit (*ptr)) {
ffff8000001015d7:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001015db:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff8000001015de:	3c 2f                	cmp    al,0x2f
ffff8000001015e0:	7e 0b                	jle    ffff8000001015ed <_int+0x5e>
ffff8000001015e2:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001015e6:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff8000001015e9:	3c 39                	cmp    al,0x39
ffff8000001015eb:	7e be                	jle    ffff8000001015ab <_int+0x1c>
    }

    *width = i;
ffff8000001015ed:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff8000001015f1:	8b 55 fc             	mov    edx,DWORD PTR [rbp-0x4]
ffff8000001015f4:	89 10                	mov    DWORD PTR [rax],edx

    return l;
ffff8000001015f6:	8b 45 f8             	mov    eax,DWORD PTR [rbp-0x8]
}
ffff8000001015f9:	5d                   	pop    rbp
ffff8000001015fa:	c3                   	ret

ffff8000001015fb <_number>:
static const char lwstr[] = "0123456789abcdef";

#include <textos/panic.h>

static int64 _number (char *buffer, u64 num, int base, bool upper)
{
ffff8000001015fb:	55                   	push   rbp
ffff8000001015fc:	48 89 e5             	mov    rbp,rsp
ffff8000001015ff:	48 83 ec 18          	sub    rsp,0x18
ffff800000101603:	48 89 7d 88          	mov    QWORD PTR [rbp-0x78],rdi
ffff800000101607:	48 89 75 80          	mov    QWORD PTR [rbp-0x80],rsi
ffff80000010160b:	89 95 7c ff ff ff    	mov    DWORD PTR [rbp-0x84],edx
ffff800000101611:	89 c8                	mov    eax,ecx
ffff800000101613:	88 85 78 ff ff ff    	mov    BYTE PTR [rbp-0x88],al
    const char *letters = upper ? upstr : lwstr ;
ffff800000101619:	80 bd 78 ff ff ff 00 	cmp    BYTE PTR [rbp-0x88],0x0
ffff800000101620:	74 09                	je     ffff80000010162b <_number+0x30>
ffff800000101622:	48 8d 05 f7 4b 00 00 	lea    rax,[rip+0x4bf7]        # ffff800000106220 <upstr>
ffff800000101629:	eb 07                	jmp    ffff800000101632 <_number+0x37>
ffff80000010162b:	48 8d 05 0e 4c 00 00 	lea    rax,[rip+0x4c0e]        # ffff800000106240 <lwstr>
ffff800000101632:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax

    int64 siz = 0;
ffff800000101636:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
ffff80000010163d:	00 
    char tmp[64+1];

    char *ptr = tmp;
ffff80000010163e:	48 8d 45 90          	lea    rax,[rbp-0x70]
ffff800000101642:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax

    if (num == 0) {
ffff800000101646:	48 83 7d 80 00       	cmp    QWORD PTR [rbp-0x80],0x0
ffff80000010164b:	75 6b                	jne    ffff8000001016b8 <_number+0xbd>
        *ptr++ = '0';
ffff80000010164d:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101651:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff800000101655:	48 89 55 f0          	mov    QWORD PTR [rbp-0x10],rdx
ffff800000101659:	c6 00 30             	mov    BYTE PTR [rax],0x30
        siz = 1;
ffff80000010165c:	48 c7 45 f8 01 00 00 	mov    QWORD PTR [rbp-0x8],0x1
ffff800000101663:	00 
ffff800000101664:	eb 59                	jmp    ffff8000001016bf <_number+0xc4>
    } else {
        while (num != 0) {
            *ptr++ = letters[num % base];
ffff800000101666:	8b 85 7c ff ff ff    	mov    eax,DWORD PTR [rbp-0x84]
ffff80000010166c:	48 63 f0             	movsxd rsi,eax
ffff80000010166f:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]             # num
ffff800000101673:	ba 00 00 00 00       	mov    edx,0x0
ffff800000101678:	48 f7 f6             	div    rsi
ffff80000010167b:	48 89 d1             	mov    rcx,rdx
ffff80000010167e:	48 89 ca             	mov    rdx,rcx
ffff800000101681:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]             # rax = letters
ffff800000101685:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
ffff800000101689:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]             # rax = ptr
ffff80000010168d:	48 8d 50 01          	lea    rdx,[rax+0x1]                        # rdx = rax + 1
ffff800000101691:	48 89 55 f0          	mov    QWORD PTR [rbp-0x10],rdx             # ptr = rax
ffff800000101695:	0f b6 11             	movzx  edx,BYTE PTR [rcx]                   # edx = (u8)*rcx
ffff800000101698:	88 10                	mov    BYTE PTR [rax],dl                    # *ptr_old = dl
            num /= base;
ffff80000010169a:	8b 85 7c ff ff ff    	mov    eax,DWORD PTR [rbp-0x84]
ffff8000001016a0:	48 63 f8             	movsxd rdi,eax
ffff8000001016a3:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
ffff8000001016a7:	ba 00 00 00 00       	mov    edx,0x0
ffff8000001016ac:	48 f7 f7             	div    rdi
ffff8000001016af:	48 89 45 80          	mov    QWORD PTR [rbp-0x80],rax
            siz++;
ffff8000001016b3:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
        while (num != 0) {
ffff8000001016b8:	48 83 7d 80 00       	cmp    QWORD PTR [rbp-0x80],0x0
ffff8000001016bd:	75 a7                	jne    ffff800000101666 <_number+0x6b>
        }
    }

    ptr--;
ffff8000001016bf:	48 83 6d f0 01       	sub    QWORD PTR [rbp-0x10],0x1
    for (int64 i = 0 ; i < siz ; i++)
ffff8000001016c4:	48 c7 45 e8 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0
ffff8000001016cb:	00 
ffff8000001016cc:	eb 21                	jmp    ffff8000001016ef <_number+0xf4>
        buffer[i] = *ptr--;
ffff8000001016ce:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff8000001016d2:	48 8d 50 ff          	lea    rdx,[rax-0x1]
ffff8000001016d6:	48 89 55 f0          	mov    QWORD PTR [rbp-0x10],rdx
ffff8000001016da:	48 8b 4d e8          	mov    rcx,QWORD PTR [rbp-0x18]

->ffff8000001016de:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]             # buffer

ffff8000001016e2:	48 01 ca             	add    rdx,rcx
ffff8000001016e5:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff8000001016e8:	88 02                	mov    BYTE PTR [rdx],al                    # wrong buffer's address!
    for (int64 i = 0 ; i < siz ; i++)
ffff8000001016ea:	48 83 45 e8 01       	add    QWORD PTR [rbp-0x18],0x1
ffff8000001016ef:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001016f3:	48 3b 45 f8          	cmp    rax,QWORD PTR [rbp-0x8]
ffff8000001016f7:	7c d5                	jl     ffff8000001016ce <_number+0xd3>
    buffer[siz] = '\0';
ffff8000001016f9:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
ffff8000001016fd:	48 8b 45 88          	mov    rax,QWORD PTR [rbp-0x78]
ffff800000101701:	48 01 d0             	add    rax,rdx
ffff800000101704:	c6 00 00             	mov    BYTE PTR [rax],0x0

    return siz;
ffff800000101707:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
}
ffff80000010170b:	c9                   	leave
ffff80000010170c:	c3                   	ret

ffff80000010170d <vsprintf>:

int64 vsprintf (char *buffer, const char *format, va_list args)
{
ffff80000010170d:	55                   	push   rbp
ffff80000010170e:	48 89 e5             	mov    rbp,rsp
ffff800000101711:	48 81 ec d0 00 00 00 	sub    rsp,0xd0
ffff800000101718:	48 89 bd 48 ff ff ff 	mov    QWORD PTR [rbp-0xb8],rdi
ffff80000010171f:	48 89 b5 40 ff ff ff 	mov    QWORD PTR [rbp-0xc0],rsi
ffff800000101726:	48 89 95 38 ff ff ff 	mov    QWORD PTR [rbp-0xc8],rdx
    char *out = buffer;
ffff80000010172d:	48 8b 85 48 ff ff ff 	mov    rax,QWORD PTR [rbp-0xb8]
ffff800000101734:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    char *ptr = (char*)format;
ffff800000101738:	48 8b 85 40 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc0]
ffff80000010173f:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax

    int flgs = 0;
ffff800000101743:	c7 45 ec 00 00 00 00 	mov    DWORD PTR [rbp-0x14],0x0

    while (ptr && *ptr)
ffff80000010174a:	e9 71 07 00 00       	jmp    ffff800000101ec0 <vsprintf+0x7b3>
    {
        if (*ptr != '%')
ffff80000010174f:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101753:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000101756:	3c 25                	cmp    al,0x25
ffff800000101758:	74 22                	je     ffff80000010177c <vsprintf+0x6f>
        {
            *out++ = *ptr++;
ffff80000010175a:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
ffff80000010175e:	48 8d 42 01          	lea    rax,[rdx+0x1]
ffff800000101762:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
ffff800000101766:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010176a:	48 8d 48 01          	lea    rcx,[rax+0x1]
ffff80000010176e:	48 89 4d f8          	mov    QWORD PTR [rbp-0x8],rcx
ffff800000101772:	0f b6 12             	movzx  edx,BYTE PTR [rdx]
ffff800000101775:	88 10                	mov    BYTE PTR [rax],dl
            continue;
ffff800000101777:	e9 44 07 00 00       	jmp    ffff800000101ec0 <vsprintf+0x7b3>
        }

parse_flgs:
ffff80000010177c:	90                   	nop
        ptr++;
ffff80000010177d:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
        switch (*ptr) {
ffff800000101782:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101786:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000101789:	0f be c0             	movsx  eax,al
ffff80000010178c:	83 e8 20             	sub    eax,0x20
ffff80000010178f:	83 f8 10             	cmp    eax,0x10
ffff800000101792:	77 4a                	ja     ffff8000001017de <vsprintf+0xd1>
ffff800000101794:	89 c0                	mov    eax,eax
ffff800000101796:	48 8d 14 85 00 00 00 	lea    rdx,[rax*4+0x0]
ffff80000010179d:	00 
ffff80000010179e:	48 8d 05 b3 4a 00 00 	lea    rax,[rip+0x4ab3]        # ffff800000106258 <lwstr+0x18>
ffff8000001017a5:	8b 04 02             	mov    eax,DWORD PTR [rdx+rax*1]
ffff8000001017a8:	48 98                	cdqe
ffff8000001017aa:	48 8d 15 a7 4a 00 00 	lea    rdx,[rip+0x4aa7]        # ffff800000106258 <lwstr+0x18>
ffff8000001017b1:	48 01 d0             	add    rax,rdx
ffff8000001017b4:	ff e0                	jmp    rax
            case '#': // 与 o,x或X 一起使用时,非零值前面会分别显示 0,0x或0X
                flgs |= SPECIAL;
ffff8000001017b6:	83 4d ec 08          	or     DWORD PTR [rbp-0x14],0x8
                goto parse_flgs;
ffff8000001017ba:	eb c1                	jmp    ffff80000010177d <vsprintf+0x70>
            case '0': // 在指定填充的数字左边放置0,而不是空格
                if (flgs & ZERO) {
ffff8000001017bc:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
ffff8000001017bf:	83 e0 04             	and    eax,0x4
ffff8000001017c2:	85 c0                	test   eax,eax
ffff8000001017c4:	75 1b                	jne    ffff8000001017e1 <vsprintf+0xd4>
                    break; // 再有就是宽度
                }
                flgs |= ZERO;
ffff8000001017c6:	83 4d ec 04          	or     DWORD PTR [rbp-0x14],0x4
                goto parse_flgs;
ffff8000001017ca:	eb b1                	jmp    ffff80000010177d <vsprintf+0x70>
            case '-': // 在给定的字段宽度内左对齐,默认是右对齐
                flgs |= LEFT;
ffff8000001017cc:	83 4d ec 01          	or     DWORD PTR [rbp-0x14],0x1
                goto parse_flgs;
ffff8000001017d0:	eb ab                	jmp    ffff80000010177d <vsprintf+0x70>
            case ' ': // 如果没有写入任何符号,则在该值前面填空格
                flgs |= SPACE;
ffff8000001017d2:	83 4d ec 10          	or     DWORD PTR [rbp-0x14],0x10
                goto parse_flgs;
ffff8000001017d6:	eb a5                	jmp    ffff80000010177d <vsprintf+0x70>
            case '+': // 如果是正数,则在最前面加一个正号
                flgs |= SIGN;
ffff8000001017d8:	83 4d ec 02          	or     DWORD PTR [rbp-0x14],0x2
                goto parse_flgs;
ffff8000001017dc:	eb 9f                	jmp    ffff80000010177d <vsprintf+0x70>
            default:
                break;
ffff8000001017de:	90                   	nop
ffff8000001017df:	eb 01                	jmp    ffff8000001017e2 <vsprintf+0xd5>
                    break; // 再有就是宽度
ffff8000001017e1:	90                   	nop
        }
        ptr--;
ffff8000001017e2:	48 83 6d f0 01       	sub    QWORD PTR [rbp-0x10],0x1

        int offset = 0;
ffff8000001017e7:	c7 45 a4 00 00 00 00 	mov    DWORD PTR [rbp-0x5c],0x0
        int radix = 10;
ffff8000001017ee:	c7 45 e8 0a 00 00 00 	mov    DWORD PTR [rbp-0x18],0xa
        int len = 0;
ffff8000001017f5:	c7 45 e4 00 00 00 00 	mov    DWORD PTR [rbp-0x1c],0x0
        int width = 0;
ffff8000001017fc:	c7 45 9c 00 00 00 00 	mov    DWORD PTR [rbp-0x64],0x0
        bool sign = false,
ffff800000101803:	c6 45 e3 00          	mov    BYTE PTR [rbp-0x1d],0x0
             upper = false;
ffff800000101807:	c6 45 e2 00          	mov    BYTE PTR [rbp-0x1e],0x0
parse_args:
        ptr++;
ffff80000010180b:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
        switch (*ptr)
ffff800000101810:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101814:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000101817:	0f be c0             	movsx  eax,al
ffff80000010181a:	83 e8 25             	sub    eax,0x25
ffff80000010181d:	83 f8 53             	cmp    eax,0x53
ffff800000101820:	0f 87 d2 02 00 00    	ja     ffff800000101af8 <vsprintf+0x3eb>
ffff800000101826:	89 c0                	mov    eax,eax
ffff800000101828:	48 8d 14 85 00 00 00 	lea    rdx,[rax*4+0x0]
ffff80000010182f:	00 
ffff800000101830:	48 8d 05 65 4a 00 00 	lea    rax,[rip+0x4a65]        # ffff80000010629c <lwstr+0x5c>
ffff800000101837:	8b 04 02             	mov    eax,DWORD PTR [rdx+rax*1]
ffff80000010183a:	48 98                	cdqe
ffff80000010183c:	48 8d 15 59 4a 00 00 	lea    rdx,[rip+0x4a59]        # ffff80000010629c <lwstr+0x5c>
ffff800000101843:	48 01 d0             	add    rax,rdx
ffff800000101846:	ff e0                	jmp    rax
        {
            case '%':
                *out++ = '%';
ffff800000101848:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010184c:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff800000101850:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
ffff800000101854:	c6 00 25             	mov    BYTE PTR [rax],0x25
                break;
ffff800000101857:	e9 9c 02 00 00       	jmp    ffff800000101af8 <vsprintf+0x3eb>
            case 'l':
            case 'L':
                len = 1;
ffff80000010185c:	c7 45 e4 01 00 00 00 	mov    DWORD PTR [rbp-0x1c],0x1
                if (*(ptr+1) == 'l' || *(ptr+1) == 'L') {
ffff800000101863:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101867:	48 83 c0 01          	add    rax,0x1
ffff80000010186b:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff80000010186e:	3c 6c                	cmp    al,0x6c
ffff800000101870:	74 0f                	je     ffff800000101881 <vsprintf+0x174>
ffff800000101872:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101876:	48 83 c0 01          	add    rax,0x1
ffff80000010187a:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff80000010187d:	3c 4c                	cmp    al,0x4c
ffff80000010187f:	75 8a                	jne    ffff80000010180b <vsprintf+0xfe>
                    ptr++;
ffff800000101881:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
                    len = 2;
ffff800000101886:	c7 45 e4 02 00 00 00 	mov    DWORD PTR [rbp-0x1c],0x2
                }
                goto parse_args;
ffff80000010188d:	e9 79 ff ff ff       	jmp    ffff80000010180b <vsprintf+0xfe>

            case 'X':
                upper = true;
ffff800000101892:	c6 45 e2 01          	mov    BYTE PTR [rbp-0x1e],0x1
            case 'x':
                radix = 16;
ffff800000101896:	c7 45 e8 10 00 00 00 	mov    DWORD PTR [rbp-0x18],0x10
                break;
ffff80000010189d:	e9 56 02 00 00       	jmp    ffff800000101af8 <vsprintf+0x3eb>
            case 'o':
                radix = 8;
ffff8000001018a2:	c7 45 e8 08 00 00 00 	mov    DWORD PTR [rbp-0x18],0x8
                break;
ffff8000001018a9:	e9 4a 02 00 00       	jmp    ffff800000101af8 <vsprintf+0x3eb>
            case 'd':
            case 'i':
                sign = true;
ffff8000001018ae:	c6 45 e3 01          	mov    BYTE PTR [rbp-0x1d],0x1
            case 'u':
                radix = 10;
ffff8000001018b2:	c7 45 e8 0a 00 00 00 	mov    DWORD PTR [rbp-0x18],0xa
                break;
ffff8000001018b9:	e9 3a 02 00 00       	jmp    ffff800000101af8 <vsprintf+0x3eb>
            case 'c':
                /* Includes the char */
                if (width > 1)
ffff8000001018be:	8b 45 9c             	mov    eax,DWORD PTR [rbp-0x64]
ffff8000001018c1:	83 f8 01             	cmp    eax,0x1
ffff8000001018c4:	7e 21                	jle    ffff8000001018e7 <vsprintf+0x1da>
                    while (--width)
ffff8000001018c6:	eb 0f                	jmp    ffff8000001018d7 <vsprintf+0x1ca>
                        *out++ = ' ';
ffff8000001018c8:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001018cc:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff8000001018d0:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
ffff8000001018d4:	c6 00 20             	mov    BYTE PTR [rax],0x20
                    while (--width)
ffff8000001018d7:	8b 45 9c             	mov    eax,DWORD PTR [rbp-0x64]
ffff8000001018da:	83 e8 01             	sub    eax,0x1
ffff8000001018dd:	89 45 9c             	mov    DWORD PTR [rbp-0x64],eax
ffff8000001018e0:	8b 45 9c             	mov    eax,DWORD PTR [rbp-0x64]
ffff8000001018e3:	85 c0                	test   eax,eax
ffff8000001018e5:	75 e1                	jne    ffff8000001018c8 <vsprintf+0x1bb>
                *out++ = (char)va_arg (args, int);
ffff8000001018e7:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff8000001018ee:	8b 00                	mov    eax,DWORD PTR [rax]
ffff8000001018f0:	83 f8 2f             	cmp    eax,0x2f
ffff8000001018f3:	77 30                	ja     ffff800000101925 <vsprintf+0x218>
ffff8000001018f5:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff8000001018fc:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
ffff800000101900:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101907:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000101909:	89 c0                	mov    eax,eax
ffff80000010190b:	48 01 d0             	add    rax,rdx
ffff80000010190e:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101915:	8b 12                	mov    edx,DWORD PTR [rdx]
ffff800000101917:	8d 4a 08             	lea    ecx,[rdx+0x8]
ffff80000010191a:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101921:	89 0a                	mov    DWORD PTR [rdx],ecx
ffff800000101923:	eb 1a                	jmp    ffff80000010193f <vsprintf+0x232>
ffff800000101925:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff80000010192c:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff800000101930:	48 8d 48 08          	lea    rcx,[rax+0x8]
ffff800000101934:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff80000010193b:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
ffff80000010193f:	8b 08                	mov    ecx,DWORD PTR [rax]
ffff800000101941:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101945:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff800000101949:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
ffff80000010194d:	89 ca                	mov    edx,ecx
ffff80000010194f:	88 10                	mov    BYTE PTR [rax],dl

                ptr++;
ffff800000101951:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
                continue;
ffff800000101956:	e9 65 05 00 00       	jmp    ffff800000101ec0 <vsprintf+0x7b3>
            case 's':
                {
                    char *src = (char *)va_arg (args, char *);
ffff80000010195b:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101962:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000101964:	83 f8 2f             	cmp    eax,0x2f
ffff800000101967:	77 30                	ja     ffff800000101999 <vsprintf+0x28c>
ffff800000101969:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101970:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
ffff800000101974:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff80000010197b:	8b 00                	mov    eax,DWORD PTR [rax]
ffff80000010197d:	89 c0                	mov    eax,eax
ffff80000010197f:	48 01 d0             	add    rax,rdx
ffff800000101982:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101989:	8b 12                	mov    edx,DWORD PTR [rdx]
ffff80000010198b:	8d 4a 08             	lea    ecx,[rdx+0x8]
ffff80000010198e:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101995:	89 0a                	mov    DWORD PTR [rdx],ecx
ffff800000101997:	eb 1a                	jmp    ffff8000001019b3 <vsprintf+0x2a6>
ffff800000101999:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff8000001019a0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff8000001019a4:	48 8d 48 08          	lea    rcx,[rax+0x8]
ffff8000001019a8:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff8000001019af:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
ffff8000001019b3:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff8000001019b6:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
                    if (src == NULL)
ffff8000001019ba:	48 83 7d d8 00       	cmp    QWORD PTR [rbp-0x28],0x0
ffff8000001019bf:	75 0b                	jne    ffff8000001019cc <vsprintf+0x2bf>
                        src = "(null)"; // 如果是 NULL 就填 "(null), 总不可能去访问 0x00 吧 QaQ"
ffff8000001019c1:	48 8d 05 89 48 00 00 	lea    rax,[rip+0x4889]        # ffff800000106251 <lwstr+0x11>
ffff8000001019c8:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
                    for (char *p = src;p && *p;p++)
ffff8000001019cc:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001019d0:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
ffff8000001019d4:	eb 0e                	jmp    ffff8000001019e4 <vsprintf+0x2d7>
                        width--;
ffff8000001019d6:	8b 45 9c             	mov    eax,DWORD PTR [rbp-0x64]
ffff8000001019d9:	83 e8 01             	sub    eax,0x1
ffff8000001019dc:	89 45 9c             	mov    DWORD PTR [rbp-0x64],eax
                    for (char *p = src;p && *p;p++)
ffff8000001019df:	48 83 45 d0 01       	add    QWORD PTR [rbp-0x30],0x1
ffff8000001019e4:	48 83 7d d0 00       	cmp    QWORD PTR [rbp-0x30],0x0
ffff8000001019e9:	74 1c                	je     ffff800000101a07 <vsprintf+0x2fa>
ffff8000001019eb:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff8000001019ef:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff8000001019f2:	84 c0                	test   al,al
ffff8000001019f4:	75 e0                	jne    ffff8000001019d6 <vsprintf+0x2c9>
                    while (width-- > 0)
ffff8000001019f6:	eb 0f                	jmp    ffff800000101a07 <vsprintf+0x2fa>
                        *out++ = ' ';
ffff8000001019f8:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001019fc:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff800000101a00:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
ffff800000101a04:	c6 00 20             	mov    BYTE PTR [rax],0x20
                    while (width-- > 0)
ffff800000101a07:	8b 45 9c             	mov    eax,DWORD PTR [rbp-0x64]
ffff800000101a0a:	8d 50 ff             	lea    edx,[rax-0x1]
ffff800000101a0d:	89 55 9c             	mov    DWORD PTR [rbp-0x64],edx
ffff800000101a10:	85 c0                	test   eax,eax
ffff800000101a12:	7f e4                	jg     ffff8000001019f8 <vsprintf+0x2eb>
                    while (*src)
ffff800000101a14:	eb 1d                	jmp    ffff800000101a33 <vsprintf+0x326>
                        *out++ = *src++;
ffff800000101a16:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
ffff800000101a1a:	48 8d 42 01          	lea    rax,[rdx+0x1]
ffff800000101a1e:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
ffff800000101a22:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101a26:	48 8d 48 01          	lea    rcx,[rax+0x1]
ffff800000101a2a:	48 89 4d f8          	mov    QWORD PTR [rbp-0x8],rcx
ffff800000101a2e:	0f b6 12             	movzx  edx,BYTE PTR [rdx]
ffff800000101a31:	88 10                	mov    BYTE PTR [rax],dl
                    while (*src)
ffff800000101a33:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000101a37:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000101a3a:	84 c0                	test   al,al
ffff800000101a3c:	75 d8                	jne    ffff800000101a16 <vsprintf+0x309>

                    ptr++;
ffff800000101a3e:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
                    continue;
ffff800000101a43:	e9 78 04 00 00       	jmp    ffff800000101ec0 <vsprintf+0x7b3>
                }
            case 'p':
                radix = 16;
ffff800000101a48:	c7 45 e8 10 00 00 00 	mov    DWORD PTR [rbp-0x18],0x10
                len = 2;
ffff800000101a4f:	c7 45 e4 02 00 00 00 	mov    DWORD PTR [rbp-0x1c],0x2
                flgs |= SPECIAL;
ffff800000101a56:	83 4d ec 08          	or     DWORD PTR [rbp-0x14],0x8
                break;
ffff800000101a5a:	e9 99 00 00 00       	jmp    ffff800000101af8 <vsprintf+0x3eb>
            case '6':
            case '7':
            case '8':
            case '9':
            case '0':
                offset = _int (ptr, &width);
ffff800000101a5f:	48 8d 55 9c          	lea    rdx,[rbp-0x64]
ffff800000101a63:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101a67:	48 89 d6             	mov    rsi,rdx
ffff800000101a6a:	48 89 c7             	mov    rdi,rax
ffff800000101a6d:	e8 1d fb ff ff       	call   ffff80000010158f <_int>
ffff800000101a72:	89 45 a4             	mov    DWORD PTR [rbp-0x5c],eax
                ptr += offset - 1;
ffff800000101a75:	8b 45 a4             	mov    eax,DWORD PTR [rbp-0x5c]
ffff800000101a78:	48 98                	cdqe
ffff800000101a7a:	48 83 e8 01          	sub    rax,0x1
ffff800000101a7e:	48 01 45 f0          	add    QWORD PTR [rbp-0x10],rax
                goto parse_args;
ffff800000101a82:	e9 84 fd ff ff       	jmp    ffff80000010180b <vsprintf+0xfe>
            case '*':
                width = va_arg (args ,int);
ffff800000101a87:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101a8e:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000101a90:	83 f8 2f             	cmp    eax,0x2f
ffff800000101a93:	77 30                	ja     ffff800000101ac5 <vsprintf+0x3b8>
ffff800000101a95:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101a9c:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
ffff800000101aa0:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101aa7:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000101aa9:	89 c0                	mov    eax,eax
ffff800000101aab:	48 01 d0             	add    rax,rdx
ffff800000101aae:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101ab5:	8b 12                	mov    edx,DWORD PTR [rdx]
ffff800000101ab7:	8d 4a 08             	lea    ecx,[rdx+0x8]
ffff800000101aba:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101ac1:	89 0a                	mov    DWORD PTR [rdx],ecx
ffff800000101ac3:	eb 1a                	jmp    ffff800000101adf <vsprintf+0x3d2>
ffff800000101ac5:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101acc:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff800000101ad0:	48 8d 48 08          	lea    rcx,[rax+0x8]
ffff800000101ad4:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101adb:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
ffff800000101adf:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000101ae1:	89 45 9c             	mov    DWORD PTR [rbp-0x64],eax
                if (width < 0)
ffff800000101ae4:	8b 45 9c             	mov    eax,DWORD PTR [rbp-0x64]
ffff800000101ae7:	85 c0                	test   eax,eax
ffff800000101ae9:	0f 89 1c fd ff ff    	jns    ffff80000010180b <vsprintf+0xfe>
                    flgs |= LEFT; // 左对齐
ffff800000101aef:	83 4d ec 01          	or     DWORD PTR [rbp-0x14],0x1
                goto parse_args;
ffff800000101af3:	e9 13 fd ff ff       	jmp    ffff80000010180b <vsprintf+0xfe>
        }

        u64 val;
        bool minus = false;
ffff800000101af8:	c6 45 c7 00          	mov    BYTE PTR [rbp-0x39],0x0

        if (len == 0)
ffff800000101afc:	83 7d e4 00          	cmp    DWORD PTR [rbp-0x1c],0x0
ffff800000101b00:	0f 85 8b 00 00 00    	jne    ffff800000101b91 <vsprintf+0x484>
        {
            val = va_arg (args, unsigned int);
ffff800000101b06:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101b0d:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000101b0f:	83 f8 2f             	cmp    eax,0x2f
ffff800000101b12:	77 30                	ja     ffff800000101b44 <vsprintf+0x437>
ffff800000101b14:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101b1b:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
ffff800000101b1f:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101b26:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000101b28:	89 c0                	mov    eax,eax
ffff800000101b2a:	48 01 d0             	add    rax,rdx
ffff800000101b2d:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101b34:	8b 12                	mov    edx,DWORD PTR [rdx]
ffff800000101b36:	8d 4a 08             	lea    ecx,[rdx+0x8]
ffff800000101b39:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101b40:	89 0a                	mov    DWORD PTR [rdx],ecx
ffff800000101b42:	eb 1a                	jmp    ffff800000101b5e <vsprintf+0x451>
ffff800000101b44:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101b4b:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff800000101b4f:	48 8d 48 08          	lea    rcx,[rax+0x8]
ffff800000101b53:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101b5a:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
ffff800000101b5e:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000101b60:	89 c0                	mov    eax,eax
ffff800000101b62:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
            if (sign && (int)val < 0) {
ffff800000101b66:	80 7d e3 00          	cmp    BYTE PTR [rbp-0x1d],0x0
ffff800000101b6a:	0f 84 38 01 00 00    	je     ffff800000101ca8 <vsprintf+0x59b>
ffff800000101b70:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff800000101b74:	85 c0                	test   eax,eax
ffff800000101b76:	0f 89 2c 01 00 00    	jns    ffff800000101ca8 <vsprintf+0x59b>
                minus = true;
ffff800000101b7c:	c6 45 c7 01          	mov    BYTE PTR [rbp-0x39],0x1
                val = -(int)val; // 符号位将在最后于字符串上添上.
ffff800000101b80:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff800000101b84:	f7 d8                	neg    eax
ffff800000101b86:	48 98                	cdqe
ffff800000101b88:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
ffff800000101b8c:	e9 17 01 00 00       	jmp    ffff800000101ca8 <vsprintf+0x59b>
            }
        }
        else if (len == 1)
ffff800000101b91:	83 7d e4 01          	cmp    DWORD PTR [rbp-0x1c],0x1
ffff800000101b95:	0f 85 8a 00 00 00    	jne    ffff800000101c25 <vsprintf+0x518>
        {
            val = va_arg (args, unsigned long);
ffff800000101b9b:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101ba2:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000101ba4:	83 f8 2f             	cmp    eax,0x2f
ffff800000101ba7:	77 30                	ja     ffff800000101bd9 <vsprintf+0x4cc>
ffff800000101ba9:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101bb0:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
ffff800000101bb4:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101bbb:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000101bbd:	89 c0                	mov    eax,eax
ffff800000101bbf:	48 01 d0             	add    rax,rdx
ffff800000101bc2:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101bc9:	8b 12                	mov    edx,DWORD PTR [rdx]
ffff800000101bcb:	8d 4a 08             	lea    ecx,[rdx+0x8]
ffff800000101bce:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101bd5:	89 0a                	mov    DWORD PTR [rdx],ecx
ffff800000101bd7:	eb 1a                	jmp    ffff800000101bf3 <vsprintf+0x4e6>
ffff800000101bd9:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101be0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff800000101be4:	48 8d 48 08          	lea    rcx,[rax+0x8]
ffff800000101be8:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101bef:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
ffff800000101bf3:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff800000101bf6:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
            if (sign && (long)val < 0) {
ffff800000101bfa:	80 7d e3 00          	cmp    BYTE PTR [rbp-0x1d],0x0
ffff800000101bfe:	0f 84 a4 00 00 00    	je     ffff800000101ca8 <vsprintf+0x59b>
ffff800000101c04:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff800000101c08:	48 85 c0             	test   rax,rax
ffff800000101c0b:	0f 89 97 00 00 00    	jns    ffff800000101ca8 <vsprintf+0x59b>
                minus = true;
ffff800000101c11:	c6 45 c7 01          	mov    BYTE PTR [rbp-0x39],0x1
                val = -(long)val;
ffff800000101c15:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff800000101c19:	48 f7 d8             	neg    rax
ffff800000101c1c:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
ffff800000101c20:	e9 83 00 00 00       	jmp    ffff800000101ca8 <vsprintf+0x59b>
            }
        }
        else if (len == 2)
ffff800000101c25:	83 7d e4 02          	cmp    DWORD PTR [rbp-0x1c],0x2
ffff800000101c29:	75 7d                	jne    ffff800000101ca8 <vsprintf+0x59b>
        {
            val = va_arg (args, unsigned long long);
ffff800000101c2b:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101c32:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000101c34:	83 f8 2f             	cmp    eax,0x2f
ffff800000101c37:	77 30                	ja     ffff800000101c69 <vsprintf+0x55c>
ffff800000101c39:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101c40:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
ffff800000101c44:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101c4b:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000101c4d:	89 c0                	mov    eax,eax
ffff800000101c4f:	48 01 d0             	add    rax,rdx
ffff800000101c52:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101c59:	8b 12                	mov    edx,DWORD PTR [rdx]
ffff800000101c5b:	8d 4a 08             	lea    ecx,[rdx+0x8]
ffff800000101c5e:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101c65:	89 0a                	mov    DWORD PTR [rdx],ecx
ffff800000101c67:	eb 1a                	jmp    ffff800000101c83 <vsprintf+0x576>
ffff800000101c69:	48 8b 85 38 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc8]
ffff800000101c70:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff800000101c74:	48 8d 48 08          	lea    rcx,[rax+0x8]
ffff800000101c78:	48 8b 95 38 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xc8]
ffff800000101c7f:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
ffff800000101c83:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff800000101c86:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
            if (sign && (long long)val < 0) {
ffff800000101c8a:	80 7d e3 00          	cmp    BYTE PTR [rbp-0x1d],0x0
ffff800000101c8e:	74 18                	je     ffff800000101ca8 <vsprintf+0x59b>
ffff800000101c90:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff800000101c94:	48 85 c0             	test   rax,rax
ffff800000101c97:	79 0f                	jns    ffff800000101ca8 <vsprintf+0x59b>
                minus = true;
ffff800000101c99:	c6 45 c7 01          	mov    BYTE PTR [rbp-0x39],0x1
                val = -(long long)val;
ffff800000101c9d:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff800000101ca1:	48 f7 d8             	neg    rax
ffff800000101ca4:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
            }
        }

        /* 每一次添加字符('+','-',' '...)都会导致 Siz 减小,
           这么做在于最后可以直接使用 Siz 来进行填充操作. */
        int64 siz = width;
ffff800000101ca8:	8b 45 9c             	mov    eax,DWORD PTR [rbp-0x64]
ffff800000101cab:	48 98                	cdqe
ffff800000101cad:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
        char tmp[TMP_BUFFER_SIZE];
        siz -= _number (tmp, val, radix, upper);
ffff800000101cb1:	0f b6 4d e2          	movzx  ecx,BYTE PTR [rbp-0x1e]
ffff800000101cb5:	8b 55 e8             	mov    edx,DWORD PTR [rbp-0x18]
ffff800000101cb8:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
ffff800000101cbc:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
ffff800000101cc3:	48 89 c7             	mov    rdi,rax
ffff800000101cc6:	e8 30 f9 ff ff       	call   ffff8000001015fb <_number>
ffff800000101ccb:	48 29 45 b8          	sub    QWORD PTR [rbp-0x48],rax

        char prefix = 0;
ffff800000101ccf:	c6 45 b7 00          	mov    BYTE PTR [rbp-0x49],0x0
        if (radix == 10)
ffff800000101cd3:	83 7d e8 0a          	cmp    DWORD PTR [rbp-0x18],0xa
ffff800000101cd7:	75 63                	jne    ffff800000101d3c <vsprintf+0x62f>
        {
            if (minus && siz--)
ffff800000101cd9:	80 7d c7 00          	cmp    BYTE PTR [rbp-0x39],0x0
ffff800000101cdd:	74 17                	je     ffff800000101cf6 <vsprintf+0x5e9>
ffff800000101cdf:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
ffff800000101ce3:	48 8d 50 ff          	lea    rdx,[rax-0x1]
ffff800000101ce7:	48 89 55 b8          	mov    QWORD PTR [rbp-0x48],rdx
ffff800000101ceb:	48 85 c0             	test   rax,rax
ffff800000101cee:	74 06                	je     ffff800000101cf6 <vsprintf+0x5e9>
                prefix = '-';
ffff800000101cf0:	c6 45 b7 2d          	mov    BYTE PTR [rbp-0x49],0x2d
ffff800000101cf4:	eb 46                	jmp    ffff800000101d3c <vsprintf+0x62f>
            /* 以下是正数的情况 */
            else if (sign && flgs & SIGN && siz--)
ffff800000101cf6:	80 7d e3 00          	cmp    BYTE PTR [rbp-0x1d],0x0
ffff800000101cfa:	74 21                	je     ffff800000101d1d <vsprintf+0x610>
ffff800000101cfc:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
ffff800000101cff:	83 e0 02             	and    eax,0x2
ffff800000101d02:	85 c0                	test   eax,eax
ffff800000101d04:	74 17                	je     ffff800000101d1d <vsprintf+0x610>
ffff800000101d06:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
ffff800000101d0a:	48 8d 50 ff          	lea    rdx,[rax-0x1]
ffff800000101d0e:	48 89 55 b8          	mov    QWORD PTR [rbp-0x48],rdx
ffff800000101d12:	48 85 c0             	test   rax,rax
ffff800000101d15:	74 06                	je     ffff800000101d1d <vsprintf+0x610>
                prefix = '+';
ffff800000101d17:	c6 45 b7 2b          	mov    BYTE PTR [rbp-0x49],0x2b
ffff800000101d1b:	eb 1f                	jmp    ffff800000101d3c <vsprintf+0x62f>
            else if (flgs & SPACE && siz--)
ffff800000101d1d:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
ffff800000101d20:	83 e0 10             	and    eax,0x10
ffff800000101d23:	85 c0                	test   eax,eax
ffff800000101d25:	74 15                	je     ffff800000101d3c <vsprintf+0x62f>
ffff800000101d27:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
ffff800000101d2b:	48 8d 50 ff          	lea    rdx,[rax-0x1]
ffff800000101d2f:	48 89 55 b8          	mov    QWORD PTR [rbp-0x48],rdx
ffff800000101d33:	48 85 c0             	test   rax,rax
ffff800000101d36:	74 04                	je     ffff800000101d3c <vsprintf+0x62f>
                prefix = ' ';
ffff800000101d38:	c6 45 b7 20          	mov    BYTE PTR [rbp-0x49],0x20
        }

        if (flgs & SPECIAL) {
ffff800000101d3c:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
ffff800000101d3f:	83 e0 08             	and    eax,0x8
ffff800000101d42:	85 c0                	test   eax,eax
ffff800000101d44:	74 23                	je     ffff800000101d69 <vsprintf+0x65c>
            siz -= (radix == 16) ? 2 :
ffff800000101d46:	83 7d e8 10          	cmp    DWORD PTR [rbp-0x18],0x10
ffff800000101d4a:	74 14                	je     ffff800000101d60 <vsprintf+0x653>
ffff800000101d4c:	83 7d e8 08          	cmp    DWORD PTR [rbp-0x18],0x8
ffff800000101d50:	75 07                	jne    ffff800000101d59 <vsprintf+0x64c>
ffff800000101d52:	b8 01 00 00 00       	mov    eax,0x1
ffff800000101d57:	eb 0c                	jmp    ffff800000101d65 <vsprintf+0x658>
ffff800000101d59:	b8 00 00 00 00       	mov    eax,0x0
ffff800000101d5e:	eb 05                	jmp    ffff800000101d65 <vsprintf+0x658>
ffff800000101d60:	b8 02 00 00 00       	mov    eax,0x2
ffff800000101d65:	48 29 45 b8          	sub    QWORD PTR [rbp-0x48],rax
                   (radix == 8 ) ? 1 : 0;
        }

        if (flgs & ZERO)
ffff800000101d69:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
ffff800000101d6c:	83 e0 04             	and    eax,0x4
ffff800000101d6f:	85 c0                	test   eax,eax
ffff800000101d71:	74 5d                	je     ffff800000101dd0 <vsprintf+0x6c3>
        {
            if (prefix) *out++ = prefix;
ffff800000101d73:	80 7d b7 00          	cmp    BYTE PTR [rbp-0x49],0x0
ffff800000101d77:	74 12                	je     ffff800000101d8b <vsprintf+0x67e>
ffff800000101d79:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101d7d:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff800000101d81:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
ffff800000101d85:	0f b6 55 b7          	movzx  edx,BYTE PTR [rbp-0x49]
ffff800000101d89:	88 10                	mov    BYTE PTR [rax],dl
            /* "0x" "0X" "0" for SPECIAL */
            if (flgs & SPECIAL && radix != 10)
ffff800000101d8b:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
ffff800000101d8e:	83 e0 08             	and    eax,0x8
ffff800000101d91:	85 c0                	test   eax,eax
ffff800000101d93:	74 3b                	je     ffff800000101dd0 <vsprintf+0x6c3>
ffff800000101d95:	83 7d e8 0a          	cmp    DWORD PTR [rbp-0x18],0xa
ffff800000101d99:	74 35                	je     ffff800000101dd0 <vsprintf+0x6c3>
            {
                *out++ = '0';
ffff800000101d9b:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101d9f:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff800000101da3:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
ffff800000101da7:	c6 00 30             	mov    BYTE PTR [rax],0x30
                if (radix == 16) {
ffff800000101daa:	83 7d e8 10          	cmp    DWORD PTR [rbp-0x18],0x10
ffff800000101dae:	75 20                	jne    ffff800000101dd0 <vsprintf+0x6c3>
                    *out++ = upper ? 'X' : 'x';
ffff800000101db0:	80 7d e2 00          	cmp    BYTE PTR [rbp-0x1e],0x0
ffff800000101db4:	74 07                	je     ffff800000101dbd <vsprintf+0x6b0>
ffff800000101db6:	b9 58 00 00 00       	mov    ecx,0x58
ffff800000101dbb:	eb 05                	jmp    ffff800000101dc2 <vsprintf+0x6b5>
ffff800000101dbd:	b9 78 00 00 00       	mov    ecx,0x78
ffff800000101dc2:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101dc6:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff800000101dca:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
ffff800000101dce:	88 08                	mov    BYTE PTR [rax],cl
                }
            }
        }

        /* Padding */
        if (!(flgs & LEFT) && siz > 0)
ffff800000101dd0:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
ffff800000101dd3:	83 e0 01             	and    eax,0x1
ffff800000101dd6:	85 c0                	test   eax,eax
ffff800000101dd8:	75 45                	jne    ffff800000101e1f <vsprintf+0x712>
ffff800000101dda:	48 83 7d b8 00       	cmp    QWORD PTR [rbp-0x48],0x0
ffff800000101ddf:	7e 3e                	jle    ffff800000101e1f <vsprintf+0x712>
        {
            char pad = flgs & ZERO ? '0' : ' ';
ffff800000101de1:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
ffff800000101de4:	83 e0 04             	and    eax,0x4
ffff800000101de7:	85 c0                	test   eax,eax
ffff800000101de9:	74 07                	je     ffff800000101df2 <vsprintf+0x6e5>
ffff800000101deb:	b8 30 00 00 00       	mov    eax,0x30
ffff800000101df0:	eb 05                	jmp    ffff800000101df7 <vsprintf+0x6ea>
ffff800000101df2:	b8 20 00 00 00       	mov    eax,0x20
ffff800000101df7:	88 45 a3             	mov    BYTE PTR [rbp-0x5d],al

            while (siz--) {
ffff800000101dfa:	eb 12                	jmp    ffff800000101e0e <vsprintf+0x701>
                *out++ = pad;
ffff800000101dfc:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101e00:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff800000101e04:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
ffff800000101e08:	0f b6 55 a3          	movzx  edx,BYTE PTR [rbp-0x5d]
ffff800000101e0c:	88 10                	mov    BYTE PTR [rax],dl
            while (siz--) {
ffff800000101e0e:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
ffff800000101e12:	48 8d 50 ff          	lea    rdx,[rax-0x1]
ffff800000101e16:	48 89 55 b8          	mov    QWORD PTR [rbp-0x48],rdx
ffff800000101e1a:	48 85 c0             	test   rax,rax
ffff800000101e1d:	75 dd                	jne    ffff800000101dfc <vsprintf+0x6ef>
            }
        }

        /* Symbol and others after padding if that is not filled with '0' -> "    0x91d" */
        if (!(flgs & ZERO))
ffff800000101e1f:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
ffff800000101e22:	83 e0 04             	and    eax,0x4
ffff800000101e25:	85 c0                	test   eax,eax
ffff800000101e27:	75 5d                	jne    ffff800000101e86 <vsprintf+0x779>
        {
            if (prefix) *out++ = prefix;
ffff800000101e29:	80 7d b7 00          	cmp    BYTE PTR [rbp-0x49],0x0
ffff800000101e2d:	74 12                	je     ffff800000101e41 <vsprintf+0x734>
ffff800000101e2f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101e33:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff800000101e37:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
ffff800000101e3b:	0f b6 55 b7          	movzx  edx,BYTE PTR [rbp-0x49]
ffff800000101e3f:	88 10                	mov    BYTE PTR [rax],dl
            /* "0x" "0X" "0" for SPECIAL */
            if (flgs & SPECIAL && radix != 10)
ffff800000101e41:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
ffff800000101e44:	83 e0 08             	and    eax,0x8
ffff800000101e47:	85 c0                	test   eax,eax
ffff800000101e49:	74 3b                	je     ffff800000101e86 <vsprintf+0x779>
ffff800000101e4b:	83 7d e8 0a          	cmp    DWORD PTR [rbp-0x18],0xa
ffff800000101e4f:	74 35                	je     ffff800000101e86 <vsprintf+0x779>
            {
                *out++ = '0';
ffff800000101e51:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101e55:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff800000101e59:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
ffff800000101e5d:	c6 00 30             	mov    BYTE PTR [rax],0x30
                if (radix == 16) {
ffff800000101e60:	83 7d e8 10          	cmp    DWORD PTR [rbp-0x18],0x10
ffff800000101e64:	75 20                	jne    ffff800000101e86 <vsprintf+0x779>
                    *out++ = upper ? 'X' : 'x';
ffff800000101e66:	80 7d e2 00          	cmp    BYTE PTR [rbp-0x1e],0x0
ffff800000101e6a:	74 07                	je     ffff800000101e73 <vsprintf+0x766>
ffff800000101e6c:	b9 58 00 00 00       	mov    ecx,0x58
ffff800000101e71:	eb 05                	jmp    ffff800000101e78 <vsprintf+0x76b>
ffff800000101e73:	b9 78 00 00 00       	mov    ecx,0x78
ffff800000101e78:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101e7c:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff800000101e80:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
ffff800000101e84:	88 08                	mov    BYTE PTR [rax],cl
                }
            }
        }

        for (char *p = tmp;*p;) {
ffff800000101e86:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
ffff800000101e8d:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
ffff800000101e91:	eb 1d                	jmp    ffff800000101eb0 <vsprintf+0x7a3>
            *out++ = *p++;
ffff800000101e93:	48 8b 55 a8          	mov    rdx,QWORD PTR [rbp-0x58]
ffff800000101e97:	48 8d 42 01          	lea    rax,[rdx+0x1]
ffff800000101e9b:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
ffff800000101e9f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101ea3:	48 8d 48 01          	lea    rcx,[rax+0x1]
ffff800000101ea7:	48 89 4d f8          	mov    QWORD PTR [rbp-0x8],rcx
ffff800000101eab:	0f b6 12             	movzx  edx,BYTE PTR [rdx]
ffff800000101eae:	88 10                	mov    BYTE PTR [rax],dl
        for (char *p = tmp;*p;) {
ffff800000101eb0:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
ffff800000101eb4:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000101eb7:	84 c0                	test   al,al
ffff800000101eb9:	75 d8                	jne    ffff800000101e93 <vsprintf+0x786>
        }

        ptr++;
ffff800000101ebb:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
    while (ptr && *ptr)
ffff800000101ec0:	48 83 7d f0 00       	cmp    QWORD PTR [rbp-0x10],0x0
ffff800000101ec5:	74 0f                	je     ffff800000101ed6 <vsprintf+0x7c9>
ffff800000101ec7:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101ecb:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000101ece:	84 c0                	test   al,al
ffff800000101ed0:	0f 85 79 f8 ff ff    	jne    ffff80000010174f <vsprintf+0x42>
    }
    *out = '\0';
ffff800000101ed6:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101eda:	c6 00 00             	mov    BYTE PTR [rax],0x0

    return (int64)(out - buffer);
ffff800000101edd:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101ee1:	48 2b 85 48 ff ff ff 	sub    rax,QWORD PTR [rbp-0xb8]
}
ffff800000101ee8:	c9                   	leave
ffff800000101ee9:	c3                   	ret

ffff800000101eea <mm_init>:
extern void vmap_init ();
extern void vmap_initvm ();
extern void heap_init ();

void mm_init ()
{
ffff800000101eea:	55                   	push   rbp
ffff800000101eeb:	48 89 e5             	mov    rbp,rsp
    pmm_init();
ffff800000101eee:	b8 00 00 00 00       	mov    eax,0x0
ffff800000101ef3:	e8 be 07 00 00       	call   ffff8000001026b6 <pmm_init>
    vmap_init();
ffff800000101ef8:	b8 00 00 00 00       	mov    eax,0x0
ffff800000101efd:	e8 7d 10 00 00       	call   ffff800000102f7f <vmap_init>

    heap_init();
ffff800000101f02:	b8 00 00 00 00       	mov    eax,0x0
ffff800000101f07:	e8 7a 11 00 00       	call   ffff800000103086 <heap_init>

    vmap_initvm();
ffff800000101f0c:	b8 00 00 00 00       	mov    eax,0x0
ffff800000101f11:	e8 bb 10 00 00       	call   ffff800000102fd1 <vmap_initvm>
}
ffff800000101f16:	90                   	nop
ffff800000101f17:	5d                   	pop    rbp
ffff800000101f18:	c3                   	ret

ffff800000101f19 <__mm_pre>:
#include <boot.h>

extern void __pmm_pre (mconfig_t *m);

void __mm_pre (mconfig_t *m)
{
ffff800000101f19:	55                   	push   rbp
ffff800000101f1a:	48 89 e5             	mov    rbp,rsp
ffff800000101f1d:	48 83 ec 10          	sub    rsp,0x10
ffff800000101f21:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
    __pmm_pre (m);
ffff800000101f25:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101f29:	48 89 c7             	mov    rdi,rax
ffff800000101f2c:	e8 73 09 00 00       	call   ffff8000001028a4 <__pmm_pre>
}
ffff800000101f31:	90                   	nop
ffff800000101f32:	c9                   	leave
ffff800000101f33:	c3                   	ret

ffff800000101f34 <alloc_early>:
   alloc  是在原有的基础上进行修改, 如果重映射还没完成, alloc 会将原来在已经分配页上的 节点向后移动一段
   alloc0 在重映射完成后, 是直接 malloc 一个新的节点, 原来的节点应该使用 delete0 来删掉
   二者的行为在重映射完成之前没有任何的差异.
*/

static void *alloc_early (free_t *prev, size_t num) { return OFFSET(prev, num * PAGE_SIZ); }
ffff800000101f34:	55                   	push   rbp
ffff800000101f35:	48 89 e5             	mov    rbp,rsp
ffff800000101f38:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
ffff800000101f3c:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
ffff800000101f40:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101f44:	48 c1 e0 0c          	shl    rax,0xc
ffff800000101f48:	48 89 c2             	mov    rdx,rax
ffff800000101f4b:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101f4f:	48 01 d0             	add    rax,rdx
ffff800000101f52:	5d                   	pop    rbp
ffff800000101f53:	c3                   	ret

ffff800000101f54 <delete_early>:
static void delete_early (free_t *node) { ; }
ffff800000101f54:	55                   	push   rbp
ffff800000101f55:	48 89 e5             	mov    rbp,rsp
ffff800000101f58:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
ffff800000101f5c:	90                   	nop
ffff800000101f5d:	5d                   	pop    rbp
ffff800000101f5e:	c3                   	ret

ffff800000101f5f <alloc_post>:

static void *alloc_post (free_t *prev, size_t num) { return (void *)prev; }
ffff800000101f5f:	55                   	push   rbp
ffff800000101f60:	48 89 e5             	mov    rbp,rsp
ffff800000101f63:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
ffff800000101f67:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
ffff800000101f6b:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101f6f:	5d                   	pop    rbp
ffff800000101f70:	c3                   	ret

ffff800000101f71 <delete_post>:
static void delete_post (free_t *node) { ; }
ffff800000101f71:	55                   	push   rbp
ffff800000101f72:	48 89 e5             	mov    rbp,rsp
ffff800000101f75:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
ffff800000101f79:	90                   	nop
ffff800000101f7a:	5d                   	pop    rbp
ffff800000101f7b:	c3                   	ret

ffff800000101f7c <alloc0_post>:

static void *alloc0_post (free_t *prev, size_t num) { return malloc (sizeof(free_t)); }
ffff800000101f7c:	55                   	push   rbp
ffff800000101f7d:	48 89 e5             	mov    rbp,rsp
ffff800000101f80:	48 83 ec 10          	sub    rsp,0x10
ffff800000101f84:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
ffff800000101f88:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
ffff800000101f8c:	bf 18 00 00 00       	mov    edi,0x18
ffff800000101f91:	e8 cb 11 00 00       	call   ffff800000103161 <malloc>
ffff800000101f96:	c9                   	leave
ffff800000101f97:	c3                   	ret

ffff800000101f98 <delete0_post>:
static void delete0_post (free_t *node) { free (node); }
ffff800000101f98:	55                   	push   rbp
ffff800000101f99:	48 89 e5             	mov    rbp,rsp
ffff800000101f9c:	48 83 ec 10          	sub    rsp,0x10
ffff800000101fa0:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
ffff800000101fa4:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000101fa8:	48 89 c7             	mov    rdi,rax
ffff800000101fab:	e8 6b 13 00 00       	call   ffff80000010331b <free>
ffff800000101fb0:	90                   	nop
ffff800000101fb1:	c9                   	leave
ffff800000101fb2:	c3                   	ret

ffff800000101fb3 <pmm_allocpages>:
static void *(*delete)(free_t *node);
static void *(*delete0)(free_t *node);

/* 获取 Num 页的内存,没有则返回 NULL */
void *pmm_allocpages (size_t num)
{
ffff800000101fb3:	55                   	push   rbp
ffff800000101fb4:	48 89 e5             	mov    rbp,rsp
ffff800000101fb7:	48 83 ec 30          	sub    rsp,0x30
ffff800000101fbb:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
    void *page = NULL;
ffff800000101fbf:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
ffff800000101fc6:	00 

    free_t *n = &_free;
ffff800000101fc7:	48 8d 05 72 02 01 00 	lea    rax,[rip+0x10272]        # ffff800000112240 <_free>
ffff800000101fce:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
    free_t *prev = &_free;
ffff800000101fd2:	48 8d 05 67 02 01 00 	lea    rax,[rip+0x10267]        # ffff800000112240 <_free>
ffff800000101fd9:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax

    do {
        n = n->next;
ffff800000101fdd:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101fe1:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff800000101fe5:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
        if (n->pages >= num)
ffff800000101fe9:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101fed:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff800000101ff0:	48 3b 45 d8          	cmp    rax,QWORD PTR [rbp-0x28]
ffff800000101ff4:	0f 82 c4 00 00 00    	jb     ffff8000001020be <pmm_allocpages+0x10b>
        {
            n->pages -= num;
ffff800000101ffa:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000101ffe:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff800000102001:	48 2b 45 d8          	sub    rax,QWORD PTR [rbp-0x28]
ffff800000102005:	48 89 c2             	mov    rdx,rax
ffff800000102008:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff80000010200c:	48 89 10             	mov    QWORD PTR [rax],rdx
            page = (void *)n->addr;
ffff80000010200f:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000102013:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff800000102017:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

            if (n->pages == 0) {
ffff80000010201b:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff80000010201f:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff800000102022:	48 85 c0             	test   rax,rax
ffff800000102025:	75 25                	jne    ffff80000010204c <pmm_allocpages+0x99>
                prev->next = n->next; // 越过,销毁
ffff800000102027:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff80000010202b:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
ffff80000010202f:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000102033:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
                delete0(n);
ffff800000102037:	48 8b 15 32 02 01 00 	mov    rdx,QWORD PTR [rip+0x10232]        # ffff800000112270 <delete0>
ffff80000010203e:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000102042:	48 89 c7             	mov    rdi,rax
ffff800000102045:	ff d2                	call   rdx
                prev->next = new;

                delete(n);
            }

            break;
ffff800000102047:	e9 8f 00 00 00       	jmp    ffff8000001020db <pmm_allocpages+0x128>
                free_t *new = alloc(n, num);
ffff80000010204c:	48 8b 0d 05 02 01 00 	mov    rcx,QWORD PTR [rip+0x10205]        # ffff800000112258 <alloc>
ffff800000102053:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
ffff800000102057:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff80000010205b:	48 89 d6             	mov    rsi,rdx
ffff80000010205e:	48 89 c7             	mov    rdi,rax
ffff800000102061:	ff d1                	call   rcx
ffff800000102063:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
                new->addr = n->addr + num * PAGE_SIZ;
ffff800000102067:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff80000010206b:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff80000010206f:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
ffff800000102073:	48 c1 e2 0c          	shl    rdx,0xc
ffff800000102077:	48 01 c2             	add    rdx,rax
ffff80000010207a:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff80000010207e:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
                new->pages = n->pages; // 之前已经减过了
ffff800000102082:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000102086:	48 8b 10             	mov    rdx,QWORD PTR [rax]
ffff800000102089:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff80000010208d:	48 89 10             	mov    QWORD PTR [rax],rdx
                new->next = n->next;
ffff800000102090:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000102094:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
ffff800000102098:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff80000010209c:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
                prev->next = new;
ffff8000001020a0:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001020a4:	48 8b 55 e0          	mov    rdx,QWORD PTR [rbp-0x20]
ffff8000001020a8:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
                delete(n);
ffff8000001020ac:	48 8b 15 b5 01 01 00 	mov    rdx,QWORD PTR [rip+0x101b5]        # ffff800000112268 <delete>
ffff8000001020b3:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff8000001020b7:	48 89 c7             	mov    rdi,rax
ffff8000001020ba:	ff d2                	call   rdx
            break;
ffff8000001020bc:	eb 1d                	jmp    ffff8000001020db <pmm_allocpages+0x128>
        }
        prev = prev->next;
ffff8000001020be:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001020c2:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff8000001020c6:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
    } while (n->next);
ffff8000001020ca:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff8000001020ce:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff8000001020d2:	48 85 c0             	test   rax,rax
ffff8000001020d5:	0f 85 02 ff ff ff    	jne    ffff800000101fdd <pmm_allocpages+0x2a>

    if (page) {
ffff8000001020db:	48 83 7d f8 00       	cmp    QWORD PTR [rbp-0x8],0x0
ffff8000001020e0:	74 43                	je     ffff800000102125 <pmm_allocpages+0x172>
        page_free -= num;
ffff8000001020e2:	48 8b 05 4f 01 01 00 	mov    rax,QWORD PTR [rip+0x1014f]        # ffff800000112238 <page_free>
ffff8000001020e9:	48 2b 45 d8          	sub    rax,QWORD PTR [rbp-0x28]
ffff8000001020ed:	48 89 05 44 01 01 00 	mov    QWORD PTR [rip+0x10144],rax        # ffff800000112238 <page_free>
        DEBUGK ("allocate pages ! - %p,%llu\n", page, num);
ffff8000001020f4:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
ffff8000001020f8:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001020fc:	49 89 d0             	mov    r8,rdx
ffff8000001020ff:	48 89 c1             	mov    rcx,rax
ffff800000102102:	48 8d 05 e7 42 00 00 	lea    rax,[rip+0x42e7]        # ffff8000001063f0 <lwstr+0x1b0>
ffff800000102109:	48 89 c2             	mov    rdx,rax
ffff80000010210c:	be 4f 00 00 00       	mov    esi,0x4f
ffff800000102111:	48 8d 05 f4 42 00 00 	lea    rax,[rip+0x42f4]        # ffff80000010640c <lwstr+0x1cc>
ffff800000102118:	48 89 c7             	mov    rdi,rax
ffff80000010211b:	b8 00 00 00 00       	mov    eax,0x0
ffff800000102120:	e8 9d df ff ff       	call   ffff8000001000c2 <debugk>
    }
    return page;
ffff800000102125:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
}
ffff800000102129:	c9                   	leave
ffff80000010212a:	c3                   	ret

ffff80000010212b <pmm_allochard>:

#include <textos/assert.h>

void pmm_allochard (void *page, size_t num)
{
ffff80000010212b:	55                   	push   rbp
ffff80000010212c:	48 89 e5             	mov    rbp,rsp
ffff80000010212f:	48 83 ec 70          	sub    rsp,0x70
ffff800000102133:	48 89 7d 98          	mov    QWORD PTR [rbp-0x68],rdi
ffff800000102137:	48 89 75 90          	mov    QWORD PTR [rbp-0x70],rsi
    if (num == 0) return;
ffff80000010213b:	48 83 7d 90 00       	cmp    QWORD PTR [rbp-0x70],0x0
ffff800000102140:	0f 84 41 02 00 00    	je     ffff800000102387 <pmm_allochard+0x25c>

    addr_t start = (addr_t)page;
ffff800000102146:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
ffff80000010214a:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
    addr_t end   = start + num * PAGE_SIZ;
ffff80000010214e:	48 8b 45 90          	mov    rax,QWORD PTR [rbp-0x70]
ffff800000102152:	48 c1 e0 0c          	shl    rax,0xc
ffff800000102156:	48 89 c2             	mov    rdx,rax
ffff800000102159:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff80000010215d:	48 01 d0             	add    rax,rdx
ffff800000102160:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax

    free_t *n = &_free;
ffff800000102164:	48 8d 05 d5 00 01 00 	lea    rax,[rip+0x100d5]        # ffff800000112240 <_free>
ffff80000010216b:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    free_t *prev = &_free;
ffff80000010216f:	48 8d 05 ca 00 01 00 	lea    rax,[rip+0x100ca]        # ffff800000112240 <_free>
ffff800000102176:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax

    do {
        n = n->next;
ffff80000010217a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010217e:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff800000102182:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

        addr_t ps = n->addr,
ffff800000102186:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010218a:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff80000010218e:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
               pe = n->addr + n->pages * PAGE_SIZ;
ffff800000102192:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102196:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
ffff80000010219a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010219e:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff8000001021a1:	48 c1 e0 0c          	shl    rax,0xc
ffff8000001021a5:	48 01 d0             	add    rax,rdx
ffff8000001021a8:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
        if (pe < start || end < ps)
ffff8000001021ac:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff8000001021b0:	48 3b 45 e8          	cmp    rax,QWORD PTR [rbp-0x18]
ffff8000001021b4:	0f 82 aa 01 00 00    	jb     ffff800000102364 <pmm_allochard+0x239>
ffff8000001021ba:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff8000001021be:	48 3b 45 d8          	cmp    rax,QWORD PTR [rbp-0x28]
ffff8000001021c2:	0f 82 9c 01 00 00    	jb     ffff800000102364 <pmm_allochard+0x239>
            goto next;

        if (start <= ps && pe <= end) {
ffff8000001021c8:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001021cc:	48 39 45 d8          	cmp    QWORD PTR [rbp-0x28],rax
ffff8000001021d0:	72 2a                	jb     ffff8000001021fc <pmm_allochard+0xd1>
ffff8000001021d2:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff8000001021d6:	48 39 45 e0          	cmp    QWORD PTR [rbp-0x20],rax
ffff8000001021da:	72 20                	jb     ffff8000001021fc <pmm_allochard+0xd1>
            prev->next = n->next;
ffff8000001021dc:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001021e0:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
ffff8000001021e4:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff8000001021e8:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
            delete0(n);
ffff8000001021ec:	48 8b 15 7d 00 01 00 	mov    rdx,QWORD PTR [rip+0x1007d]        # ffff800000112270 <delete0>
ffff8000001021f3:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001021f7:	48 89 c7             	mov    rdi,rax
ffff8000001021fa:	ff d2                	call   rdx
        }

        if (start <= ps && ps < end) {
ffff8000001021fc:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000102200:	48 39 45 d8          	cmp    QWORD PTR [rbp-0x28],rax
ffff800000102204:	72 6a                	jb     ffff800000102270 <pmm_allochard+0x145>
ffff800000102206:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff80000010220a:	48 3b 45 e0          	cmp    rax,QWORD PTR [rbp-0x20]
ffff80000010220e:	73 60                	jae    ffff800000102270 <pmm_allochard+0x145>
            free_t *new = alloc0((free_t *)end, 0);
ffff800000102210:	48 8b 15 49 00 01 00 	mov    rdx,QWORD PTR [rip+0x10049]        # ffff800000112260 <alloc0>
ffff800000102217:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff80000010221b:	be 00 00 00 00       	mov    esi,0x0
ffff800000102220:	48 89 c7             	mov    rdi,rax
ffff800000102223:	ff d2                	call   rdx
ffff800000102225:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax

            new->pages = (pe - end) / PAGE_SIZ;
ffff800000102229:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff80000010222d:	48 2b 45 e0          	sub    rax,QWORD PTR [rbp-0x20]
ffff800000102231:	48 c1 e8 0c          	shr    rax,0xc
ffff800000102235:	48 89 c2             	mov    rdx,rax
ffff800000102238:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff80000010223c:	48 89 10             	mov    QWORD PTR [rax],rdx
            new->next = n->next;
ffff80000010223f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102243:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
ffff800000102247:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff80000010224b:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
            prev->next = new;
ffff80000010224f:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000102253:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
ffff800000102257:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx

            delete0(n);
ffff80000010225b:	48 8b 15 0e 00 01 00 	mov    rdx,QWORD PTR [rip+0x1000e]        # ffff800000112270 <delete0>
ffff800000102262:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102266:	48 89 c7             	mov    rdi,rax
ffff800000102269:	ff d2                	call   rdx
        if (start <= ps && ps < end) {
ffff80000010226b:	e9 f8 00 00 00       	jmp    ffff800000102368 <pmm_allochard+0x23d>
        } else if (start < pe && pe <= end) {
ffff800000102270:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000102274:	48 3b 45 d0          	cmp    rax,QWORD PTR [rbp-0x30]
ffff800000102278:	73 2c                	jae    ffff8000001022a6 <pmm_allochard+0x17b>
ffff80000010227a:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff80000010227e:	48 39 45 e0          	cmp    QWORD PTR [rbp-0x20],rax
ffff800000102282:	72 22                	jb     ffff8000001022a6 <pmm_allochard+0x17b>
            n->pages -= (pe - start) / PAGE_SIZ;
ffff800000102284:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102288:	48 8b 10             	mov    rdx,QWORD PTR [rax]
ffff80000010228b:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff80000010228f:	48 2b 45 e8          	sub    rax,QWORD PTR [rbp-0x18]
ffff800000102293:	48 c1 e8 0c          	shr    rax,0xc
ffff800000102297:	48 29 c2             	sub    rdx,rax
ffff80000010229a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010229e:	48 89 10             	mov    QWORD PTR [rax],rdx
ffff8000001022a1:	e9 c2 00 00 00       	jmp    ffff800000102368 <pmm_allochard+0x23d>
        } else if (ps < start && end < pe) {
ffff8000001022a6:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001022aa:	48 3b 45 e8          	cmp    rax,QWORD PTR [rbp-0x18]
ffff8000001022ae:	0f 83 b3 00 00 00    	jae    ffff800000102367 <pmm_allochard+0x23c>
ffff8000001022b4:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff8000001022b8:	48 3b 45 d0          	cmp    rax,QWORD PTR [rbp-0x30]
ffff8000001022bc:	0f 83 a5 00 00 00    	jae    ffff800000102367 <pmm_allochard+0x23c>
            free_t *free0 = alloc0((free_t *)ps, 0);
ffff8000001022c2:	48 8b 15 97 ff 00 00 	mov    rdx,QWORD PTR [rip+0xff97]        # ffff800000112260 <alloc0>
ffff8000001022c9:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001022cd:	be 00 00 00 00       	mov    esi,0x0
ffff8000001022d2:	48 89 c7             	mov    rdi,rax
ffff8000001022d5:	ff d2                	call   rdx
ffff8000001022d7:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
            free_t *free1 = alloc0((free_t *)end, 0);
ffff8000001022db:	48 8b 15 7e ff 00 00 	mov    rdx,QWORD PTR [rip+0xff7e]        # ffff800000112260 <alloc0>
ffff8000001022e2:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff8000001022e6:	be 00 00 00 00       	mov    esi,0x0
ffff8000001022eb:	48 89 c7             	mov    rdi,rax
ffff8000001022ee:	ff d2                	call   rdx
ffff8000001022f0:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax

            size_t pg0 = (start - ps) / PAGE_SIZ;
ffff8000001022f4:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001022f8:	48 2b 45 d8          	sub    rax,QWORD PTR [rbp-0x28]
ffff8000001022fc:	48 c1 e8 0c          	shr    rax,0xc
ffff800000102300:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
            size_t pg1 = (pe - end) / PAGE_SIZ;
ffff800000102304:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff800000102308:	48 2b 45 e0          	sub    rax,QWORD PTR [rbp-0x20]
ffff80000010230c:	48 c1 e8 0c          	shr    rax,0xc
ffff800000102310:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax

            free0->pages = pg0;
ffff800000102314:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
ffff800000102318:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
ffff80000010231c:	48 89 10             	mov    QWORD PTR [rax],rdx
            free1->pages = pg1;
ffff80000010231f:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
ffff800000102323:	48 8b 55 a8          	mov    rdx,QWORD PTR [rbp-0x58]
ffff800000102327:	48 89 10             	mov    QWORD PTR [rax],rdx

            free1->next = n->next;
ffff80000010232a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010232e:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
ffff800000102332:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
ffff800000102336:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
            free0->next = free1;
ffff80000010233a:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
ffff80000010233e:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
ffff800000102342:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
            prev->next = free0;
ffff800000102346:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff80000010234a:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
ffff80000010234e:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx

            delete0(n);
ffff800000102352:	48 8b 15 17 ff 00 00 	mov    rdx,QWORD PTR [rip+0xff17]        # ffff800000112270 <delete0>
ffff800000102359:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010235d:	48 89 c7             	mov    rdi,rax
ffff800000102360:	ff d2                	call   rdx
ffff800000102362:	eb 04                	jmp    ffff800000102368 <pmm_allochard+0x23d>
            goto next;
ffff800000102364:	90                   	nop
ffff800000102365:	eb 01                	jmp    ffff800000102368 <pmm_allochard+0x23d>
        }

next:
ffff800000102367:	90                   	nop
        prev = prev->next;
ffff800000102368:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff80000010236c:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff800000102370:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
    } while (n->next);
ffff800000102374:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102378:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff80000010237c:	48 85 c0             	test   rax,rax
ffff80000010237f:	0f 85 f5 fd ff ff    	jne    ffff80000010217a <pmm_allochard+0x4f>
ffff800000102385:	eb 01                	jmp    ffff800000102388 <pmm_allochard+0x25d>
    if (num == 0) return;
ffff800000102387:	90                   	nop
}
ffff800000102388:	c9                   	leave
ffff800000102389:	c3                   	ret

ffff80000010238a <_pmm_isfree>:

static bool _pmm_isfree (void *page, size_t num)
{
ffff80000010238a:	55                   	push   rbp
ffff80000010238b:	48 89 e5             	mov    rbp,rsp
ffff80000010238e:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
ffff800000102392:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
    free_t *n = &_free;
ffff800000102396:	48 8d 05 a3 fe 00 00 	lea    rax,[rip+0xfea3]        # ffff800000112240 <_free>
ffff80000010239d:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

       non   : ZAStart >= ZBEnd || ZBStart >= ZAEnd
       exist(for `if`) : MAX(ZAStart, ZBStart) < MIN(ZAEnd, ZBEnd)
    */

    addr_t start = (addr_t)page,
ffff8000001023a1:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff8000001023a5:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
           end   = (addr_t)page + num * PAGE_SIZ;
ffff8000001023a9:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
ffff8000001023ad:	48 c1 e0 0c          	shl    rax,0xc
ffff8000001023b1:	48 89 c2             	mov    rdx,rax
ffff8000001023b4:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff8000001023b8:	48 01 d0             	add    rax,rdx
ffff8000001023bb:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax

    do {
        n = n->next;
ffff8000001023bf:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001023c3:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff8000001023c7:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
        addr_t ps = (addr_t)n->addr,
ffff8000001023cb:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001023cf:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff8000001023d3:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
               pe = (addr_t)n->addr + n->pages * PAGE_SIZ;
ffff8000001023d7:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001023db:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
ffff8000001023df:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001023e3:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff8000001023e6:	48 c1 e0 0c          	shl    rax,0xc
ffff8000001023ea:	48 01 d0             	add    rax,rdx
ffff8000001023ed:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
        if (MAX(ps, start) < MIN(pe, end)) {
ffff8000001023f1:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
ffff8000001023f5:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff8000001023f9:	48 39 c2             	cmp    rdx,rax
ffff8000001023fc:	48 0f 43 c2          	cmovae rax,rdx
ffff800000102400:	48 89 c1             	mov    rcx,rax
ffff800000102403:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
ffff800000102407:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff80000010240b:	48 39 c2             	cmp    rdx,rax
ffff80000010240e:	48 0f 46 c2          	cmovbe rax,rdx
ffff800000102412:	48 39 c1             	cmp    rcx,rax
ffff800000102415:	73 07                	jae    ffff80000010241e <_pmm_isfree+0x94>
            return true;
ffff800000102417:	b8 01 00 00 00       	mov    eax,0x1
ffff80000010241c:	eb 12                	jmp    ffff800000102430 <_pmm_isfree+0xa6>
        }
    } while (n->next);
ffff80000010241e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102422:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff800000102426:	48 85 c0             	test   rax,rax
ffff800000102429:	75 94                	jne    ffff8000001023bf <_pmm_isfree+0x35>

    return false;
ffff80000010242b:	b8 00 00 00 00       	mov    eax,0x0
}
ffff800000102430:	5d                   	pop    rbp
ffff800000102431:	c3                   	ret

ffff800000102432 <pmm_freepages>:

void pmm_freepages (void *page, size_t num)
{
ffff800000102432:	55                   	push   rbp
ffff800000102433:	48 89 e5             	mov    rbp,rsp
ffff800000102436:	48 83 ec 50          	sub    rsp,0x50
ffff80000010243a:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
ffff80000010243e:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi
    page = (void*)((addr_t)page &~ 0x7ff); // 抹掉低位
ffff800000102442:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
ffff800000102446:	48 25 00 f8 ff ff    	and    rax,0xfffffffffffff800
ffff80000010244c:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
    if (_pmm_isfree (page, num)) {
ffff800000102450:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
ffff800000102454:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
ffff800000102458:	48 89 d6             	mov    rsi,rdx
ffff80000010245b:	48 89 c7             	mov    rdi,rax
ffff80000010245e:	e8 27 ff ff ff       	call   ffff80000010238a <_pmm_isfree>
ffff800000102463:	84 c0                	test   al,al
ffff800000102465:	74 36                	je     ffff80000010249d <pmm_freepages+0x6b>
        DEBUGK ("these pages are free before! - %p,%llu\n", page, num);
ffff800000102467:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
ffff80000010246b:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
ffff80000010246f:	49 89 d0             	mov    r8,rdx
ffff800000102472:	48 89 c1             	mov    rcx,rax
ffff800000102475:	48 8d 05 9c 3f 00 00 	lea    rax,[rip+0x3f9c]        # ffff800000106418 <lwstr+0x1d8>
ffff80000010247c:	48 89 c2             	mov    rdx,rax
ffff80000010247f:	be ad 00 00 00       	mov    esi,0xad
ffff800000102484:	48 8d 05 81 3f 00 00 	lea    rax,[rip+0x3f81]        # ffff80000010640c <lwstr+0x1cc>
ffff80000010248b:	48 89 c7             	mov    rdi,rax
ffff80000010248e:	b8 00 00 00 00       	mov    eax,0x0
ffff800000102493:	e8 2a dc ff ff       	call   ffff8000001000c2 <debugk>
        return;
ffff800000102498:	e9 17 02 00 00       	jmp    ffff8000001026b4 <pmm_freepages+0x282>
    }

    addr_t start = (addr_t)page,
ffff80000010249d:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
ffff8000001024a1:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
           end   = (addr_t)page + num * PAGE_SIZ;
ffff8000001024a5:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
ffff8000001024a9:	48 c1 e0 0c          	shl    rax,0xc
ffff8000001024ad:	48 89 c2             	mov    rdx,rax
ffff8000001024b0:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
ffff8000001024b4:	48 01 d0             	add    rax,rdx
ffff8000001024b7:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax

    free_t *n = &_free;
ffff8000001024bb:	48 8d 05 7e fd 00 00 	lea    rax,[rip+0xfd7e]        # ffff800000112240 <_free>
ffff8000001024c2:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    free_t *prev = &_free;
ffff8000001024c6:	48 8d 05 73 fd 00 00 	lea    rax,[rip+0xfd73]        # ffff800000112240 <_free>
ffff8000001024cd:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
    do {
        n = n->next;
ffff8000001024d1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001024d5:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff8000001024d9:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

        addr_t ps = n->addr,
ffff8000001024dd:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001024e1:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff8000001024e5:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
               pe = n->addr + n->pages * PAGE_SIZ;
ffff8000001024e9:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001024ed:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
ffff8000001024f1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001024f5:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff8000001024f8:	48 c1 e0 0c          	shl    rax,0xc
ffff8000001024fc:	48 01 d0             	add    rax,rdx
ffff8000001024ff:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax

        if (ps == end)        // Head
ffff800000102503:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000102507:	48 3b 45 e0          	cmp    rax,QWORD PTR [rbp-0x20]
ffff80000010250b:	75 6b                	jne    ffff800000102578 <pmm_freepages+0x146>
        {
            free_t *new = alloc(page, 0);
ffff80000010250d:	48 8b 15 44 fd 00 00 	mov    rdx,QWORD PTR [rip+0xfd44]        # ffff800000112258 <alloc>
ffff800000102514:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
ffff800000102518:	be 00 00 00 00       	mov    esi,0x0
ffff80000010251d:	48 89 c7             	mov    rdi,rax
ffff800000102520:	ff d2                	call   rdx
ffff800000102522:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
            new->addr = start;
ffff800000102526:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
ffff80000010252a:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
ffff80000010252e:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
            new->pages = n->pages + num;
ffff800000102532:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102536:	48 8b 10             	mov    rdx,QWORD PTR [rax]
ffff800000102539:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
ffff80000010253d:	48 01 c2             	add    rdx,rax
ffff800000102540:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
ffff800000102544:	48 89 10             	mov    QWORD PTR [rax],rdx
            new->next = n->next;
ffff800000102547:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010254b:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
ffff80000010254f:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
ffff800000102553:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
            prev->next = new;
ffff800000102557:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff80000010255b:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
ffff80000010255f:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx

            delete(n);
ffff800000102563:	48 8b 15 fe fc 00 00 	mov    rdx,QWORD PTR [rip+0xfcfe]        # ffff800000112268 <delete>
ffff80000010256a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010256e:	48 89 c7             	mov    rdi,rax
ffff800000102571:	ff d2                	call   rdx
            break;
ffff800000102573:	e9 f6 00 00 00       	jmp    ffff80000010266e <pmm_freepages+0x23c>
        }
        else if (pe == start) // Tail
ffff800000102578:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff80000010257c:	48 3b 45 e8          	cmp    rax,QWORD PTR [rbp-0x18]
ffff800000102580:	75 1a                	jne    ffff80000010259c <pmm_freepages+0x16a>
        {
            n->pages += num;
ffff800000102582:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102586:	48 8b 10             	mov    rdx,QWORD PTR [rax]
ffff800000102589:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
ffff80000010258d:	48 01 c2             	add    rdx,rax
ffff800000102590:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102594:	48 89 10             	mov    QWORD PTR [rax],rdx
            break;
ffff800000102597:	e9 d2 00 00 00       	jmp    ffff80000010266e <pmm_freepages+0x23c>
        }
        else if (ps < start && (!n->next || n->next->addr > start)) // Another case
ffff80000010259c:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001025a0:	48 3b 45 e8          	cmp    rax,QWORD PTR [rbp-0x18]
ffff8000001025a4:	0f 83 a7 00 00 00    	jae    ffff800000102651 <pmm_freepages+0x21f>
ffff8000001025aa:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001025ae:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff8000001025b2:	48 85 c0             	test   rax,rax
ffff8000001025b5:	74 16                	je     ffff8000001025cd <pmm_freepages+0x19b>
ffff8000001025b7:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001025bb:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff8000001025bf:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff8000001025c3:	48 39 45 e8          	cmp    QWORD PTR [rbp-0x18],rax
ffff8000001025c7:	0f 83 84 00 00 00    	jae    ffff800000102651 <pmm_freepages+0x21f>
        {
            ASSERTK(end < n->next->addr);
ffff8000001025cd:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001025d1:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff8000001025d5:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff8000001025d9:	48 39 45 e0          	cmp    QWORD PTR [rbp-0x20],rax
ffff8000001025dd:	0f 92 c0             	setb   al
ffff8000001025e0:	0f b6 c0             	movzx  eax,al
ffff8000001025e3:	48 8d 15 56 3e 00 00 	lea    rdx,[rip+0x3e56]        # ffff800000106440 <lwstr+0x200>
ffff8000001025ea:	48 89 d1             	mov    rcx,rdx
ffff8000001025ed:	89 c2                	mov    edx,eax
ffff8000001025ef:	be ce 00 00 00       	mov    esi,0xce
ffff8000001025f4:	48 8d 05 11 3e 00 00 	lea    rax,[rip+0x3e11]        # ffff80000010640c <lwstr+0x1cc>
ffff8000001025fb:	48 89 c7             	mov    rdi,rax
ffff8000001025fe:	e8 94 db ff ff       	call   ffff800000100197 <assertk>

            free_t *new = alloc0(page, 0);
ffff800000102603:	48 8b 15 56 fc 00 00 	mov    rdx,QWORD PTR [rip+0xfc56]        # ffff800000112260 <alloc0>
ffff80000010260a:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
ffff80000010260e:	be 00 00 00 00       	mov    esi,0x0
ffff800000102613:	48 89 c7             	mov    rdi,rax
ffff800000102616:	ff d2                	call   rdx
ffff800000102618:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax

            new->addr = start;
ffff80000010261c:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff800000102620:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
ffff800000102624:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
            new->pages = num;
ffff800000102628:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff80000010262c:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
ffff800000102630:	48 89 10             	mov    QWORD PTR [rax],rdx
            new->next = n->next;
ffff800000102633:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102637:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
ffff80000010263b:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff80000010263f:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
            n->next = new;
ffff800000102643:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102647:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
ffff80000010264b:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
            break;
ffff80000010264f:	eb 1d                	jmp    ffff80000010266e <pmm_freepages+0x23c>
        }

        prev = prev->next;
ffff800000102651:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000102655:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff800000102659:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
    } while (n->next);
ffff80000010265d:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102661:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff800000102665:	48 85 c0             	test   rax,rax
ffff800000102668:	0f 85 63 fe ff ff    	jne    ffff8000001024d1 <pmm_freepages+0x9f>

    page_free += num;
ffff80000010266e:	48 8b 15 c3 fb 00 00 	mov    rdx,QWORD PTR [rip+0xfbc3]        # ffff800000112238 <page_free>
ffff800000102675:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
ffff800000102679:	48 01 d0             	add    rax,rdx
ffff80000010267c:	48 89 05 b5 fb 00 00 	mov    QWORD PTR [rip+0xfbb5],rax        # ffff800000112238 <page_free>
    DEBUGK ("free pages! - %p,%llu\n", page, num);
ffff800000102683:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
ffff800000102687:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
ffff80000010268b:	49 89 d0             	mov    r8,rdx
ffff80000010268e:	48 89 c1             	mov    rcx,rax
ffff800000102691:	48 8d 05 bc 3d 00 00 	lea    rax,[rip+0x3dbc]        # ffff800000106454 <lwstr+0x214>
ffff800000102698:	48 89 c2             	mov    rdx,rax
ffff80000010269b:	be dd 00 00 00       	mov    esi,0xdd
ffff8000001026a0:	48 8d 05 65 3d 00 00 	lea    rax,[rip+0x3d65]        # ffff80000010640c <lwstr+0x1cc>
ffff8000001026a7:	48 89 c7             	mov    rdi,rax
ffff8000001026aa:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001026af:	e8 0e da ff ff       	call   ffff8000001000c2 <debugk>
}
ffff8000001026b4:	c9                   	leave
ffff8000001026b5:	c3                   	ret

ffff8000001026b6 <pmm_init>:

void pmm_init ()
{
ffff8000001026b6:	55                   	push   rbp
ffff8000001026b7:	48 89 e5             	mov    rbp,rsp
    DEBUGK ("pages : - total(%llu), free(%llu)\n", page_total, page_free);
ffff8000001026ba:	48 8b 15 77 fb 00 00 	mov    rdx,QWORD PTR [rip+0xfb77]        # ffff800000112238 <page_free>
ffff8000001026c1:	48 8b 05 68 fb 00 00 	mov    rax,QWORD PTR [rip+0xfb68]        # ffff800000112230 <page_total>
ffff8000001026c8:	49 89 d0             	mov    r8,rdx
ffff8000001026cb:	48 89 c1             	mov    rcx,rax
ffff8000001026ce:	48 8d 05 9b 3d 00 00 	lea    rax,[rip+0x3d9b]        # ffff800000106470 <lwstr+0x230>
ffff8000001026d5:	48 89 c2             	mov    rdx,rax
ffff8000001026d8:	be e2 00 00 00       	mov    esi,0xe2
ffff8000001026dd:	48 8d 05 28 3d 00 00 	lea    rax,[rip+0x3d28]        # ffff80000010640c <lwstr+0x1cc>
ffff8000001026e4:	48 89 c7             	mov    rdi,rax
ffff8000001026e7:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001026ec:	e8 d1 d9 ff ff       	call   ffff8000001000c2 <debugk>
}
ffff8000001026f1:	90                   	nop
ffff8000001026f2:	5d                   	pop    rbp
ffff8000001026f3:	c3                   	ret

ffff8000001026f4 <__pmm_tovmm>:

void __pmm_tovmm ()
{
ffff8000001026f4:	55                   	push   rbp
ffff8000001026f5:	48 89 e5             	mov    rbp,rsp
ffff8000001026f8:	53                   	push   rbx
ffff8000001026f9:	48 83 ec 48          	sub    rsp,0x48
ffff8000001026fd:	48 89 e0             	mov    rax,rsp
ffff800000102700:	48 89 c3             	mov    rbx,rax
    /* 必须要注意的是, 在完成之前最好避免执行任何的物理内存分配操作 */

    free_t *old = &_free,
ffff800000102703:	48 8d 05 36 fb 00 00 	lea    rax,[rip+0xfb36]        # ffff800000112240 <_free>
ffff80000010270a:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
           *new = &_free;
ffff80000010270e:	48 8d 05 2b fb 00 00 	lea    rax,[rip+0xfb2b]        # ffff800000112240 <_free>
ffff800000102715:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax

    size_t i = 0,
ffff800000102719:	48 c7 45 d8 00 00 00 	mov    QWORD PTR [rbp-0x28],0x0
ffff800000102720:	00 
           cnt = 0;
ffff800000102721:	48 c7 45 d0 00 00 00 	mov    QWORD PTR [rbp-0x30],0x0
ffff800000102728:	00 
    for (free_t *n = _free.next ; n ; n = n->next) cnt++;
ffff800000102729:	48 8b 05 20 fb 00 00 	mov    rax,QWORD PTR [rip+0xfb20]        # ffff800000112250 <_free+0x10>
ffff800000102730:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
ffff800000102734:	eb 11                	jmp    ffff800000102747 <__pmm_tovmm+0x53>
ffff800000102736:	48 83 45 d0 01       	add    QWORD PTR [rbp-0x30],0x1
ffff80000010273b:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff80000010273f:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff800000102743:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
ffff800000102747:	48 83 7d c8 00       	cmp    QWORD PTR [rbp-0x38],0x0
ffff80000010274c:	75 e8                	jne    ffff800000102736 <__pmm_tovmm+0x42>

    void *array[cnt];
ffff80000010274e:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff800000102752:	48 89 c2             	mov    rdx,rax
ffff800000102755:	48 83 ea 01          	sub    rdx,0x1
ffff800000102759:	48 89 55 c0          	mov    QWORD PTR [rbp-0x40],rdx
ffff80000010275d:	48 8d 14 c5 00 00 00 	lea    rdx,[rax*8+0x0]
ffff800000102764:	00 
ffff800000102765:	b8 10 00 00 00       	mov    eax,0x10
ffff80000010276a:	48 83 e8 01          	sub    rax,0x1
ffff80000010276e:	48 01 d0             	add    rax,rdx
ffff800000102771:	be 10 00 00 00       	mov    esi,0x10
ffff800000102776:	ba 00 00 00 00       	mov    edx,0x0
ffff80000010277b:	48 f7 f6             	div    rsi
ffff80000010277e:	48 6b c0 10          	imul   rax,rax,0x10
ffff800000102782:	48 29 c4             	sub    rsp,rax
ffff800000102785:	48 89 e0             	mov    rax,rsp
ffff800000102788:	48 83 c0 07          	add    rax,0x7
ffff80000010278c:	48 c1 e8 03          	shr    rax,0x3
ffff800000102790:	48 c1 e0 03          	shl    rax,0x3
ffff800000102794:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
    for (i = 0 ; i < cnt ; i++)
ffff800000102798:	48 c7 45 d8 00 00 00 	mov    QWORD PTR [rbp-0x28],0x0
ffff80000010279f:	00 
ffff8000001027a0:	eb 1b                	jmp    ffff8000001027bd <__pmm_tovmm+0xc9>
        array[i] = malloc(sizeof(free_t));
ffff8000001027a2:	bf 18 00 00 00       	mov    edi,0x18
ffff8000001027a7:	e8 b5 09 00 00       	call   ffff800000103161 <malloc>
ffff8000001027ac:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
ffff8000001027b0:	48 8b 4d d8          	mov    rcx,QWORD PTR [rbp-0x28]
ffff8000001027b4:	48 89 04 ca          	mov    QWORD PTR [rdx+rcx*8],rax
    for (i = 0 ; i < cnt ; i++)
ffff8000001027b8:	48 83 45 d8 01       	add    QWORD PTR [rbp-0x28],0x1
ffff8000001027bd:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001027c1:	48 3b 45 d0          	cmp    rax,QWORD PTR [rbp-0x30]
ffff8000001027c5:	72 db                	jb     ffff8000001027a2 <__pmm_tovmm+0xae>

    i = 0;
ffff8000001027c7:	48 c7 45 d8 00 00 00 	mov    QWORD PTR [rbp-0x28],0x0
ffff8000001027ce:	00 
    while (old->next && i < cnt) {
ffff8000001027cf:	eb 52                	jmp    ffff800000102823 <__pmm_tovmm+0x12f>
        old = old->next;
ffff8000001027d1:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001027d5:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff8000001027d9:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax

        new->next = array[i++];
ffff8000001027dd:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001027e1:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff8000001027e5:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
ffff8000001027e9:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
ffff8000001027ed:	48 8b 14 c2          	mov    rdx,QWORD PTR [rdx+rax*8]
ffff8000001027f1:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff8000001027f5:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
        new = new->next;
ffff8000001027f9:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff8000001027fd:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff800000102801:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax

        new->addr = old->addr;
ffff800000102805:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000102809:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
ffff80000010280d:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000102811:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
        new->pages = old->pages;
ffff800000102815:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000102819:	48 8b 10             	mov    rdx,QWORD PTR [rax]
ffff80000010281c:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000102820:	48 89 10             	mov    QWORD PTR [rax],rdx
    while (old->next && i < cnt) {
ffff800000102823:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000102827:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff80000010282b:	48 85 c0             	test   rax,rax
ffff80000010282e:	74 28                	je     ffff800000102858 <__pmm_tovmm+0x164>
ffff800000102830:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000102834:	48 3b 45 d0          	cmp    rax,QWORD PTR [rbp-0x30]
ffff800000102838:	72 97                	jb     ffff8000001027d1 <__pmm_tovmm+0xdd>
    }

    while (i < cnt)
ffff80000010283a:	eb 1c                	jmp    ffff800000102858 <__pmm_tovmm+0x164>
        free (array[i++]);
ffff80000010283c:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000102840:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff800000102844:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
ffff800000102848:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
ffff80000010284c:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
ffff800000102850:	48 89 c7             	mov    rdi,rax
ffff800000102853:	e8 c3 0a 00 00       	call   ffff80000010331b <free>
    while (i < cnt)
ffff800000102858:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff80000010285c:	48 3b 45 d0          	cmp    rax,QWORD PTR [rbp-0x30]
ffff800000102860:	72 da                	jb     ffff80000010283c <__pmm_tovmm+0x148>

    /* switch mode */
    alloc = (void *)alloc_post;
ffff800000102862:	48 8d 05 f6 f6 ff ff 	lea    rax,[rip+0xfffffffffffff6f6]        # ffff800000101f5f <alloc_post>
ffff800000102869:	48 89 05 e8 f9 00 00 	mov    QWORD PTR [rip+0xf9e8],rax        # ffff800000112258 <alloc>
    alloc0 = (void *)alloc0_post;
ffff800000102870:	48 8d 05 05 f7 ff ff 	lea    rax,[rip+0xfffffffffffff705]        # ffff800000101f7c <alloc0_post>
ffff800000102877:	48 89 05 e2 f9 00 00 	mov    QWORD PTR [rip+0xf9e2],rax        # ffff800000112260 <alloc0>
    delete = (void *)delete_post;
ffff80000010287e:	48 8d 05 ec f6 ff ff 	lea    rax,[rip+0xfffffffffffff6ec]        # ffff800000101f71 <delete_post>
ffff800000102885:	48 89 05 dc f9 00 00 	mov    QWORD PTR [rip+0xf9dc],rax        # ffff800000112268 <delete>
    delete0 = (void *)delete0_post;
ffff80000010288c:	48 8d 05 05 f7 ff ff 	lea    rax,[rip+0xfffffffffffff705]        # ffff800000101f98 <delete0_post>
ffff800000102893:	48 89 05 d6 f9 00 00 	mov    QWORD PTR [rip+0xf9d6],rax        # ffff800000112270 <delete0>
ffff80000010289a:	48 89 dc             	mov    rsp,rbx
}
ffff80000010289d:	90                   	nop
ffff80000010289e:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
ffff8000001028a2:	c9                   	leave
ffff8000001028a3:	c3                   	ret

ffff8000001028a4 <__pmm_pre>:

#include <boot.h>
#include <textos/uefi.h>

void __pmm_pre (mconfig_t *m)
{
ffff8000001028a4:	55                   	push   rbp
ffff8000001028a5:	48 89 e5             	mov    rbp,rsp
ffff8000001028a8:	48 83 ec 40          	sub    rsp,0x40
ffff8000001028ac:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
    mapinfo_t *info = m->map;
ffff8000001028b0:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff8000001028b4:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff8000001028b7:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
    EFI_MEMORY_DESCRIPTOR *desc = info->maps + info->descsiz; // Skip the first one,its ptr points to NULL.
ffff8000001028bb:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001028bf:	48 8b 10             	mov    rdx,QWORD PTR [rax]
ffff8000001028c2:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001028c6:	48 8b 40 20          	mov    rax,QWORD PTR [rax+0x20]
ffff8000001028ca:	48 01 d0             	add    rax,rdx
ffff8000001028cd:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

    page_free = 0;
ffff8000001028d1:	48 c7 05 5c f9 00 00 	mov    QWORD PTR [rip+0xf95c],0x0        # ffff800000112238 <page_free>
ffff8000001028d8:	00 00 00 00 

    free_t *n = &_free;
ffff8000001028dc:	48 8d 05 5d f9 00 00 	lea    rax,[rip+0xf95d]        # ffff800000112240 <_free>
ffff8000001028e3:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
    for (int i = 1 ; i < info->mapcount ; i++, desc = OFFSET(desc, info->descsiz))
ffff8000001028e7:	c7 45 ec 01 00 00 00 	mov    DWORD PTR [rbp-0x14],0x1
ffff8000001028ee:	e9 aa 00 00 00       	jmp    ffff80000010299d <__pmm_pre+0xf9>
    {
        page_total += desc->NumberOfPages;
ffff8000001028f3:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001028f7:	48 8b 50 18          	mov    rdx,QWORD PTR [rax+0x18]
ffff8000001028fb:	48 8b 05 2e f9 00 00 	mov    rax,QWORD PTR [rip+0xf92e]        # ffff800000112230 <page_total>
ffff800000102902:	48 01 d0             	add    rax,rdx
ffff800000102905:	48 89 05 24 f9 00 00 	mov    QWORD PTR [rip+0xf924],rax        # ffff800000112230 <page_total>

        if (desc->Type == EfiBootServicesData ||
ffff80000010290c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102910:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000102912:	83 f8 04             	cmp    eax,0x4
ffff800000102915:	74 0b                	je     ffff800000102922 <__pmm_pre+0x7e>
            desc->Type == EfiBootServicesCode)
ffff800000102917:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010291b:	8b 00                	mov    eax,DWORD PTR [rax]
        if (desc->Type == EfiBootServicesData ||
ffff80000010291d:	83 f8 03             	cmp    eax,0x3
ffff800000102920:	75 0a                	jne    ffff80000010292c <__pmm_pre+0x88>
            desc->Type  = EfiConventionalMemory;
ffff800000102922:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102926:	c7 00 07 00 00 00    	mov    DWORD PTR [rax],0x7

        if (desc->Type != EfiConventionalMemory)
ffff80000010292c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102930:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000102932:	83 f8 07             	cmp    eax,0x7
ffff800000102935:	75 55                	jne    ffff80000010298c <__pmm_pre+0xe8>
            continue;
        page_free += desc->NumberOfPages;
ffff800000102937:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010293b:	48 8b 50 18          	mov    rdx,QWORD PTR [rax+0x18]
ffff80000010293f:	48 8b 05 f2 f8 00 00 	mov    rax,QWORD PTR [rip+0xf8f2]        # ffff800000112238 <page_free>
ffff800000102946:	48 01 d0             	add    rax,rdx
ffff800000102949:	48 89 05 e8 f8 00 00 	mov    QWORD PTR [rip+0xf8e8],rax        # ffff800000112238 <page_free>

        /* 处理与内核占用的物理内存的重叠区域
         *  TODO - replace it!
        */

        n->next = (free_t *)desc->PhysicalStart;
ffff800000102950:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102954:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff800000102958:	48 89 c2             	mov    rdx,rax
ffff80000010295b:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff80000010295f:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
        n = n->next;
ffff800000102963:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000102967:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff80000010296b:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
        n->addr = (u64)n;
ffff80000010296f:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
ffff800000102973:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000102977:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
        n->pages = desc->NumberOfPages;
ffff80000010297b:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010297f:	48 8b 50 18          	mov    rdx,QWORD PTR [rax+0x18]
ffff800000102983:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000102987:	48 89 10             	mov    QWORD PTR [rax],rdx
ffff80000010298a:	eb 01                	jmp    ffff80000010298d <__pmm_pre+0xe9>
            continue;
ffff80000010298c:	90                   	nop
    for (int i = 1 ; i < info->mapcount ; i++, desc = OFFSET(desc, info->descsiz))
ffff80000010298d:	83 45 ec 01          	add    DWORD PTR [rbp-0x14],0x1
ffff800000102991:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000102995:	48 8b 40 20          	mov    rax,QWORD PTR [rax+0x20]
ffff800000102999:	48 01 45 f8          	add    QWORD PTR [rbp-0x8],rax
ffff80000010299d:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
ffff8000001029a0:	48 63 d0             	movsxd rdx,eax
ffff8000001029a3:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001029a7:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff8000001029ab:	48 39 c2             	cmp    rdx,rax
ffff8000001029ae:	0f 82 3f ff ff ff    	jb     ffff8000001028f3 <__pmm_pre+0x4f>
    }
    
    alloc = (void *)alloc_early;
ffff8000001029b4:	48 8d 05 79 f5 ff ff 	lea    rax,[rip+0xfffffffffffff579]        # ffff800000101f34 <alloc_early>
ffff8000001029bb:	48 89 05 96 f8 00 00 	mov    QWORD PTR [rip+0xf896],rax        # ffff800000112258 <alloc>
    alloc0 = (void *)alloc_early;
ffff8000001029c2:	48 8d 05 6b f5 ff ff 	lea    rax,[rip+0xfffffffffffff56b]        # ffff800000101f34 <alloc_early>
ffff8000001029c9:	48 89 05 90 f8 00 00 	mov    QWORD PTR [rip+0xf890],rax        # ffff800000112260 <alloc0>
    delete = (void *)delete_early;
ffff8000001029d0:	48 8d 05 7d f5 ff ff 	lea    rax,[rip+0xfffffffffffff57d]        # ffff800000101f54 <delete_early>
ffff8000001029d7:	48 89 05 8a f8 00 00 	mov    QWORD PTR [rip+0xf88a],rax        # ffff800000112268 <delete>
    delete0 = (void *)delete_early;
ffff8000001029de:	48 8d 05 6f f5 ff ff 	lea    rax,[rip+0xfffffffffffff56f]        # ffff800000101f54 <delete_early>
ffff8000001029e5:	48 89 05 84 f8 00 00 	mov    QWORD PTR [rip+0xf884],rax        # ffff800000112270 <delete0>

    for (kpgs_t *p = m->kpgs ; p->va ; p++)
ffff8000001029ec:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff8000001029f0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff8000001029f4:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
ffff8000001029f8:	eb 2d                	jmp    ffff800000102a27 <__pmm_pre+0x183>
        pmm_allochard (p->phy, (p->msiz + PAGE_SIZ - 1) / PAGE_SIZ);
ffff8000001029fa:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff8000001029fe:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff800000102a02:	48 05 ff 0f 00 00    	add    rax,0xfff
ffff800000102a08:	48 c1 e8 0c          	shr    rax,0xc
ffff800000102a0c:	48 89 c2             	mov    rdx,rax
ffff800000102a0f:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000102a13:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff800000102a17:	48 89 d6             	mov    rsi,rdx
ffff800000102a1a:	48 89 c7             	mov    rdi,rax
ffff800000102a1d:	e8 09 f7 ff ff       	call   ffff80000010212b <pmm_allochard>
    for (kpgs_t *p = m->kpgs ; p->va ; p++)
ffff800000102a22:	48 83 45 e0 20       	add    QWORD PTR [rbp-0x20],0x20
ffff800000102a27:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000102a2b:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000102a2e:	84 c0                	test   al,al
ffff800000102a30:	75 c8                	jne    ffff8000001029fa <__pmm_pre+0x156>
}
ffff800000102a32:	90                   	nop
ffff800000102a33:	90                   	nop
ffff800000102a34:	c9                   	leave
ffff800000102a35:	c3                   	ret

ffff800000102a36 <vmm_canadjust>:
/* Check if the Vrt is a canonical format
   vrt addr and adjust it if it is invalid

   @retval  int   The state */
int vmm_canadjust (u64 *vrt)
{
ffff800000102a36:	55                   	push   rbp
ffff800000102a37:	48 89 e5             	mov    rbp,rsp
ffff800000102a3a:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
    if ((*vrt >> 47) & 1) {
ffff800000102a3e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102a42:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff800000102a45:	48 ba 00 00 00 00 00 	movabs rdx,0x800000000000
ffff800000102a4c:	80 00 00 
ffff800000102a4f:	48 21 d0             	and    rax,rdx
ffff800000102a52:	48 85 c0             	test   rax,rax
ffff800000102a55:	74 3c                	je     ffff800000102a93 <vmm_canadjust+0x5d>
        if (*vrt >> 48 == 0xFFF)
ffff800000102a57:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102a5b:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff800000102a5e:	48 c1 e8 30          	shr    rax,0x30
ffff800000102a62:	48 3d ff 0f 00 00    	cmp    rax,0xfff
ffff800000102a68:	75 07                	jne    ffff800000102a71 <vmm_canadjust+0x3b>
            return true;
ffff800000102a6a:	b8 01 00 00 00       	mov    eax,0x1
ffff800000102a6f:	eb 27                	jmp    ffff800000102a98 <vmm_canadjust+0x62>

        *vrt |= 0xffff8ull << 44;
ffff800000102a71:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102a75:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff800000102a78:	48 ba 00 00 00 00 00 	movabs rdx,0xffff800000000000
ffff800000102a7f:	80 ff ff 
ffff800000102a82:	48 09 c2             	or     rdx,rax
ffff800000102a85:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102a89:	48 89 10             	mov    QWORD PTR [rax],rdx
        return false;
ffff800000102a8c:	b8 00 00 00 00       	mov    eax,0x0
ffff800000102a91:	eb 05                	jmp    ffff800000102a98 <vmm_canadjust+0x62>
    }

    return true;
ffff800000102a93:	b8 01 00 00 00       	mov    eax,0x1
}
ffff800000102a98:	5d                   	pop    rbp
ffff800000102a99:	c3                   	ret

ffff800000102a9a <vmm_phyauto>:

void *vmm_phyauto (u64 vrt, size_t num, u16 flgs)
{
ffff800000102a9a:	55                   	push   rbp
ffff800000102a9b:	48 89 e5             	mov    rbp,rsp
ffff800000102a9e:	48 83 ec 30          	sub    rsp,0x30
ffff800000102aa2:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
ffff800000102aa6:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
ffff800000102aaa:	89 d0                	mov    eax,edx
ffff800000102aac:	66 89 45 dc          	mov    WORD PTR [rbp-0x24],ax
    ASSERTK (!(vrt & 0xFFF) && vrt != 0); // 确保它不是 NULL 并且是一页开始的地方
ffff800000102ab0:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000102ab4:	25 ff 0f 00 00       	and    eax,0xfff
ffff800000102ab9:	48 85 c0             	test   rax,rax
ffff800000102abc:	75 10                	jne    ffff800000102ace <vmm_phyauto+0x34>
ffff800000102abe:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000102ac2:	48 85 c0             	test   rax,rax
ffff800000102ac5:	74 07                	je     ffff800000102ace <vmm_phyauto+0x34>
ffff800000102ac7:	b8 01 00 00 00       	mov    eax,0x1
ffff800000102acc:	eb 05                	jmp    ffff800000102ad3 <vmm_phyauto+0x39>
ffff800000102ace:	b8 00 00 00 00       	mov    eax,0x0
ffff800000102ad3:	0f b6 c0             	movzx  eax,al
ffff800000102ad6:	48 8d 15 bb 39 00 00 	lea    rdx,[rip+0x39bb]        # ffff800000106498 <lwstr+0x258>
ffff800000102add:	48 89 d1             	mov    rcx,rdx
ffff800000102ae0:	89 c2                	mov    edx,eax
ffff800000102ae2:	be 19 00 00 00       	mov    esi,0x19
ffff800000102ae7:	48 8d 05 c5 39 00 00 	lea    rax,[rip+0x39c5]        # ffff8000001064b3 <lwstr+0x273>
ffff800000102aee:	48 89 c7             	mov    rdi,rax
ffff800000102af1:	e8 a1 d6 ff ff       	call   ffff800000100197 <assertk>

    if (!vmm_canadjust (&vrt))
ffff800000102af6:	48 8d 45 e8          	lea    rax,[rbp-0x18]
ffff800000102afa:	48 89 c7             	mov    rdi,rax
ffff800000102afd:	e8 34 ff ff ff       	call   ffff800000102a36 <vmm_canadjust>
ffff800000102b02:	85 c0                	test   eax,eax
ffff800000102b04:	75 2a                	jne    ffff800000102b30 <vmm_phyauto+0x96>
        DEBUGK ("the addr is not a canonical addr, adjust it - %p\n",vrt);
ffff800000102b06:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000102b0a:	48 89 c1             	mov    rcx,rax
ffff800000102b0d:	48 8d 05 ac 39 00 00 	lea    rax,[rip+0x39ac]        # ffff8000001064c0 <lwstr+0x280>
ffff800000102b14:	48 89 c2             	mov    rdx,rax
ffff800000102b17:	be 1c 00 00 00       	mov    esi,0x1c
ffff800000102b1c:	48 8d 05 90 39 00 00 	lea    rax,[rip+0x3990]        # ffff8000001064b3 <lwstr+0x273>
ffff800000102b23:	48 89 c7             	mov    rdi,rax
ffff800000102b26:	b8 00 00 00 00       	mov    eax,0x0
ffff800000102b2b:	e8 92 d5 ff ff       	call   ffff8000001000c2 <debugk>

    void *page = pmm_allocpages (num);
ffff800000102b30:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000102b34:	48 89 c7             	mov    rdi,rax
ffff800000102b37:	e8 77 f4 ff ff       	call   ffff800000101fb3 <pmm_allocpages>
ffff800000102b3c:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

    vmap_map ((u64)page, vrt, num, flgs, MAP_4K);
ffff800000102b40:	0f b7 4d dc          	movzx  ecx,WORD PTR [rbp-0x24]
ffff800000102b44:	48 8b 75 e8          	mov    rsi,QWORD PTR [rbp-0x18]
ffff800000102b48:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102b4c:	48 8b 55 e0          	mov    rdx,QWORD PTR [rbp-0x20]
ffff800000102b50:	41 b8 01 00 00 00    	mov    r8d,0x1
ffff800000102b56:	48 89 c7             	mov    rdi,rax
ffff800000102b59:	e8 45 03 00 00       	call   ffff800000102ea3 <vmap_map>

    return (void *)vrt;
ffff800000102b5e:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
}
ffff800000102b62:	c9                   	leave
ffff800000102b63:	c3                   	ret

ffff800000102b64 <vmm_allocpages>:

static u64 _idx;

/* TODO: complete it */
void *vmm_allocpages (size_t num, u16 flgs)
{
ffff800000102b64:	55                   	push   rbp
ffff800000102b65:	48 89 e5             	mov    rbp,rsp
ffff800000102b68:	48 83 ec 20          	sub    rsp,0x20
ffff800000102b6c:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
ffff800000102b70:	89 f0                	mov    eax,esi
ffff800000102b72:	66 89 45 e4          	mov    WORD PTR [rbp-0x1c],ax
    void *page = (void *)__kern_vmm_pages + PAGE_SIZ * _idx;
ffff800000102b76:	48 8b 05 fb f6 00 00 	mov    rax,QWORD PTR [rip+0xf6fb]        # ffff800000112278 <_idx>
ffff800000102b7d:	48 c1 e0 0c          	shl    rax,0xc
ffff800000102b81:	48 89 c2             	mov    rdx,rax
ffff800000102b84:	48 b8 00 00 00 00 00 	movabs rax,0xffff900000000000
ffff800000102b8b:	90 ff ff 
ffff800000102b8e:	48 01 d0             	add    rax,rdx
ffff800000102b91:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

    _idx += num;
ffff800000102b95:	48 8b 15 dc f6 00 00 	mov    rdx,QWORD PTR [rip+0xf6dc]        # ffff800000112278 <_idx>
ffff800000102b9c:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000102ba0:	48 01 d0             	add    rax,rdx
ffff800000102ba3:	48 89 05 ce f6 00 00 	mov    QWORD PTR [rip+0xf6ce],rax        # ffff800000112278 <_idx>

    vmm_phyauto ((u64)page, num, flgs);
ffff800000102baa:	0f b7 55 e4          	movzx  edx,WORD PTR [rbp-0x1c]
ffff800000102bae:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102bb2:	48 8b 4d e8          	mov    rcx,QWORD PTR [rbp-0x18]
ffff800000102bb6:	48 89 ce             	mov    rsi,rcx
ffff800000102bb9:	48 89 c7             	mov    rdi,rax
ffff800000102bbc:	e8 d9 fe ff ff       	call   ffff800000102a9a <vmm_phyauto>

    return page;
ffff800000102bc1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
}
ffff800000102bc5:	c9                   	leave
ffff800000102bc6:	c3                   	ret

ffff800000102bc7 <_vrt_entryget>:
#include <textos/panic.h>

/* Get vrt addr of pgt by addr & level */
static inline u64*
_vrt_entryget (u64 addr, int level)
{
ffff800000102bc7:	55                   	push   rbp
ffff800000102bc8:	48 89 e5             	mov    rbp,rsp
ffff800000102bcb:	48 83 ec 10          	sub    rsp,0x10
ffff800000102bcf:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
ffff800000102bd3:	89 75 f4             	mov    DWORD PTR [rbp-0xc],esi
    if (level == L_PML4)
ffff800000102bd6:	83 7d f4 04          	cmp    DWORD PTR [rbp-0xc],0x4
ffff800000102bda:	75 0c                	jne    ffff800000102be8 <_vrt_entryget+0x21>
        return (u64 *)VRT(R_IDX, R_IDX, R_IDX, R_IDX);
ffff800000102bdc:	48 c7 c0 00 f0 ff ff 	mov    rax,0xfffffffffffff000
ffff800000102be3:	e9 e9 00 00 00       	jmp    ffff800000102cd1 <_vrt_entryget+0x10a>
    else if (level == L_PDPT)
ffff800000102be8:	83 7d f4 03          	cmp    DWORD PTR [rbp-0xc],0x3
ffff800000102bec:	75 1c                	jne    ffff800000102c0a <_vrt_entryget+0x43>
        return (u64 *)VRT(R_IDX, R_IDX, R_IDX, PML4E_IDX(addr));
ffff800000102bee:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102bf2:	48 c1 e8 27          	shr    rax,0x27
ffff800000102bf6:	48 c1 e0 0c          	shl    rax,0xc
ffff800000102bfa:	25 00 f0 1f 00       	and    eax,0x1ff000
ffff800000102bff:	48 0d 00 00 e0 ff    	or     rax,0xffffffffffe00000
ffff800000102c05:	e9 c7 00 00 00       	jmp    ffff800000102cd1 <_vrt_entryget+0x10a>
    else if (level == L_PD)
ffff800000102c0a:	83 7d f4 02          	cmp    DWORD PTR [rbp-0xc],0x2
ffff800000102c0e:	75 33                	jne    ffff800000102c43 <_vrt_entryget+0x7c>
        return (u64 *)VRT(R_IDX, R_IDX, PML4E_IDX(addr), PDPTE_IDX(addr));
ffff800000102c10:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102c14:	48 c1 e8 27          	shr    rax,0x27
ffff800000102c18:	48 c1 e0 15          	shl    rax,0x15
ffff800000102c1c:	25 00 00 e0 3f       	and    eax,0x3fe00000
ffff800000102c21:	48 89 c2             	mov    rdx,rax
ffff800000102c24:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102c28:	48 c1 e8 1e          	shr    rax,0x1e
ffff800000102c2c:	48 c1 e0 0c          	shl    rax,0xc
ffff800000102c30:	25 00 f0 1f 00       	and    eax,0x1ff000
ffff800000102c35:	48 09 d0             	or     rax,rdx
ffff800000102c38:	48 0d 00 00 00 c0    	or     rax,0xffffffffc0000000
ffff800000102c3e:	e9 8e 00 00 00       	jmp    ffff800000102cd1 <_vrt_entryget+0x10a>
    else if (level == L_PT)
ffff800000102c43:	83 7d f4 01          	cmp    DWORD PTR [rbp-0xc],0x1
ffff800000102c47:	75 53                	jne    ffff800000102c9c <_vrt_entryget+0xd5>
        return (u64 *)VRT(R_IDX, PML4E_IDX(addr), PDPTE_IDX(addr), PDE_IDX(addr));
ffff800000102c49:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102c4d:	48 c1 e8 27          	shr    rax,0x27
ffff800000102c51:	48 c1 e0 1e          	shl    rax,0x1e
ffff800000102c55:	48 89 c2             	mov    rdx,rax
ffff800000102c58:	48 b8 00 00 00 c0 7f 	movabs rax,0x7fc0000000
ffff800000102c5f:	00 00 00 
ffff800000102c62:	48 21 c2             	and    rdx,rax
ffff800000102c65:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102c69:	48 c1 e8 1e          	shr    rax,0x1e
ffff800000102c6d:	48 c1 e0 15          	shl    rax,0x15
ffff800000102c71:	25 00 00 e0 3f       	and    eax,0x3fe00000
ffff800000102c76:	48 09 c2             	or     rdx,rax
ffff800000102c79:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102c7d:	48 c1 e8 15          	shr    rax,0x15
ffff800000102c81:	48 c1 e0 0c          	shl    rax,0xc
ffff800000102c85:	25 00 f0 1f 00       	and    eax,0x1ff000
ffff800000102c8a:	48 09 c2             	or     rdx,rax
ffff800000102c8d:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
ffff800000102c94:	ff ff ff 
ffff800000102c97:	48 09 d0             	or     rax,rdx
ffff800000102c9a:	eb 35                	jmp    ffff800000102cd1 <_vrt_entryget+0x10a>

    PANIC ("Unable to get the vrt addr of the pgt by addr & level - %p, %d\n", addr, level);
ffff800000102c9c:	8b 55 f4             	mov    edx,DWORD PTR [rbp-0xc]
ffff800000102c9f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102ca3:	41 89 d0             	mov    r8d,edx
ffff800000102ca6:	48 89 c1             	mov    rcx,rax
ffff800000102ca9:	48 8d 05 48 38 00 00 	lea    rax,[rip+0x3848]        # ffff8000001064f8 <lwstr+0x2b8>
ffff800000102cb0:	48 89 c2             	mov    rdx,rax
ffff800000102cb3:	be 3b 00 00 00       	mov    esi,0x3b
ffff800000102cb8:	48 8d 05 79 38 00 00 	lea    rax,[rip+0x3879]        # ffff800000106538 <lwstr+0x2f8>
ffff800000102cbf:	48 89 c7             	mov    rdi,rax
ffff800000102cc2:	b8 00 00 00 00       	mov    eax,0x0
ffff800000102cc7:	e8 1c d5 ff ff       	call   ffff8000001001e8 <panic>

    return NULL;
ffff800000102ccc:	b8 00 00 00 00       	mov    eax,0x0
}
ffff800000102cd1:	c9                   	leave
ffff800000102cd2:	c3                   	ret

ffff800000102cd3 <_map_walk>:

static void
_map_walk (u64 phy, u64 vrt, u16 flgs, u64 *tab, int level, int mode)
{
ffff800000102cd3:	55                   	push   rbp
ffff800000102cd4:	48 89 e5             	mov    rbp,rsp
ffff800000102cd7:	48 83 ec 40          	sub    rsp,0x40
ffff800000102cdb:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
ffff800000102cdf:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
ffff800000102ce3:	89 d0                	mov    eax,edx
ffff800000102ce5:	48 89 4d d0          	mov    QWORD PTR [rbp-0x30],rcx
ffff800000102ce9:	44 89 45 d8          	mov    DWORD PTR [rbp-0x28],r8d
ffff800000102ced:	44 89 4d cc          	mov    DWORD PTR [rbp-0x34],r9d
ffff800000102cf1:	66 89 45 dc          	mov    WORD PTR [rbp-0x24],ax
    u64 idx = IDX(vrt, level);
ffff800000102cf5:	8b 45 d8             	mov    eax,DWORD PTR [rbp-0x28]
ffff800000102cf8:	8d 50 ff             	lea    edx,[rax-0x1]
ffff800000102cfb:	89 d0                	mov    eax,edx
ffff800000102cfd:	c1 e0 03             	shl    eax,0x3
ffff800000102d00:	01 d0                	add    eax,edx
ffff800000102d02:	83 c0 0c             	add    eax,0xc
ffff800000102d05:	48 8b 55 e0          	mov    rdx,QWORD PTR [rbp-0x20]
ffff800000102d09:	89 c1                	mov    ecx,eax
ffff800000102d0b:	48 d3 ea             	shr    rdx,cl
ffff800000102d0e:	48 89 d0             	mov    rax,rdx
ffff800000102d11:	25 ff 01 00 00       	and    eax,0x1ff
ffff800000102d16:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

    if (level == mode) {
ffff800000102d1a:	8b 45 d8             	mov    eax,DWORD PTR [rbp-0x28]
ffff800000102d1d:	3b 45 cc             	cmp    eax,DWORD PTR [rbp-0x34]
ffff800000102d20:	75 37                	jne    ffff800000102d59 <_map_walk+0x86>
        tab[idx] = PE_S_ADDR(phy) | PE_S_FLAGS(flgs);
ffff800000102d22:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000102d26:	48 25 00 f8 ff ff    	and    rax,0xfffffffffffff800
ffff800000102d2c:	48 89 c1             	mov    rcx,rax
ffff800000102d2f:	0f b7 45 dc          	movzx  eax,WORD PTR [rbp-0x24]
ffff800000102d33:	25 ff 07 00 00       	and    eax,0x7ff
ffff800000102d38:	48 89 c2             	mov    rdx,rax
ffff800000102d3b:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102d3f:	48 8d 34 c5 00 00 00 	lea    rsi,[rax*8+0x0]
ffff800000102d46:	00 
ffff800000102d47:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff800000102d4b:	48 01 f0             	add    rax,rsi
ffff800000102d4e:	48 09 ca             	or     rdx,rcx
ffff800000102d51:	48 89 10             	mov    QWORD PTR [rax],rdx
        return;
ffff800000102d54:	e9 f8 00 00 00       	jmp    ffff800000102e51 <_map_walk+0x17e>
    }
    else if (!(tab[idx] & PE_P))
ffff800000102d59:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102d5d:	48 8d 14 c5 00 00 00 	lea    rdx,[rax*8+0x0]
ffff800000102d64:	00 
ffff800000102d65:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff800000102d69:	48 01 d0             	add    rax,rdx
ffff800000102d6c:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff800000102d6f:	83 e0 01             	and    eax,0x1
ffff800000102d72:	48 85 c0             	test   rax,rax
ffff800000102d75:	0f 85 95 00 00 00    	jne    ffff800000102e10 <_map_walk+0x13d>
    {
        void *new = pmm_allocpages(1);
ffff800000102d7b:	bf 01 00 00 00       	mov    edi,0x1
ffff800000102d80:	e8 2e f2 ff ff       	call   ffff800000101fb3 <pmm_allocpages>
ffff800000102d85:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
        ASSERTK (new != NULL);
ffff800000102d89:	48 83 7d f0 00       	cmp    QWORD PTR [rbp-0x10],0x0
ffff800000102d8e:	0f 95 c0             	setne  al
ffff800000102d91:	0f b6 c0             	movzx  eax,al
ffff800000102d94:	48 8d 15 a6 37 00 00 	lea    rdx,[rip+0x37a6]        # ffff800000106541 <lwstr+0x301>
ffff800000102d9b:	48 89 d1             	mov    rcx,rdx
ffff800000102d9e:	89 c2                	mov    edx,eax
ffff800000102da0:	be 4c 00 00 00       	mov    esi,0x4c
ffff800000102da5:	48 8d 05 8c 37 00 00 	lea    rax,[rip+0x378c]        # ffff800000106538 <lwstr+0x2f8>
ffff800000102dac:	48 89 c7             	mov    rdi,rax
ffff800000102daf:	e8 e3 d3 ff ff       	call   ffff800000100197 <assertk>

        tab[idx] = PE_S_ADDR(new) | PE_RW | PE_P;
ffff800000102db4:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000102db8:	48 25 00 f8 ff ff    	and    rax,0xfffffffffffff800
ffff800000102dbe:	48 89 c2             	mov    rdx,rax
ffff800000102dc1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000102dc5:	48 8d 0c c5 00 00 00 	lea    rcx,[rax*8+0x0]
ffff800000102dcc:	00 
ffff800000102dcd:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff800000102dd1:	48 01 c8             	add    rax,rcx
ffff800000102dd4:	48 83 ca 03          	or     rdx,0x3
ffff800000102dd8:	48 89 10             	mov    QWORD PTR [rax],rdx
        __asm__ volatile ("invlpg (%0)" : : "r"(tab) : "memory");
ffff800000102ddb:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff800000102ddf:	0f 01 38             	invlpg BYTE PTR [rax]
        new = _vrt_entryget (vrt, level - 1);
ffff800000102de2:	8b 45 d8             	mov    eax,DWORD PTR [rbp-0x28]
ffff800000102de5:	8d 50 ff             	lea    edx,[rax-0x1]
ffff800000102de8:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000102dec:	89 d6                	mov    esi,edx
ffff800000102dee:	48 89 c7             	mov    rdi,rax
ffff800000102df1:	e8 d1 fd ff ff       	call   ffff800000102bc7 <_vrt_entryget>
ffff800000102df6:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
        memset (new, 0, PAGE_SIZ);
ffff800000102dfa:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000102dfe:	ba 00 10 00 00       	mov    edx,0x1000
ffff800000102e03:	be 00 00 00 00       	mov    esi,0x0
ffff800000102e08:	48 89 c7             	mov    rdi,rax
ffff800000102e0b:	e8 f0 e6 ff ff       	call   ffff800000101500 <memset>
    }

    tab = (u64 *)_vrt_entryget (vrt, level - 1);
ffff800000102e10:	8b 45 d8             	mov    eax,DWORD PTR [rbp-0x28]
ffff800000102e13:	8d 50 ff             	lea    edx,[rax-0x1]
ffff800000102e16:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000102e1a:	89 d6                	mov    esi,edx
ffff800000102e1c:	48 89 c7             	mov    rdi,rax
ffff800000102e1f:	e8 a3 fd ff ff       	call   ffff800000102bc7 <_vrt_entryget>
ffff800000102e24:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
    _map_walk (phy, vrt, flgs, tab, --level, mode);
ffff800000102e28:	83 6d d8 01          	sub    DWORD PTR [rbp-0x28],0x1
ffff800000102e2c:	0f b7 55 dc          	movzx  edx,WORD PTR [rbp-0x24]
ffff800000102e30:	44 8b 45 cc          	mov    r8d,DWORD PTR [rbp-0x34]
ffff800000102e34:	8b 7d d8             	mov    edi,DWORD PTR [rbp-0x28]
ffff800000102e37:	48 8b 4d d0          	mov    rcx,QWORD PTR [rbp-0x30]
ffff800000102e3b:	48 8b 75 e0          	mov    rsi,QWORD PTR [rbp-0x20]
ffff800000102e3f:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000102e43:	45 89 c1             	mov    r9d,r8d
ffff800000102e46:	41 89 f8             	mov    r8d,edi
ffff800000102e49:	48 89 c7             	mov    rdi,rax
ffff800000102e4c:	e8 82 fe ff ff       	call   ffff800000102cd3 <_map_walk>
}
ffff800000102e51:	c9                   	leave
ffff800000102e52:	c3                   	ret

ffff800000102e53 <parse_flags>:

static inline u16
parse_flags (int md)
{
ffff800000102e53:	55                   	push   rbp
ffff800000102e54:	48 89 e5             	mov    rbp,rsp
ffff800000102e57:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
    if (md == MAP_2M)
ffff800000102e5a:	83 7d fc 02          	cmp    DWORD PTR [rbp-0x4],0x2
ffff800000102e5e:	75 07                	jne    ffff800000102e67 <parse_flags+0x14>
        return PDE_2M;
ffff800000102e60:	b8 80 00 00 00       	mov    eax,0x80
ffff800000102e65:	eb 12                	jmp    ffff800000102e79 <parse_flags+0x26>
    else if (md == MAP_1G)
ffff800000102e67:	83 7d fc 03          	cmp    DWORD PTR [rbp-0x4],0x3
ffff800000102e6b:	75 07                	jne    ffff800000102e74 <parse_flags+0x21>
        return PDPTE_1G;
ffff800000102e6d:	b8 80 00 00 00       	mov    eax,0x80
ffff800000102e72:	eb 05                	jmp    ffff800000102e79 <parse_flags+0x26>

    return 0;
ffff800000102e74:	b8 00 00 00 00       	mov    eax,0x0
}
ffff800000102e79:	5d                   	pop    rbp
ffff800000102e7a:	c3                   	ret

ffff800000102e7b <_pagesiz>:

static inline u32
_pagesiz (int md)
{
ffff800000102e7b:	55                   	push   rbp
ffff800000102e7c:	48 89 e5             	mov    rbp,rsp
ffff800000102e7f:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
    if (md == MAP_2M)
ffff800000102e82:	83 7d fc 02          	cmp    DWORD PTR [rbp-0x4],0x2
ffff800000102e86:	75 07                	jne    ffff800000102e8f <_pagesiz+0x14>
        return SIZE_2MB;
ffff800000102e88:	b8 00 00 20 00       	mov    eax,0x200000
ffff800000102e8d:	eb 12                	jmp    ffff800000102ea1 <_pagesiz+0x26>
    else if (md == MAP_1G)
ffff800000102e8f:	83 7d fc 03          	cmp    DWORD PTR [rbp-0x4],0x3
ffff800000102e93:	75 07                	jne    ffff800000102e9c <_pagesiz+0x21>
        return SIZE_1GB;
ffff800000102e95:	b8 00 00 00 40       	mov    eax,0x40000000
ffff800000102e9a:	eb 05                	jmp    ffff800000102ea1 <_pagesiz+0x26>

    return SIZE_4KB;
ffff800000102e9c:	b8 00 10 00 00       	mov    eax,0x1000
}
ffff800000102ea1:	5d                   	pop    rbp
ffff800000102ea2:	c3                   	ret

ffff800000102ea3 <vmap_map>:

void vmap_map (u64 phy, u64 vrt, size_t num, u16 flgs, int mode)
{
ffff800000102ea3:	55                   	push   rbp
ffff800000102ea4:	48 89 e5             	mov    rbp,rsp
ffff800000102ea7:	53                   	push   rbx
ffff800000102ea8:	48 83 ec 38          	sub    rsp,0x38
ffff800000102eac:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
ffff800000102eb0:	48 89 75 d0          	mov    QWORD PTR [rbp-0x30],rsi
ffff800000102eb4:	48 89 55 c8          	mov    QWORD PTR [rbp-0x38],rdx
ffff800000102eb8:	89 c8                	mov    eax,ecx
ffff800000102eba:	44 89 45 c0          	mov    DWORD PTR [rbp-0x40],r8d
ffff800000102ebe:	66 89 45 c4          	mov    WORD PTR [rbp-0x3c],ax
    DEBUGK ("Try to map %p -> %p - %llu,%x,%d\n", phy, vrt, num, flgs, mode);
ffff800000102ec2:	0f b7 55 c4          	movzx  edx,WORD PTR [rbp-0x3c]
ffff800000102ec6:	48 8b 7d c8          	mov    rdi,QWORD PTR [rbp-0x38]
ffff800000102eca:	48 8b 75 d0          	mov    rsi,QWORD PTR [rbp-0x30]
ffff800000102ece:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000102ed2:	8b 4d c0             	mov    ecx,DWORD PTR [rbp-0x40]
ffff800000102ed5:	51                   	push   rcx
ffff800000102ed6:	52                   	push   rdx
ffff800000102ed7:	49 89 f9             	mov    r9,rdi
ffff800000102eda:	49 89 f0             	mov    r8,rsi
ffff800000102edd:	48 89 c1             	mov    rcx,rax
ffff800000102ee0:	48 8d 05 69 36 00 00 	lea    rax,[rip+0x3669]        # ffff800000106550 <lwstr+0x310>
ffff800000102ee7:	48 89 c2             	mov    rdx,rax
ffff800000102eea:	be 70 00 00 00       	mov    esi,0x70
ffff800000102eef:	48 8d 05 42 36 00 00 	lea    rax,[rip+0x3642]        # ffff800000106538 <lwstr+0x2f8>
ffff800000102ef6:	48 89 c7             	mov    rdi,rax
ffff800000102ef9:	b8 00 00 00 00       	mov    eax,0x0
ffff800000102efe:	e8 bf d1 ff ff       	call   ffff8000001000c2 <debugk>
ffff800000102f03:	48 83 c4 10          	add    rsp,0x10

    u64 pagesiz = _pagesiz (mode);
ffff800000102f07:	8b 45 c0             	mov    eax,DWORD PTR [rbp-0x40]
ffff800000102f0a:	89 c7                	mov    edi,eax
ffff800000102f0c:	e8 6a ff ff ff       	call   ffff800000102e7b <_pagesiz>
ffff800000102f11:	89 c0                	mov    eax,eax
ffff800000102f13:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
    while (num--) {
ffff800000102f17:	eb 47                	jmp    ffff800000102f60 <vmap_map+0xbd>
        _map_walk (phy, vrt, flgs | parse_flags (mode), pml4, L_PML4, mode);
ffff800000102f19:	48 8b 1d 60 f3 00 00 	mov    rbx,QWORD PTR [rip+0xf360]        # ffff800000112280 <pml4>
ffff800000102f20:	8b 45 c0             	mov    eax,DWORD PTR [rbp-0x40]
ffff800000102f23:	89 c7                	mov    edi,eax
ffff800000102f25:	e8 29 ff ff ff       	call   ffff800000102e53 <parse_flags>
ffff800000102f2a:	66 0b 45 c4          	or     ax,WORD PTR [rbp-0x3c]
ffff800000102f2e:	0f b7 d0             	movzx  edx,ax
ffff800000102f31:	8b 4d c0             	mov    ecx,DWORD PTR [rbp-0x40]
ffff800000102f34:	48 8b 75 d0          	mov    rsi,QWORD PTR [rbp-0x30]
ffff800000102f38:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000102f3c:	41 89 c9             	mov    r9d,ecx
ffff800000102f3f:	41 b8 04 00 00 00    	mov    r8d,0x4
ffff800000102f45:	48 89 d9             	mov    rcx,rbx
ffff800000102f48:	48 89 c7             	mov    rdi,rax
ffff800000102f4b:	e8 83 fd ff ff       	call   ffff800000102cd3 <_map_walk>
        phy += pagesiz;
ffff800000102f50:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000102f54:	48 01 45 d8          	add    QWORD PTR [rbp-0x28],rax
        vrt += pagesiz;
ffff800000102f58:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000102f5c:	48 01 45 d0          	add    QWORD PTR [rbp-0x30],rax
    while (num--) {
ffff800000102f60:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff800000102f64:	48 8d 50 ff          	lea    rdx,[rax-0x1]
ffff800000102f68:	48 89 55 c8          	mov    QWORD PTR [rbp-0x38],rdx
ffff800000102f6c:	48 85 c0             	test   rax,rax
ffff800000102f6f:	75 a8                	jne    ffff800000102f19 <vmap_map+0x76>
    }

    __asm__ volatile ("invlpg (%0)" : : "r"(vrt) : "memory");
ffff800000102f71:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff800000102f75:	0f 01 38             	invlpg BYTE PTR [rax]
}
ffff800000102f78:	90                   	nop
ffff800000102f79:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
ffff800000102f7d:	c9                   	leave
ffff800000102f7e:	c3                   	ret

ffff800000102f7f <vmap_init>:

void vmap_init ()
{
ffff800000102f7f:	55                   	push   rbp
ffff800000102f80:	48 89 e5             	mov    rbp,rsp
    pml4 = (u64 *)read_cr3();
ffff800000102f83:	b8 00 00 00 00       	mov    eax,0x0
ffff800000102f88:	e8 03 0e 00 00       	call   ffff800000103d90 <read_cr3>
ffff800000102f8d:	48 89 05 ec f2 00 00 	mov    QWORD PTR [rip+0xf2ec],rax        # ffff800000112280 <pml4>
    pml4[R_IDX] = PE_S_ADDR((u64)pml4) | PE_RW | PE_P;
ffff800000102f94:	48 8b 05 e5 f2 00 00 	mov    rax,QWORD PTR [rip+0xf2e5]        # ffff800000112280 <pml4>
ffff800000102f9b:	48 25 00 f8 ff ff    	and    rax,0xfffffffffffff800
ffff800000102fa1:	48 89 c2             	mov    rdx,rax
ffff800000102fa4:	48 8b 05 d5 f2 00 00 	mov    rax,QWORD PTR [rip+0xf2d5]        # ffff800000112280 <pml4>
ffff800000102fab:	48 05 f8 0f 00 00    	add    rax,0xff8
ffff800000102fb1:	48 83 ca 03          	or     rdx,0x3
ffff800000102fb5:	48 89 10             	mov    QWORD PTR [rax],rdx

    // set pgt into vrt mode
    pml4 = _vrt_entryget (0, L_PML4);
ffff800000102fb8:	be 04 00 00 00       	mov    esi,0x4
ffff800000102fbd:	bf 00 00 00 00       	mov    edi,0x0
ffff800000102fc2:	e8 00 fc ff ff       	call   ffff800000102bc7 <_vrt_entryget>
ffff800000102fc7:	48 89 05 b2 f2 00 00 	mov    QWORD PTR [rip+0xf2b2],rax        # ffff800000112280 <pml4>
}
ffff800000102fce:	90                   	nop
ffff800000102fcf:	5d                   	pop    rbp
ffff800000102fd0:	c3                   	ret

ffff800000102fd1 <vmap_initvm>:
extern void __pmm_tovmm();
extern void __apic_tovmm();
extern void __video_tovmm();

void vmap_initvm ()
{
ffff800000102fd1:	55                   	push   rbp
ffff800000102fd2:	48 89 e5             	mov    rbp,rsp
ffff800000102fd5:	48 83 ec 10          	sub    rsp,0x10
    vmap_map(0, __kern_phy_offet, __kern_phy_mapsz / _pagesiz(MAP_1G), PE_P | PE_RW, MAP_1G);
ffff800000102fd9:	bf 03 00 00 00       	mov    edi,0x3
ffff800000102fde:	e8 98 fe ff ff       	call   ffff800000102e7b <_pagesiz>
ffff800000102fe3:	89 c6                	mov    esi,eax
ffff800000102fe5:	48 b8 00 00 00 00 00 	movabs rax,0x10000000000
ffff800000102fec:	01 00 00 
ffff800000102fef:	ba 00 00 00 00       	mov    edx,0x0
ffff800000102ff4:	48 f7 f6             	div    rsi
ffff800000102ff7:	41 b8 03 00 00 00    	mov    r8d,0x3
ffff800000102ffd:	b9 03 00 00 00       	mov    ecx,0x3
ffff800000103002:	48 89 c2             	mov    rdx,rax
ffff800000103005:	48 b8 00 00 00 00 00 	movabs rax,0xffff830000000000
ffff80000010300c:	83 ff ff 
ffff80000010300f:	48 89 c6             	mov    rsi,rax
ffff800000103012:	bf 00 00 00 00       	mov    edi,0x0
ffff800000103017:	e8 87 fe ff ff       	call   ffff800000102ea3 <vmap_map>

    // As callback functions
    __pmm_tovmm();
ffff80000010301c:	b8 00 00 00 00       	mov    eax,0x0
ffff800000103021:	e8 ce f6 ff ff       	call   ffff8000001026f4 <__pmm_tovmm>
    __apic_tovmm();
ffff800000103026:	b8 00 00 00 00       	mov    eax,0x0
ffff80000010302b:	e8 67 d6 ff ff       	call   ffff800000100697 <__apic_tovmm>
    __video_tovmm();
ffff800000103030:	b8 00 00 00 00       	mov    eax,0x0
ffff800000103035:	e8 a1 07 00 00       	call   ffff8000001037db <__video_tovmm>
    
    for (int i = 0; i < 256 ;i++)
ffff80000010303a:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
ffff800000103041:	eb 36                	jmp    ffff800000103079 <vmap_initvm+0xa8>
        pml4[i] &= ~PE_P;
ffff800000103043:	48 8b 05 36 f2 00 00 	mov    rax,QWORD PTR [rip+0xf236]        # ffff800000112280 <pml4>
ffff80000010304a:	8b 55 fc             	mov    edx,DWORD PTR [rbp-0x4]
ffff80000010304d:	48 63 d2             	movsxd rdx,edx
ffff800000103050:	48 c1 e2 03          	shl    rdx,0x3
ffff800000103054:	48 01 d0             	add    rax,rdx
ffff800000103057:	48 8b 10             	mov    rdx,QWORD PTR [rax]
ffff80000010305a:	48 8b 05 1f f2 00 00 	mov    rax,QWORD PTR [rip+0xf21f]        # ffff800000112280 <pml4>
ffff800000103061:	8b 4d fc             	mov    ecx,DWORD PTR [rbp-0x4]
ffff800000103064:	48 63 c9             	movsxd rcx,ecx
ffff800000103067:	48 c1 e1 03          	shl    rcx,0x3
ffff80000010306b:	48 01 c8             	add    rax,rcx
ffff80000010306e:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
ffff800000103072:	48 89 10             	mov    QWORD PTR [rax],rdx
    for (int i = 0; i < 256 ;i++)
ffff800000103075:	83 45 fc 01          	add    DWORD PTR [rbp-0x4],0x1
ffff800000103079:	81 7d fc ff 00 00 00 	cmp    DWORD PTR [rbp-0x4],0xff
ffff800000103080:	7e c1                	jle    ffff800000103043 <vmap_initvm+0x72>
}
ffff800000103082:	90                   	nop
ffff800000103083:	90                   	nop
ffff800000103084:	c9                   	leave
ffff800000103085:	c3                   	ret

ffff800000103086 <heap_init>:

static void _merge (block_t *hdr);
static void _extend_heap (size_t siz);

void heap_init ()
{
ffff800000103086:	55                   	push   rbp
ffff800000103087:	48 89 e5             	mov    rbp,rsp
ffff80000010308a:	48 83 ec 10          	sub    rsp,0x10
    block_t *hp = pmm_allocpages (HEAP_ORIG); // 分配初始页,总不可能让指针们踩空吧......
ffff80000010308e:	bf 01 00 00 00       	mov    edi,0x1
ffff800000103093:	e8 1b ef ff ff       	call   ffff800000101fb3 <pmm_allocpages>
ffff800000103098:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

    PUT (hp + 0, SET(0, 0));    // Padding
ffff80000010309c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001030a0:	c7 00 00 00 00 00    	mov    DWORD PTR [rax],0x0
    PUT (hp + 1, SET(8, true)); // 设置序言块
ffff8000001030a6:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001030aa:	48 83 c0 04          	add    rax,0x4
ffff8000001030ae:	c7 00 41 00 00 00    	mov    DWORD PTR [rax],0x41
    PUT (hp + 2, SET(8, true));
ffff8000001030b4:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001030b8:	48 83 c0 08          	add    rax,0x8
ffff8000001030bc:	c7 00 41 00 00 00    	mov    DWORD PTR [rax],0x41
    PUT (hp + 3, SET(0, true)); // 设置结尾块 has only header
ffff8000001030c2:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001030c6:	48 83 c0 0c          	add    rax,0xc
ffff8000001030ca:	c7 00 01 00 00 00    	mov    DWORD PTR [rax],0x1

    vmap_map ((u64)hp, __kern_heap_base, HEAP_ORIG, PE_RW | PE_P, MAP_4K); // 映射至内核堆处
ffff8000001030d0:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001030d4:	41 b8 01 00 00 00    	mov    r8d,0x1
ffff8000001030da:	b9 03 00 00 00       	mov    ecx,0x3
ffff8000001030df:	ba 01 00 00 00       	mov    edx,0x1
ffff8000001030e4:	48 be 00 00 00 00 00 	movabs rsi,0xffff810000000000
ffff8000001030eb:	81 ff ff 
ffff8000001030ee:	48 89 c7             	mov    rdi,rax
ffff8000001030f1:	e8 ad fd ff ff       	call   ffff800000102ea3 <vmap_map>

    _heap.root = (block_t *)__kern_heap_base + 3;
ffff8000001030f6:	48 b8 0c 00 00 00 00 	movabs rax,0xffff81000000000c
ffff8000001030fd:	81 ff ff 
ffff800000103100:	48 89 05 91 f1 00 00 	mov    QWORD PTR [rip+0xf191],rax        # ffff800000112298 <_heap+0x8>
    _heap.brk = (block_t *)_heap.root;
ffff800000103107:	48 8b 05 8a f1 00 00 	mov    rax,QWORD PTR [rip+0xf18a]        # ffff800000112298 <_heap+0x8>
ffff80000010310e:	48 89 05 7b f1 00 00 	mov    QWORD PTR [rip+0xf17b],rax        # ffff800000112290 <_heap>
    _heap.max = (void *)__kern_heap_base + HEAP_ORIG * PAGE_SIZ;
ffff800000103115:	48 b8 00 10 00 00 00 	movabs rax,0xffff810000001000
ffff80000010311c:	81 ff ff 
ffff80000010311f:	48 89 05 7a f1 00 00 	mov    QWORD PTR [rip+0xf17a],rax        # ffff8000001122a0 <_heap+0x10>
}
ffff800000103126:	90                   	nop
ffff800000103127:	c9                   	leave
ffff800000103128:	c3                   	ret

ffff800000103129 <sbrk>:

void *sbrk (int64 siz)
{
ffff800000103129:	55                   	push   rbp
ffff80000010312a:	48 89 e5             	mov    rbp,rsp
ffff80000010312d:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
    _heap.brk += _ALIGN (siz, 8);
ffff800000103131:	48 8b 05 58 f1 00 00 	mov    rax,QWORD PTR [rip+0xf158]        # ffff800000112290 <_heap>
ffff800000103138:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
ffff80000010313c:	48 83 c2 07          	add    rdx,0x7
ffff800000103140:	48 83 e2 f8          	and    rdx,0xfffffffffffffff8
ffff800000103144:	48 01 d0             	add    rax,rdx
ffff800000103147:	48 89 05 42 f1 00 00 	mov    QWORD PTR [rip+0xf142],rax        # ffff800000112290 <_heap>

    return (_heap.brk - siz);
ffff80000010314e:	48 8b 05 3b f1 00 00 	mov    rax,QWORD PTR [rip+0xf13b]        # ffff800000112290 <_heap>
ffff800000103155:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
ffff800000103159:	48 f7 da             	neg    rdx
ffff80000010315c:	48 01 d0             	add    rax,rdx
}
ffff80000010315f:	5d                   	pop    rbp
ffff800000103160:	c3                   	ret

ffff800000103161 <malloc>:

#include <textos/assert.h>

void *malloc (size_t siz)
{
ffff800000103161:	55                   	push   rbp
ffff800000103162:	48 89 e5             	mov    rbp,rsp
ffff800000103165:	48 83 ec 20          	sub    rsp,0x20
ffff800000103169:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
    u64 request = siz;
ffff80000010316d:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000103171:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax

    if (siz == 0) {
ffff800000103175:	48 83 7d e8 00       	cmp    QWORD PTR [rbp-0x18],0x0
ffff80000010317a:	75 0a                	jne    ffff800000103186 <malloc+0x25>
        return NULL;
ffff80000010317c:	b8 00 00 00 00       	mov    eax,0x0
ffff800000103181:	e9 93 01 00 00       	jmp    ffff800000103319 <malloc+0x1b8>
    }
    block_t *curr = _heap.root;
ffff800000103186:	48 8b 05 0b f1 00 00 	mov    rax,QWORD PTR [rip+0xf10b]        # ffff800000112298 <_heap+0x8>
ffff80000010318d:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

    siz = _ALIGN(siz + sizeof(block_t) * 2, 8);
ffff800000103191:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000103195:	48 83 c0 0f          	add    rax,0xf
ffff800000103199:	48 83 e0 f8          	and    rax,0xfffffffffffffff8
ffff80000010319d:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
    while (curr && (u64)curr < (u64)_heap.brk) {
ffff8000001031a1:	e9 3d 01 00 00       	jmp    ffff8000001032e3 <malloc+0x182>
        if (!ALOC(*curr)) {
ffff8000001031a6:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001031aa:	8b 00                	mov    eax,DWORD PTR [rax]
ffff8000001031ac:	83 e0 01             	and    eax,0x1
ffff8000001031af:	85 c0                	test   eax,eax
ffff8000001031b1:	0f 85 ef 00 00 00    	jne    ffff8000001032a6 <malloc+0x145>
            if (SIZ(*curr) > siz) {
ffff8000001031b7:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001031bb:	8b 00                	mov    eax,DWORD PTR [rax]
ffff8000001031bd:	c1 e8 03             	shr    eax,0x3
ffff8000001031c0:	89 c0                	mov    eax,eax
ffff8000001031c2:	48 39 45 e8          	cmp    QWORD PTR [rbp-0x18],rax
ffff8000001031c6:	0f 83 90 00 00 00    	jae    ffff80000010325c <malloc+0xfb>
                PUT (OFFSET(curr, SIZ(*curr) - 4), SET(SIZ(*curr) - siz, false)); // Next free footer
ffff8000001031cc:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001031d0:	8b 00                	mov    eax,DWORD PTR [rax]
ffff8000001031d2:	c1 e8 03             	shr    eax,0x3
ffff8000001031d5:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
ffff8000001031d9:	89 d1                	mov    ecx,edx
ffff8000001031db:	29 c8                	sub    eax,ecx
ffff8000001031dd:	89 c2                	mov    edx,eax
ffff8000001031df:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001031e3:	8b 00                	mov    eax,DWORD PTR [rax]
ffff8000001031e5:	c1 e8 03             	shr    eax,0x3
ffff8000001031e8:	83 e8 04             	sub    eax,0x4
ffff8000001031eb:	89 c1                	mov    ecx,eax
ffff8000001031ed:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001031f1:	48 01 c8             	add    rax,rcx
ffff8000001031f4:	c1 e2 03             	shl    edx,0x3
ffff8000001031f7:	89 10                	mov    DWORD PTR [rax],edx
                PUT (OFFSET(curr, siz           ), SET(SIZ(*curr) - siz, false)); // Next free header
ffff8000001031f9:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001031fd:	8b 00                	mov    eax,DWORD PTR [rax]
ffff8000001031ff:	c1 e8 03             	shr    eax,0x3
ffff800000103202:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
ffff800000103206:	29 d0                	sub    eax,edx
ffff800000103208:	89 c1                	mov    ecx,eax
ffff80000010320a:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
ffff80000010320e:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000103212:	48 01 d0             	add    rax,rdx
ffff800000103215:	8d 14 cd 00 00 00 00 	lea    edx,[rcx*8+0x0]
ffff80000010321c:	89 10                	mov    DWORD PTR [rax],edx

                PUT (curr, SET(siz, true));                  // Header
ffff80000010321e:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000103222:	c1 e0 03             	shl    eax,0x3
ffff800000103225:	83 c8 01             	or     eax,0x1
ffff800000103228:	89 c2                	mov    edx,eax
ffff80000010322a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010322e:	89 10                	mov    DWORD PTR [rax],edx
                PUT (OFFSET(curr, siz - 4), SET(siz, true)); // Footer
ffff800000103230:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000103234:	8d 14 c5 00 00 00 00 	lea    edx,[rax*8+0x0]
ffff80000010323b:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff80000010323f:	48 8d 48 fc          	lea    rcx,[rax-0x4]
ffff800000103243:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103247:	48 01 c8             	add    rax,rcx
ffff80000010324a:	83 ca 01             	or     edx,0x1
ffff80000010324d:	89 10                	mov    DWORD PTR [rax],edx

                return PAYLOAD (curr);
ffff80000010324f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103253:	48 83 c0 04          	add    rax,0x4
ffff800000103257:	e9 bd 00 00 00       	jmp    ffff800000103319 <malloc+0x1b8>
            } else if (SIZ(*curr) == siz) {
ffff80000010325c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103260:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000103262:	c1 e8 03             	shr    eax,0x3
ffff800000103265:	89 c0                	mov    eax,eax
ffff800000103267:	48 39 45 e8          	cmp    QWORD PTR [rbp-0x18],rax
ffff80000010326b:	75 39                	jne    ffff8000001032a6 <malloc+0x145>
                PUT (curr, SET(siz, true));                 // Header
ffff80000010326d:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000103271:	c1 e0 03             	shl    eax,0x3
ffff800000103274:	83 c8 01             	or     eax,0x1
ffff800000103277:	89 c2                	mov    edx,eax
ffff800000103279:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010327d:	89 10                	mov    DWORD PTR [rax],edx
                PUT (OFFSET(curr, SIZ(*curr) - 4),*curr);   // Footer
ffff80000010327f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103283:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000103285:	c1 e8 03             	shr    eax,0x3
ffff800000103288:	83 e8 04             	sub    eax,0x4
ffff80000010328b:	89 c2                	mov    edx,eax
ffff80000010328d:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103291:	48 01 c2             	add    rdx,rax
ffff800000103294:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103298:	8b 00                	mov    eax,DWORD PTR [rax]
ffff80000010329a:	89 02                	mov    DWORD PTR [rdx],eax

                return PAYLOAD (curr);
ffff80000010329c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001032a0:	48 83 c0 04          	add    rax,0x4
ffff8000001032a4:	eb 73                	jmp    ffff800000103319 <malloc+0x1b8>
            }
        }

        ASSERTK (*curr != 0);
ffff8000001032a6:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001032aa:	8b 00                	mov    eax,DWORD PTR [rax]
ffff8000001032ac:	85 c0                	test   eax,eax
ffff8000001032ae:	0f 95 c0             	setne  al
ffff8000001032b1:	0f b6 c0             	movzx  eax,al
ffff8000001032b4:	48 8d 15 b7 32 00 00 	lea    rdx,[rip+0x32b7]        # ffff800000106572 <lwstr+0x332>
ffff8000001032bb:	48 89 d1             	mov    rcx,rdx
ffff8000001032be:	89 c2                	mov    edx,eax
ffff8000001032c0:	be 5e 00 00 00       	mov    esi,0x5e
ffff8000001032c5:	48 8d 05 b1 32 00 00 	lea    rax,[rip+0x32b1]        # ffff80000010657d <lwstr+0x33d>
ffff8000001032cc:	48 89 c7             	mov    rdi,rax
ffff8000001032cf:	e8 c3 ce ff ff       	call   ffff800000100197 <assertk>
        curr = OFFSET (curr, SIZ(*curr));
ffff8000001032d4:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001032d8:	8b 00                	mov    eax,DWORD PTR [rax]
ffff8000001032da:	c1 e8 03             	shr    eax,0x3
ffff8000001032dd:	89 c0                	mov    eax,eax
ffff8000001032df:	48 01 45 f8          	add    QWORD PTR [rbp-0x8],rax
    while (curr && (u64)curr < (u64)_heap.brk) {
ffff8000001032e3:	48 83 7d f8 00       	cmp    QWORD PTR [rbp-0x8],0x0
ffff8000001032e8:	74 17                	je     ffff800000103301 <malloc+0x1a0>
ffff8000001032ea:	48 8b 05 9f ef 00 00 	mov    rax,QWORD PTR [rip+0xef9f]        # ffff800000112290 <_heap>
ffff8000001032f1:	48 89 c2             	mov    rdx,rax
ffff8000001032f4:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001032f8:	48 39 d0             	cmp    rax,rdx
ffff8000001032fb:	0f 82 a5 fe ff ff    	jb     ffff8000001031a6 <malloc+0x45>
    }

    _extend_heap (siz);
ffff800000103301:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000103305:	48 89 c7             	mov    rdi,rax
ffff800000103308:	e8 18 02 00 00       	call   ffff800000103525 <_extend_heap>
    
    return malloc (request);
ffff80000010330d:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000103311:	48 89 c7             	mov    rdi,rax
ffff800000103314:	e8 48 fe ff ff       	call   ffff800000103161 <malloc>
}
ffff800000103319:	c9                   	leave
ffff80000010331a:	c3                   	ret

ffff80000010331b <free>:

void free (void *addr)
{
ffff80000010331b:	55                   	push   rbp
ffff80000010331c:	48 89 e5             	mov    rbp,rsp
ffff80000010331f:	48 83 ec 20          	sub    rsp,0x20
ffff800000103323:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
    if (addr == NULL || (u64)addr > (u64)_heap.max) {
ffff800000103327:	48 83 7d e8 00       	cmp    QWORD PTR [rbp-0x18],0x0
ffff80000010332c:	74 79                	je     ffff8000001033a7 <free+0x8c>
ffff80000010332e:	48 8b 05 6b ef 00 00 	mov    rax,QWORD PTR [rip+0xef6b]        # ffff8000001122a0 <_heap+0x10>
ffff800000103335:	48 89 c2             	mov    rdx,rax
ffff800000103338:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff80000010333c:	48 39 c2             	cmp    rdx,rax
ffff80000010333f:	72 66                	jb     ffff8000001033a7 <free+0x8c>
        return;
    }

    block_t *hdr = addr - 4;
ffff800000103341:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000103345:	48 83 e8 04          	sub    rax,0x4
ffff800000103349:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    block_t *ftr = (void *)hdr + SIZ(*hdr) - sizeof(block_t);
ffff80000010334d:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103351:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000103353:	c1 e8 03             	shr    eax,0x3
ffff800000103356:	89 c0                	mov    eax,eax
ffff800000103358:	48 8d 50 fc          	lea    rdx,[rax-0x4]
ffff80000010335c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103360:	48 01 d0             	add    rax,rdx
ffff800000103363:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax

    if (*hdr != *ftr) {
ffff800000103367:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010336b:	8b 10                	mov    edx,DWORD PTR [rax]
ffff80000010336d:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000103371:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000103373:	39 c2                	cmp    edx,eax
ffff800000103375:	75 33                	jne    ffff8000001033aa <free+0x8f>
        return;
    }

    PUT(hdr, SET(SIZ(*hdr), false));
ffff800000103377:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010337b:	8b 00                	mov    eax,DWORD PTR [rax]
ffff80000010337d:	83 e0 f8             	and    eax,0xfffffff8
ffff800000103380:	89 c2                	mov    edx,eax
ffff800000103382:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103386:	89 10                	mov    DWORD PTR [rax],edx
    PUT(ftr, SET(SIZ(*ftr), false));
ffff800000103388:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff80000010338c:	8b 00                	mov    eax,DWORD PTR [rax]
ffff80000010338e:	83 e0 f8             	and    eax,0xfffffff8
ffff800000103391:	89 c2                	mov    edx,eax
ffff800000103393:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000103397:	89 10                	mov    DWORD PTR [rax],edx

    // ૮(˶ᵔ ᵕ ᵔ˶)ა
    _merge (hdr);
ffff800000103399:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010339d:	48 89 c7             	mov    rdi,rax
ffff8000001033a0:	e8 08 00 00 00       	call   ffff8000001033ad <_merge>
ffff8000001033a5:	eb 04                	jmp    ffff8000001033ab <free+0x90>
        return;
ffff8000001033a7:	90                   	nop
ffff8000001033a8:	eb 01                	jmp    ffff8000001033ab <free+0x90>
        return;
ffff8000001033aa:	90                   	nop
}
ffff8000001033ab:	c9                   	leave
ffff8000001033ac:	c3                   	ret

ffff8000001033ad <_merge>:

static void _merge (block_t *hdr)
{
ffff8000001033ad:	55                   	push   rbp
ffff8000001033ae:	48 89 e5             	mov    rbp,rsp
ffff8000001033b1:	48 83 ec 40          	sub    rsp,0x40
ffff8000001033b5:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
    block_t *ftr = (void *)hdr + SIZ(*hdr) - sizeof(block_t);
ffff8000001033b9:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff8000001033bd:	8b 00                	mov    eax,DWORD PTR [rax]
ffff8000001033bf:	c1 e8 03             	shr    eax,0x3
ffff8000001033c2:	89 c0                	mov    eax,eax
ffff8000001033c4:	48 8d 50 fc          	lea    rdx,[rax-0x4]
ffff8000001033c8:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff8000001033cc:	48 01 d0             	add    rax,rdx
ffff8000001033cf:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    
    block_t *prev_ftr = hdr - 1;
ffff8000001033d3:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff8000001033d7:	48 83 e8 04          	sub    rax,0x4
ffff8000001033db:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
    block_t *next_hdr = ftr + 1;
ffff8000001033df:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001033e3:	48 83 c0 04          	add    rax,0x4
ffff8000001033e7:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax

    if (!ALOC(*next_hdr) && SIZ(*next_hdr)) {
ffff8000001033eb:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001033ef:	8b 00                	mov    eax,DWORD PTR [rax]
ffff8000001033f1:	83 e0 01             	and    eax,0x1
ffff8000001033f4:	85 c0                	test   eax,eax
ffff8000001033f6:	0f 85 89 00 00 00    	jne    ffff800000103485 <_merge+0xd8>
ffff8000001033fc:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000103400:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000103402:	c1 e8 03             	shr    eax,0x3
ffff800000103405:	85 c0                	test   eax,eax
ffff800000103407:	74 7c                	je     ffff800000103485 <_merge+0xd8>
        block_t *next_ftr = OFFSET (next_hdr, SIZ(*next_hdr) - 4);
ffff800000103409:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff80000010340d:	8b 00                	mov    eax,DWORD PTR [rax]
ffff80000010340f:	c1 e8 03             	shr    eax,0x3
ffff800000103412:	83 e8 04             	sub    eax,0x4
ffff800000103415:	89 c2                	mov    edx,eax
ffff800000103417:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff80000010341b:	48 01 d0             	add    rax,rdx
ffff80000010341e:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
        ASSERTK (*next_hdr == *next_ftr);
ffff800000103422:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000103426:	8b 10                	mov    edx,DWORD PTR [rax]
ffff800000103428:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff80000010342c:	8b 00                	mov    eax,DWORD PTR [rax]
ffff80000010342e:	39 c2                	cmp    edx,eax
ffff800000103430:	0f 94 c0             	sete   al
ffff800000103433:	0f b6 c0             	movzx  eax,al
ffff800000103436:	48 8d 15 4a 31 00 00 	lea    rdx,[rip+0x314a]        # ffff800000106587 <lwstr+0x347>
ffff80000010343d:	48 89 d1             	mov    rcx,rdx
ffff800000103440:	89 c2                	mov    edx,eax
ffff800000103442:	be 84 00 00 00       	mov    esi,0x84
ffff800000103447:	48 8d 05 2f 31 00 00 	lea    rax,[rip+0x312f]        # ffff80000010657d <lwstr+0x33d>
ffff80000010344e:	48 89 c7             	mov    rdi,rax
ffff800000103451:	e8 41 cd ff ff       	call   ffff800000100197 <assertk>
        PUT (hdr, SET(SIZ(*hdr) + SIZ(*next_hdr), false)); // Set hdr
ffff800000103456:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff80000010345a:	8b 00                	mov    eax,DWORD PTR [rax]
ffff80000010345c:	c1 e8 03             	shr    eax,0x3
ffff80000010345f:	89 c2                	mov    edx,eax
ffff800000103461:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000103465:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000103467:	c1 e8 03             	shr    eax,0x3
ffff80000010346a:	01 d0                	add    eax,edx
ffff80000010346c:	8d 14 c5 00 00 00 00 	lea    edx,[rax*8+0x0]
ffff800000103473:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff800000103477:	89 10                	mov    DWORD PTR [rax],edx
        PUT (next_ftr, *hdr);                              // Set Ftr
ffff800000103479:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff80000010347d:	8b 10                	mov    edx,DWORD PTR [rax]
ffff80000010347f:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000103483:	89 10                	mov    DWORD PTR [rax],edx
    }
    if (!ALOC(*prev_ftr) && SIZ(*prev_ftr)) {
ffff800000103485:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000103489:	8b 00                	mov    eax,DWORD PTR [rax]
ffff80000010348b:	83 e0 01             	and    eax,0x1
ffff80000010348e:	85 c0                	test   eax,eax
ffff800000103490:	0f 85 8c 00 00 00    	jne    ffff800000103522 <_merge+0x175>
ffff800000103496:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff80000010349a:	8b 00                	mov    eax,DWORD PTR [rax]
ffff80000010349c:	c1 e8 03             	shr    eax,0x3
ffff80000010349f:	85 c0                	test   eax,eax
ffff8000001034a1:	74 7f                	je     ffff800000103522 <_merge+0x175>
        block_t *prev_hdr = (void *)hdr - SIZ(*prev_ftr);
ffff8000001034a3:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff8000001034a7:	8b 00                	mov    eax,DWORD PTR [rax]
ffff8000001034a9:	c1 e8 03             	shr    eax,0x3
ffff8000001034ac:	89 c0                	mov    eax,eax
ffff8000001034ae:	48 f7 d8             	neg    rax
ffff8000001034b1:	48 89 c2             	mov    rdx,rax
ffff8000001034b4:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff8000001034b8:	48 01 d0             	add    rax,rdx
ffff8000001034bb:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
        ASSERTK (*prev_hdr == *prev_ftr);
ffff8000001034bf:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001034c3:	8b 10                	mov    edx,DWORD PTR [rax]
ffff8000001034c5:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff8000001034c9:	8b 00                	mov    eax,DWORD PTR [rax]
ffff8000001034cb:	39 c2                	cmp    edx,eax
ffff8000001034cd:	0f 94 c0             	sete   al
ffff8000001034d0:	0f b6 c0             	movzx  eax,al
ffff8000001034d3:	48 8d 15 c4 30 00 00 	lea    rdx,[rip+0x30c4]        # ffff80000010659e <lwstr+0x35e>
ffff8000001034da:	48 89 d1             	mov    rcx,rdx
ffff8000001034dd:	89 c2                	mov    edx,eax
ffff8000001034df:	be 8a 00 00 00       	mov    esi,0x8a
ffff8000001034e4:	48 8d 05 92 30 00 00 	lea    rax,[rip+0x3092]        # ffff80000010657d <lwstr+0x33d>
ffff8000001034eb:	48 89 c7             	mov    rdi,rax
ffff8000001034ee:	e8 a4 cc ff ff       	call   ffff800000100197 <assertk>
        PUT (prev_hdr, SET(SIZ(*prev_hdr) + SIZ(*hdr), false));
ffff8000001034f3:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001034f7:	8b 00                	mov    eax,DWORD PTR [rax]
ffff8000001034f9:	c1 e8 03             	shr    eax,0x3
ffff8000001034fc:	89 c2                	mov    edx,eax
ffff8000001034fe:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff800000103502:	8b 00                	mov    eax,DWORD PTR [rax]
ffff800000103504:	c1 e8 03             	shr    eax,0x3
ffff800000103507:	01 d0                	add    eax,edx
ffff800000103509:	8d 14 c5 00 00 00 00 	lea    edx,[rax*8+0x0]
ffff800000103510:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000103514:	89 10                	mov    DWORD PTR [rax],edx
        PUT (ftr, *prev_hdr);
ffff800000103516:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff80000010351a:	8b 10                	mov    edx,DWORD PTR [rax]
ffff80000010351c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103520:	89 10                	mov    DWORD PTR [rax],edx
    }
}
ffff800000103522:	90                   	nop
ffff800000103523:	c9                   	leave
ffff800000103524:	c3                   	ret

ffff800000103525 <_extend_heap>:

static void _extend_heap (size_t siz)
{
ffff800000103525:	55                   	push   rbp
ffff800000103526:	48 89 e5             	mov    rbp,rsp
ffff800000103529:	48 83 ec 30          	sub    rsp,0x30
ffff80000010352d:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
    siz = _ALIGN (siz, 8);
ffff800000103531:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000103535:	48 83 c0 07          	add    rax,0x7
ffff800000103539:	48 83 e0 f8          	and    rax,0xfffffffffffffff8
ffff80000010353d:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
    int64 diff = (u64)_heap.brk + siz - (u64)_heap.max;
ffff800000103541:	48 8b 05 48 ed 00 00 	mov    rax,QWORD PTR [rip+0xed48]        # ffff800000112290 <_heap>
ffff800000103548:	48 89 c2             	mov    rdx,rax
ffff80000010354b:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff80000010354f:	48 01 d0             	add    rax,rdx
ffff800000103552:	48 8b 15 47 ed 00 00 	mov    rdx,QWORD PTR [rip+0xed47]        # ffff8000001122a0 <_heap+0x10>
ffff800000103559:	48 29 d0             	sub    rax,rdx
ffff80000010355c:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    if (diff > 0) {
ffff800000103560:	48 83 7d f8 00       	cmp    QWORD PTR [rbp-0x8],0x0
ffff800000103565:	7e 6e                	jle    ffff8000001035d5 <_extend_heap+0xb0>
        u64 pages = DIV_ROUND_UP(diff, PAGE_SIZ);
ffff800000103567:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010356b:	48 05 ff 0f 00 00    	add    rax,0xfff
ffff800000103571:	48 8d 90 ff 0f 00 00 	lea    rdx,[rax+0xfff]
ffff800000103578:	48 85 c0             	test   rax,rax
ffff80000010357b:	48 0f 48 c2          	cmovs  rax,rdx
ffff80000010357f:	48 c1 f8 0c          	sar    rax,0xc
ffff800000103583:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
        void *ext = pmm_allocpages(pages);
ffff800000103587:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff80000010358b:	48 89 c7             	mov    rdi,rax
ffff80000010358e:	e8 20 ea ff ff       	call   ffff800000101fb3 <pmm_allocpages>
ffff800000103593:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax

        vmap_map ((u64)ext, (u64)_heap.max, pages, PE_RW | PE_P, MAP_4K);
ffff800000103597:	48 8b 05 02 ed 00 00 	mov    rax,QWORD PTR [rip+0xed02]        # ffff8000001122a0 <_heap+0x10>
ffff80000010359e:	48 89 c6             	mov    rsi,rax
ffff8000001035a1:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001035a5:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
ffff8000001035a9:	41 b8 01 00 00 00    	mov    r8d,0x1
ffff8000001035af:	b9 03 00 00 00       	mov    ecx,0x3
ffff8000001035b4:	48 89 c7             	mov    rdi,rax
ffff8000001035b7:	e8 e7 f8 ff ff       	call   ffff800000102ea3 <vmap_map>

        _heap.max += pages * PAGE_SIZ;
ffff8000001035bc:	48 8b 05 dd ec 00 00 	mov    rax,QWORD PTR [rip+0xecdd]        # ffff8000001122a0 <_heap+0x10>
ffff8000001035c3:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
ffff8000001035c7:	48 c1 e2 0c          	shl    rdx,0xc
ffff8000001035cb:	48 01 d0             	add    rax,rdx
ffff8000001035ce:	48 89 05 cb ec 00 00 	mov    QWORD PTR [rip+0xeccb],rax        # ffff8000001122a0 <_heap+0x10>
    }

    void *hdr = sbrk (siz); // get prev Brk as hdr that a new free block holds
ffff8000001035d5:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001035d9:	48 89 c7             	mov    rdi,rax
ffff8000001035dc:	e8 48 fb ff ff       	call   ffff800000103129 <sbrk>
ffff8000001035e1:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax

    PUT (hdr, SET(siz, false));           // 新的头
ffff8000001035e5:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001035e9:	8d 14 c5 00 00 00 00 	lea    edx,[rax*8+0x0]
ffff8000001035f0:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff8000001035f4:	89 10                	mov    DWORD PTR [rax],edx
    PUT (hdr + siz - 4, SET(siz, false)); // 新的脚
ffff8000001035f6:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001035fa:	89 c1                	mov    ecx,eax
ffff8000001035fc:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000103600:	48 8d 50 fc          	lea    rdx,[rax-0x4]
ffff800000103604:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000103608:	48 01 d0             	add    rax,rdx
ffff80000010360b:	8d 14 cd 00 00 00 00 	lea    edx,[rcx*8+0x0]
ffff800000103612:	89 10                	mov    DWORD PTR [rax],edx
    PUT (hdr + siz, SET(0, true));        // 结尾块
ffff800000103614:	48 8b 55 e0          	mov    rdx,QWORD PTR [rbp-0x20]
ffff800000103618:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff80000010361c:	48 01 d0             	add    rax,rdx
ffff80000010361f:	c7 00 01 00 00 00    	mov    DWORD PTR [rax],0x1

    _merge (hdr);
ffff800000103625:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000103629:	48 89 c7             	mov    rdi,rax
ffff80000010362c:	e8 7c fd ff ff       	call   ffff8000001033ad <_merge>
}
ffff800000103631:	90                   	nop
ffff800000103632:	c9                   	leave
ffff800000103633:	c3                   	ret

ffff800000103634 <pixel_put>:

void pixel_put (
        u32 x,u32 y,
        u32 color
        )
{
ffff800000103634:	55                   	push   rbp
ffff800000103635:	48 89 e5             	mov    rbp,rsp
ffff800000103638:	89 7d ec             	mov    DWORD PTR [rbp-0x14],edi
ffff80000010363b:	89 75 e8             	mov    DWORD PTR [rbp-0x18],esi
ffff80000010363e:	89 55 e4             	mov    DWORD PTR [rbp-0x1c],edx
    if (x > hor || y > hor) {
ffff800000103641:	8b 05 61 ec 00 00    	mov    eax,DWORD PTR [rip+0xec61]        # ffff8000001122a8 <hor>
ffff800000103647:	3b 45 ec             	cmp    eax,DWORD PTR [rbp-0x14]
ffff80000010364a:	72 3a                	jb     ffff800000103686 <pixel_put+0x52>
ffff80000010364c:	8b 05 56 ec 00 00    	mov    eax,DWORD PTR [rip+0xec56]        # ffff8000001122a8 <hor>
ffff800000103652:	3b 45 e8             	cmp    eax,DWORD PTR [rbp-0x18]
ffff800000103655:	72 2f                	jb     ffff800000103686 <pixel_put+0x52>
        return;
    }

    u32 *pixel = fb + x + hor * y;
ffff800000103657:	48 8b 15 52 ec 00 00 	mov    rdx,QWORD PTR [rip+0xec52]        # ffff8000001122b0 <fb>
ffff80000010365e:	8b 4d ec             	mov    ecx,DWORD PTR [rbp-0x14]
ffff800000103661:	8b 05 41 ec 00 00    	mov    eax,DWORD PTR [rip+0xec41]        # ffff8000001122a8 <hor>
ffff800000103667:	0f af 45 e8          	imul   eax,DWORD PTR [rbp-0x18]
ffff80000010366b:	89 c0                	mov    eax,eax
ffff80000010366d:	48 01 c8             	add    rax,rcx
ffff800000103670:	48 c1 e0 02          	shl    rax,0x2
ffff800000103674:	48 01 d0             	add    rax,rdx
ffff800000103677:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    *pixel = color;
ffff80000010367b:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010367f:	8b 55 e4             	mov    edx,DWORD PTR [rbp-0x1c]
ffff800000103682:	89 10                	mov    DWORD PTR [rax],edx
ffff800000103684:	eb 01                	jmp    ffff800000103687 <pixel_put+0x53>
        return;
ffff800000103686:	90                   	nop
}
ffff800000103687:	5d                   	pop    rbp
ffff800000103688:	c3                   	ret

ffff800000103689 <block_put>:
void block_put (
        u32 x,u32 y,
        u32 xe,u32 ye,
        u32 color
        )
{
ffff800000103689:	55                   	push   rbp
ffff80000010368a:	48 89 e5             	mov    rbp,rsp
ffff80000010368d:	48 83 ec 28          	sub    rsp,0x28
ffff800000103691:	89 7d ec             	mov    DWORD PTR [rbp-0x14],edi
ffff800000103694:	89 75 e8             	mov    DWORD PTR [rbp-0x18],esi
ffff800000103697:	89 55 e4             	mov    DWORD PTR [rbp-0x1c],edx
ffff80000010369a:	89 4d e0             	mov    DWORD PTR [rbp-0x20],ecx
ffff80000010369d:	44 89 45 dc          	mov    DWORD PTR [rbp-0x24],r8d
    if (x > xe) {
ffff8000001036a1:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
ffff8000001036a4:	39 45 e4             	cmp    DWORD PTR [rbp-0x1c],eax
ffff8000001036a7:	73 12                	jae    ffff8000001036bb <block_put+0x32>
        u32 tmp = x;
ffff8000001036a9:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
ffff8000001036ac:	89 45 f4             	mov    DWORD PTR [rbp-0xc],eax
        x = xe;
ffff8000001036af:	8b 45 e4             	mov    eax,DWORD PTR [rbp-0x1c]
ffff8000001036b2:	89 45 ec             	mov    DWORD PTR [rbp-0x14],eax
        xe = tmp;
ffff8000001036b5:	8b 45 f4             	mov    eax,DWORD PTR [rbp-0xc]
ffff8000001036b8:	89 45 e4             	mov    DWORD PTR [rbp-0x1c],eax
    }

    if (y > ye) {
ffff8000001036bb:	8b 45 e8             	mov    eax,DWORD PTR [rbp-0x18]
ffff8000001036be:	39 45 e0             	cmp    DWORD PTR [rbp-0x20],eax
ffff8000001036c1:	73 12                	jae    ffff8000001036d5 <block_put+0x4c>
        u32 tmp = y;
ffff8000001036c3:	8b 45 e8             	mov    eax,DWORD PTR [rbp-0x18]
ffff8000001036c6:	89 45 f0             	mov    DWORD PTR [rbp-0x10],eax
        y = ye;
ffff8000001036c9:	8b 45 e0             	mov    eax,DWORD PTR [rbp-0x20]
ffff8000001036cc:	89 45 e8             	mov    DWORD PTR [rbp-0x18],eax
        ye = tmp;
ffff8000001036cf:	8b 45 f0             	mov    eax,DWORD PTR [rbp-0x10]
ffff8000001036d2:	89 45 e0             	mov    DWORD PTR [rbp-0x20],eax
    }

    for (u32 i = x ; i < xe && i < hor ; i++)
ffff8000001036d5:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
ffff8000001036d8:	89 45 fc             	mov    DWORD PTR [rbp-0x4],eax
ffff8000001036db:	eb 35                	jmp    ffff800000103712 <block_put+0x89>
        for (u32 j = y ; j < ye && j < ver ; j++)
ffff8000001036dd:	8b 45 e8             	mov    eax,DWORD PTR [rbp-0x18]
ffff8000001036e0:	89 45 f8             	mov    DWORD PTR [rbp-0x8],eax
ffff8000001036e3:	eb 16                	jmp    ffff8000001036fb <block_put+0x72>
            pixel_put (i, j, color);
ffff8000001036e5:	8b 55 dc             	mov    edx,DWORD PTR [rbp-0x24]
ffff8000001036e8:	8b 4d f8             	mov    ecx,DWORD PTR [rbp-0x8]
ffff8000001036eb:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff8000001036ee:	89 ce                	mov    esi,ecx
ffff8000001036f0:	89 c7                	mov    edi,eax
ffff8000001036f2:	e8 3d ff ff ff       	call   ffff800000103634 <pixel_put>
        for (u32 j = y ; j < ye && j < ver ; j++)
ffff8000001036f7:	83 45 f8 01          	add    DWORD PTR [rbp-0x8],0x1
ffff8000001036fb:	8b 45 f8             	mov    eax,DWORD PTR [rbp-0x8]
ffff8000001036fe:	3b 45 e0             	cmp    eax,DWORD PTR [rbp-0x20]
ffff800000103701:	73 0b                	jae    ffff80000010370e <block_put+0x85>
ffff800000103703:	8b 05 a3 eb 00 00    	mov    eax,DWORD PTR [rip+0xeba3]        # ffff8000001122ac <ver>
ffff800000103709:	39 45 f8             	cmp    DWORD PTR [rbp-0x8],eax
ffff80000010370c:	72 d7                	jb     ffff8000001036e5 <block_put+0x5c>
    for (u32 i = x ; i < xe && i < hor ; i++)
ffff80000010370e:	83 45 fc 01          	add    DWORD PTR [rbp-0x4],0x1
ffff800000103712:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff800000103715:	3b 45 e4             	cmp    eax,DWORD PTR [rbp-0x1c]
ffff800000103718:	73 0b                	jae    ffff800000103725 <block_put+0x9c>
ffff80000010371a:	8b 05 88 eb 00 00    	mov    eax,DWORD PTR [rip+0xeb88]        # ffff8000001122a8 <hor>
ffff800000103720:	39 45 fc             	cmp    DWORD PTR [rbp-0x4],eax
ffff800000103723:	72 b8                	jb     ffff8000001036dd <block_put+0x54>
}
ffff800000103725:	90                   	nop
ffff800000103726:	c9                   	leave
ffff800000103727:	c3                   	ret

ffff800000103728 <screen_clear>:

void screen_clear ()
{
ffff800000103728:	55                   	push   rbp
ffff800000103729:	48 89 e5             	mov    rbp,rsp
    u32 i = fb_siz / 4;
ffff80000010372c:	48 8b 05 85 eb 00 00 	mov    rax,QWORD PTR [rip+0xeb85]        # ffff8000001122b8 <fb_siz>
ffff800000103733:	48 c1 e8 02          	shr    rax,0x2
ffff800000103737:	89 45 fc             	mov    DWORD PTR [rbp-0x4],eax
    u32 *p = fb;
ffff80000010373a:	48 8b 05 6f eb 00 00 	mov    rax,QWORD PTR [rip+0xeb6f]        # ffff8000001122b0 <fb>
ffff800000103741:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax

    while (i-- && p)
ffff800000103745:	eb 12                	jmp    ffff800000103759 <screen_clear+0x31>
        *p++ = 0;
ffff800000103747:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff80000010374b:	48 8d 50 04          	lea    rdx,[rax+0x4]
ffff80000010374f:	48 89 55 f0          	mov    QWORD PTR [rbp-0x10],rdx
ffff800000103753:	c7 00 00 00 00 00    	mov    DWORD PTR [rax],0x0
    while (i-- && p)
ffff800000103759:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff80000010375c:	8d 50 ff             	lea    edx,[rax-0x1]
ffff80000010375f:	89 55 fc             	mov    DWORD PTR [rbp-0x4],edx
ffff800000103762:	85 c0                	test   eax,eax
ffff800000103764:	74 07                	je     ffff80000010376d <screen_clear+0x45>
ffff800000103766:	48 83 7d f0 00       	cmp    QWORD PTR [rbp-0x10],0x0
ffff80000010376b:	75 da                	jne    ffff800000103747 <screen_clear+0x1f>
}
ffff80000010376d:	90                   	nop
ffff80000010376e:	5d                   	pop    rbp
ffff80000010376f:	c3                   	ret

ffff800000103770 <screen_info>:

void screen_info (u32 *i_hor, u32 *i_ver)
{
ffff800000103770:	55                   	push   rbp
ffff800000103771:	48 89 e5             	mov    rbp,rsp
ffff800000103774:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
ffff800000103778:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
    *i_hor = hor;
ffff80000010377c:	8b 15 26 eb 00 00    	mov    edx,DWORD PTR [rip+0xeb26]        # ffff8000001122a8 <hor>
ffff800000103782:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103786:	89 10                	mov    DWORD PTR [rax],edx
    *i_ver = ver;
ffff800000103788:	8b 15 1e eb 00 00    	mov    edx,DWORD PTR [rip+0xeb1e]        # ffff8000001122ac <ver>
ffff80000010378e:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000103792:	89 10                	mov    DWORD PTR [rax],edx
}
ffff800000103794:	90                   	nop
ffff800000103795:	5d                   	pop    rbp
ffff800000103796:	c3                   	ret

ffff800000103797 <__video_pre>:

#include <boot.h>

void __video_pre (vconfig_t *v)
{
ffff800000103797:	55                   	push   rbp
ffff800000103798:	48 89 e5             	mov    rbp,rsp
ffff80000010379b:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
    hor = v->hor;
ffff80000010379f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001037a3:	48 8b 00             	mov    rax,QWORD PTR [rax]
ffff8000001037a6:	89 05 fc ea 00 00    	mov    DWORD PTR [rip+0xeafc],eax        # ffff8000001122a8 <hor>
    ver = v->ver;
ffff8000001037ac:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001037b0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
ffff8000001037b4:	89 05 f2 ea 00 00    	mov    DWORD PTR [rip+0xeaf2],eax        # ffff8000001122ac <ver>

    fb = (void *)v->fb;
ffff8000001037ba:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001037be:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
ffff8000001037c2:	48 89 05 e7 ea 00 00 	mov    QWORD PTR [rip+0xeae7],rax        # ffff8000001122b0 <fb>
    fb_siz = v->fb_siz;
ffff8000001037c9:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001037cd:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
ffff8000001037d1:	48 89 05 e0 ea 00 00 	mov    QWORD PTR [rip+0xeae0],rax        # ffff8000001122b8 <fb_siz>
}
ffff8000001037d8:	90                   	nop
ffff8000001037d9:	5d                   	pop    rbp
ffff8000001037da:	c3                   	ret

ffff8000001037db <__video_tovmm>:

#include <textos/mm.h>

void __video_tovmm ()
{
ffff8000001037db:	55                   	push   rbp
ffff8000001037dc:	48 89 e5             	mov    rbp,rsp
ffff8000001037df:	48 83 ec 10          	sub    rsp,0x10
    size_t pages = DIV_ROUND_UP(fb_siz, PAGE_SIZ);
ffff8000001037e3:	48 8b 05 ce ea 00 00 	mov    rax,QWORD PTR [rip+0xeace]        # ffff8000001122b8 <fb_siz>
ffff8000001037ea:	48 05 ff 0f 00 00    	add    rax,0xfff
ffff8000001037f0:	48 c1 e8 0c          	shr    rax,0xc
ffff8000001037f4:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    vmap_map ((u64)fb, __kern_fb_base, pages, PE_RW | PE_P | PTE_G, MAP_4K);
ffff8000001037f8:	48 8b 05 b1 ea 00 00 	mov    rax,QWORD PTR [rip+0xeab1]        # ffff8000001122b0 <fb>
ffff8000001037ff:	48 89 c7             	mov    rdi,rax
ffff800000103802:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103806:	41 b8 01 00 00 00    	mov    r8d,0x1
ffff80000010380c:	b9 03 01 00 00       	mov    ecx,0x103
ffff800000103811:	48 89 c2             	mov    rdx,rax
ffff800000103814:	48 b8 00 00 00 00 00 	movabs rax,0xffff8a0000000000
ffff80000010381b:	8a ff ff 
ffff80000010381e:	48 89 c6             	mov    rsi,rax
ffff800000103821:	e8 7d f6 ff ff       	call   ffff800000102ea3 <vmap_map>

    fb = (void *)__kern_fb_base;
ffff800000103826:	48 b8 00 00 00 00 00 	movabs rax,0xffff8a0000000000
ffff80000010382d:	8a ff ff 
ffff800000103830:	48 89 05 79 ea 00 00 	mov    QWORD PTR [rip+0xea79],rax        # ffff8000001122b0 <fb>
}
ffff800000103837:	90                   	nop
ffff800000103838:	c9                   	leave
ffff800000103839:	c3                   	ret

ffff80000010383a <font_show>:
  Show a letter by Code.

  @retval int  The index of the bitmap according to `Font`.
*/
int font_show (u8 code, font_t *f, u64 x, u64 y, u32 fg, u32 bg)
{
ffff80000010383a:	55                   	push   rbp
ffff80000010383b:	48 89 e5             	mov    rbp,rsp
ffff80000010383e:	48 83 ec 50          	sub    rsp,0x50
ffff800000103842:	89 f8                	mov    eax,edi
ffff800000103844:	48 89 75 d0          	mov    QWORD PTR [rbp-0x30],rsi
ffff800000103848:	48 89 55 c8          	mov    QWORD PTR [rbp-0x38],rdx
ffff80000010384c:	48 89 4d c0          	mov    QWORD PTR [rbp-0x40],rcx
ffff800000103850:	44 89 45 d8          	mov    DWORD PTR [rbp-0x28],r8d
ffff800000103854:	44 89 4d bc          	mov    DWORD PTR [rbp-0x44],r9d
ffff800000103858:	88 45 dc             	mov    BYTE PTR [rbp-0x24],al
    u16 siz = f->w * f->h / 8;
ffff80000010385b:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff80000010385f:	0f b6 40 08          	movzx  eax,BYTE PTR [rax+0x8]
ffff800000103863:	0f b6 d0             	movzx  edx,al
ffff800000103866:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff80000010386a:	0f b6 40 09          	movzx  eax,BYTE PTR [rax+0x9]
ffff80000010386e:	0f b6 c0             	movzx  eax,al
ffff800000103871:	0f af c2             	imul   eax,edx
ffff800000103874:	8d 50 07             	lea    edx,[rax+0x7]
ffff800000103877:	85 c0                	test   eax,eax
ffff800000103879:	0f 48 c2             	cmovs  eax,edx
ffff80000010387c:	c1 f8 03             	sar    eax,0x3
ffff80000010387f:	66 89 45 f6          	mov    WORD PTR [rbp-0xa],ax
    u8 *base = f->base + code * siz;
ffff800000103883:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff800000103887:	48 8b 08             	mov    rcx,QWORD PTR [rax]
ffff80000010388a:	0f b6 55 dc          	movzx  edx,BYTE PTR [rbp-0x24]
ffff80000010388e:	0f b7 45 f6          	movzx  eax,WORD PTR [rbp-0xa]
ffff800000103892:	0f af c2             	imul   eax,edx
ffff800000103895:	48 98                	cdqe
ffff800000103897:	48 01 c8             	add    rax,rcx
ffff80000010389a:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax

    u8 src = 0;
ffff80000010389e:	c6 45 e7 00          	mov    BYTE PTR [rbp-0x19],0x0
    for (u32 yi = 0 ; yi < f->h ; yi++)
ffff8000001038a2:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
ffff8000001038a9:	e9 b3 00 00 00       	jmp    ffff800000103961 <font_show+0x127>
    {
        for (u32 xi = 0 ; xi < f->w ; xi++)
ffff8000001038ae:	c7 45 f8 00 00 00 00 	mov    DWORD PTR [rbp-0x8],0x0
ffff8000001038b5:	e9 8f 00 00 00       	jmp    ffff800000103949 <font_show+0x10f>
        {
            src = base[(yi * f->w + xi) / 8];
ffff8000001038ba:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff8000001038be:	0f b6 40 08          	movzx  eax,BYTE PTR [rax+0x8]
ffff8000001038c2:	0f b6 c0             	movzx  eax,al
ffff8000001038c5:	0f af 45 fc          	imul   eax,DWORD PTR [rbp-0x4]
ffff8000001038c9:	89 c2                	mov    edx,eax
ffff8000001038cb:	8b 45 f8             	mov    eax,DWORD PTR [rbp-0x8]
ffff8000001038ce:	01 d0                	add    eax,edx
ffff8000001038d0:	c1 e8 03             	shr    eax,0x3
ffff8000001038d3:	89 c2                	mov    edx,eax
ffff8000001038d5:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff8000001038d9:	48 01 d0             	add    rax,rdx
ffff8000001038dc:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff8000001038df:	88 45 e7             	mov    BYTE PTR [rbp-0x19],al

            if (src >> (7 - xi % 8) & 0x1) {
ffff8000001038e2:	0f b6 55 e7          	movzx  edx,BYTE PTR [rbp-0x19]
ffff8000001038e6:	8b 45 f8             	mov    eax,DWORD PTR [rbp-0x8]
ffff8000001038e9:	f7 d0                	not    eax
ffff8000001038eb:	83 e0 07             	and    eax,0x7
ffff8000001038ee:	89 c1                	mov    ecx,eax
ffff8000001038f0:	d3 fa                	sar    edx,cl
ffff8000001038f2:	89 d0                	mov    eax,edx
ffff8000001038f4:	83 e0 01             	and    eax,0x1
ffff8000001038f7:	85 c0                	test   eax,eax
ffff8000001038f9:	74 26                	je     ffff800000103921 <font_show+0xe7>
                pixel_put (x + xi, y + yi, fg);
ffff8000001038fb:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
ffff8000001038ff:	89 c2                	mov    edx,eax
ffff800000103901:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff800000103904:	8d 34 02             	lea    esi,[rdx+rax*1]
ffff800000103907:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff80000010390b:	89 c2                	mov    edx,eax
ffff80000010390d:	8b 45 f8             	mov    eax,DWORD PTR [rbp-0x8]
ffff800000103910:	8d 0c 02             	lea    ecx,[rdx+rax*1]
ffff800000103913:	8b 45 d8             	mov    eax,DWORD PTR [rbp-0x28]
ffff800000103916:	89 c2                	mov    edx,eax
ffff800000103918:	89 cf                	mov    edi,ecx
ffff80000010391a:	e8 15 fd ff ff       	call   ffff800000103634 <pixel_put>
ffff80000010391f:	eb 24                	jmp    ffff800000103945 <font_show+0x10b>
            } else {
                pixel_put (x + xi, y + yi, bg);
ffff800000103921:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
ffff800000103925:	89 c2                	mov    edx,eax
ffff800000103927:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff80000010392a:	8d 34 02             	lea    esi,[rdx+rax*1]
ffff80000010392d:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
ffff800000103931:	89 c2                	mov    edx,eax
ffff800000103933:	8b 45 f8             	mov    eax,DWORD PTR [rbp-0x8]
ffff800000103936:	8d 0c 02             	lea    ecx,[rdx+rax*1]
ffff800000103939:	8b 45 bc             	mov    eax,DWORD PTR [rbp-0x44]
ffff80000010393c:	89 c2                	mov    edx,eax
ffff80000010393e:	89 cf                	mov    edi,ecx
ffff800000103940:	e8 ef fc ff ff       	call   ffff800000103634 <pixel_put>
        for (u32 xi = 0 ; xi < f->w ; xi++)
ffff800000103945:	83 45 f8 01          	add    DWORD PTR [rbp-0x8],0x1
ffff800000103949:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff80000010394d:	0f b6 40 08          	movzx  eax,BYTE PTR [rax+0x8]
ffff800000103951:	0f b6 c0             	movzx  eax,al
ffff800000103954:	39 45 f8             	cmp    DWORD PTR [rbp-0x8],eax
ffff800000103957:	0f 82 5d ff ff ff    	jb     ffff8000001038ba <font_show+0x80>
    for (u32 yi = 0 ; yi < f->h ; yi++)
ffff80000010395d:	83 45 fc 01          	add    DWORD PTR [rbp-0x4],0x1
ffff800000103961:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
ffff800000103965:	0f b6 40 09          	movzx  eax,BYTE PTR [rax+0x9]
ffff800000103969:	0f b6 c0             	movzx  eax,al
ffff80000010396c:	39 45 fc             	cmp    DWORD PTR [rbp-0x4],eax
ffff80000010396f:	0f 82 39 ff ff ff    	jb     ffff8000001038ae <font_show+0x74>
            }
        }
    }

    return code;
ffff800000103975:	0f b6 45 dc          	movzx  eax,BYTE PTR [rbp-0x24]
}
ffff800000103979:	c9                   	leave
ffff80000010397a:	c3                   	ret

ffff80000010397b <font_get>:
STATIC_ASSERT(sizeof(fonts) != 0, "No font here!");

#define NR_FONT (sizeof(fonts) / sizeof(font_t))

font_t *font_get (int idx)
{
ffff80000010397b:	55                   	push   rbp
ffff80000010397c:	48 89 e5             	mov    rbp,rsp
ffff80000010397f:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
    return idx + 1 > NR_FONT ? NULL : &fonts[idx];
ffff800000103982:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff800000103985:	83 c0 01             	add    eax,0x1
ffff800000103988:	83 f8 01             	cmp    eax,0x1
ffff80000010398b:	77 18                	ja     ffff8000001039a5 <font_get+0x2a>
ffff80000010398d:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff800000103990:	48 98                	cdqe
ffff800000103992:	48 c1 e0 04          	shl    rax,0x4
ffff800000103996:	48 89 c2             	mov    rdx,rax
ffff800000103999:	48 8d 05 70 56 00 00 	lea    rax,[rip+0x5670]        # ffff800000109010 <fonts>
ffff8000001039a0:	48 01 d0             	add    rax,rdx
ffff8000001039a3:	eb 05                	jmp    ffff8000001039aa <font_get+0x2f>
ffff8000001039a5:	b8 00 00 00 00       	mov    eax,0x0
}
ffff8000001039aa:	5d                   	pop    rbp
ffff8000001039ab:	c3                   	ret

ffff8000001039ac <pic_disable>:

#define MPIC_DATA 0x21
#define SPIC_DATA 0xA1

void pic_disable ()
{
ffff8000001039ac:	55                   	push   rbp
ffff8000001039ad:	48 89 e5             	mov    rbp,rsp
    /* Mask all interrupts in 8259 */
    outb (SPIC_DATA, 0xFF);
ffff8000001039b0:	be ff 00 00 00       	mov    esi,0xff
ffff8000001039b5:	bf a1 00 00 00       	mov    edi,0xa1
ffff8000001039ba:	e8 2a 04 00 00       	call   ffff800000103de9 <outb>
    outb (MPIC_DATA, 0xFF);
ffff8000001039bf:	be ff 00 00 00       	mov    esi,0xff
ffff8000001039c4:	bf 21 00 00 00       	mov    edi,0x21
ffff8000001039c9:	e8 1b 04 00 00       	call   ffff800000103de9 <outb>
}
ffff8000001039ce:	90                   	nop
ffff8000001039cf:	5d                   	pop    rbp
ffff8000001039d0:	c3                   	ret

ffff8000001039d1 <_ms>:
#include <io.h>
#include <irq.h>
#include <intr.h>

static inline void _ms ()
{
ffff8000001039d1:	55                   	push   rbp
ffff8000001039d2:	48 89 e5             	mov    rbp,rsp
    /*
       通道2 - 先写低位,再写高位 - Interrupt On Terminal Count - BCD disabled
    */
    outb(R_MCMD, CMD_PACK(CNT_2, 0b11, M_TERM, false));
ffff8000001039d5:	be b0 00 00 00       	mov    esi,0xb0
ffff8000001039da:	bf 43 00 00 00       	mov    edi,0x43
ffff8000001039df:	e8 05 04 00 00       	call   ffff800000103de9 <outb>

    outb(R_CNT2, IC_MS & 0xff);
ffff8000001039e4:	be a9 00 00 00       	mov    esi,0xa9
ffff8000001039e9:	bf 42 00 00 00       	mov    edi,0x42
ffff8000001039ee:	e8 f6 03 00 00       	call   ffff800000103de9 <outb>
    outb(R_CNT2, (IC_MS >> 8) & 0xff);
ffff8000001039f3:	be 04 00 00 00       	mov    esi,0x4
ffff8000001039f8:	bf 42 00 00 00       	mov    edi,0x42
ffff8000001039fd:	e8 e7 03 00 00       	call   ffff800000103de9 <outb>
       0x61 为 NMI Status and Control Register 

       Timer Counter 2 OUT Status (TMR2_OUT_STS) — RO. This bit reflects the current 
       state of the 8254 counter 2 output.
    */
    while ((inb(0x61) & 0x20) == 0);
ffff800000103a02:	90                   	nop
ffff800000103a03:	bf 61 00 00 00       	mov    edi,0x61
ffff800000103a08:	e8 c3 03 00 00       	call   ffff800000103dd0 <inb>
ffff800000103a0d:	0f b6 c0             	movzx  eax,al
ffff800000103a10:	83 e0 20             	and    eax,0x20
ffff800000103a13:	85 c0                	test   eax,eax
ffff800000103a15:	74 ec                	je     ffff800000103a03 <_ms+0x32>
}
ffff800000103a17:	90                   	nop
ffff800000103a18:	90                   	nop
ffff800000103a19:	5d                   	pop    rbp
ffff800000103a1a:	c3                   	ret

ffff800000103a1b <pit_sleepms>:

void pit_sleepms (int ms)
{
ffff800000103a1b:	55                   	push   rbp
ffff800000103a1c:	48 89 e5             	mov    rbp,rsp
ffff800000103a1f:	48 83 ec 10          	sub    rsp,0x10
ffff800000103a23:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
    while (ms--)
ffff800000103a26:	eb 0a                	jmp    ffff800000103a32 <pit_sleepms+0x17>
        _ms();
ffff800000103a28:	b8 00 00 00 00       	mov    eax,0x0
ffff800000103a2d:	e8 9f ff ff ff       	call   ffff8000001039d1 <_ms>
    while (ms--)
ffff800000103a32:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
ffff800000103a35:	8d 50 ff             	lea    edx,[rax-0x1]
ffff800000103a38:	89 55 fc             	mov    DWORD PTR [rbp-0x4],edx
ffff800000103a3b:	85 c0                	test   eax,eax
ffff800000103a3d:	75 e9                	jne    ffff800000103a28 <pit_sleepms+0xd>
}
ffff800000103a3f:	90                   	nop
ffff800000103a40:	90                   	nop
ffff800000103a41:	c9                   	leave
ffff800000103a42:	c3                   	ret

ffff800000103a43 <serial_getc>:
#define R_LSR   5     // - Line Status Register
#define R_MSR   6     // - Modem Status Register
#define R_SCR   7     // - Scratch Register

static inline char serial_getc ()
{
ffff800000103a43:	55                   	push   rbp
ffff800000103a44:	48 89 e5             	mov    rbp,rsp
    while ((inb (COM1 + R_LSR) & 0x01) == 0);
ffff800000103a47:	90                   	nop
ffff800000103a48:	bf fd 03 00 00       	mov    edi,0x3fd
ffff800000103a4d:	e8 7e 03 00 00       	call   ffff800000103dd0 <inb>
ffff800000103a52:	0f b6 c0             	movzx  eax,al
ffff800000103a55:	83 e0 01             	and    eax,0x1
ffff800000103a58:	85 c0                	test   eax,eax
ffff800000103a5a:	74 ec                	je     ffff800000103a48 <serial_getc+0x5>

    return inb (COM1 + R_DATA);
ffff800000103a5c:	bf f8 03 00 00       	mov    edi,0x3f8
ffff800000103a61:	e8 6a 03 00 00       	call   ffff800000103dd0 <inb>
}
ffff800000103a66:	5d                   	pop    rbp
ffff800000103a67:	c3                   	ret

ffff800000103a68 <serial_read>:

size_t serial_read (char *str, size_t siz)
{
ffff800000103a68:	55                   	push   rbp
ffff800000103a69:	48 89 e5             	mov    rbp,rsp
ffff800000103a6c:	53                   	push   rbx
ffff800000103a6d:	48 83 ec 28          	sub    rsp,0x28
ffff800000103a71:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
ffff800000103a75:	48 89 75 d0          	mov    QWORD PTR [rbp-0x30],rsi
    for (size_t i = 0 ; i < siz ; i++)
ffff800000103a79:	48 c7 45 e8 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0
ffff800000103a80:	00 
ffff800000103a81:	eb 1d                	jmp    ffff800000103aa0 <serial_read+0x38>
        *str++ = serial_getc (); 
ffff800000103a83:	48 8b 5d d8          	mov    rbx,QWORD PTR [rbp-0x28]
ffff800000103a87:	48 8d 43 01          	lea    rax,[rbx+0x1]
ffff800000103a8b:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
ffff800000103a8f:	b8 00 00 00 00       	mov    eax,0x0
ffff800000103a94:	e8 aa ff ff ff       	call   ffff800000103a43 <serial_getc>
ffff800000103a99:	88 03                	mov    BYTE PTR [rbx],al
    for (size_t i = 0 ; i < siz ; i++)
ffff800000103a9b:	48 83 45 e8 01       	add    QWORD PTR [rbp-0x18],0x1
ffff800000103aa0:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000103aa4:	48 3b 45 d0          	cmp    rax,QWORD PTR [rbp-0x30]
ffff800000103aa8:	72 d9                	jb     ffff800000103a83 <serial_read+0x1b>

    return siz;
ffff800000103aaa:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
}
ffff800000103aae:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
ffff800000103ab2:	c9                   	leave
ffff800000103ab3:	c3                   	ret

ffff800000103ab4 <serial_putc>:

static inline void serial_putc (char Char)
{
ffff800000103ab4:	55                   	push   rbp
ffff800000103ab5:	48 89 e5             	mov    rbp,rsp
ffff800000103ab8:	48 83 ec 10          	sub    rsp,0x10
ffff800000103abc:	89 f8                	mov    eax,edi
ffff800000103abe:	88 45 fc             	mov    BYTE PTR [rbp-0x4],al
    while ((inb (COM1 + R_LSR) & 0x20) == 0);
ffff800000103ac1:	90                   	nop
ffff800000103ac2:	bf fd 03 00 00       	mov    edi,0x3fd
ffff800000103ac7:	e8 04 03 00 00       	call   ffff800000103dd0 <inb>
ffff800000103acc:	0f b6 c0             	movzx  eax,al
ffff800000103acf:	83 e0 20             	and    eax,0x20
ffff800000103ad2:	85 c0                	test   eax,eax
ffff800000103ad4:	74 ec                	je     ffff800000103ac2 <serial_putc+0xe>

    outb (COM1 + R_DATA, Char);
ffff800000103ad6:	0f b6 45 fc          	movzx  eax,BYTE PTR [rbp-0x4]
ffff800000103ada:	0f b6 c0             	movzx  eax,al
ffff800000103add:	89 c6                	mov    esi,eax
ffff800000103adf:	bf f8 03 00 00       	mov    edi,0x3f8
ffff800000103ae4:	e8 00 03 00 00       	call   ffff800000103de9 <outb>
}
ffff800000103ae9:	90                   	nop
ffff800000103aea:	c9                   	leave
ffff800000103aeb:	c3                   	ret

ffff800000103aec <serial_write>:

size_t serial_write (char *str, size_t siz)
{
ffff800000103aec:	55                   	push   rbp
ffff800000103aed:	48 89 e5             	mov    rbp,rsp
ffff800000103af0:	48 83 ec 20          	sub    rsp,0x20
ffff800000103af4:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
ffff800000103af8:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
    char *p = str;
ffff800000103afc:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000103b00:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    while (siz-- && p && *p)
ffff800000103b04:	eb 19                	jmp    ffff800000103b1f <serial_write+0x33>
        serial_putc (*p++);
ffff800000103b06:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103b0a:	48 8d 50 01          	lea    rdx,[rax+0x1]
ffff800000103b0e:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
ffff800000103b12:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000103b15:	0f be c0             	movsx  eax,al
ffff800000103b18:	89 c7                	mov    edi,eax
ffff800000103b1a:	e8 95 ff ff ff       	call   ffff800000103ab4 <serial_putc>
    while (siz-- && p && *p)
ffff800000103b1f:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000103b23:	48 8d 50 ff          	lea    rdx,[rax-0x1]
ffff800000103b27:	48 89 55 e0          	mov    QWORD PTR [rbp-0x20],rdx
ffff800000103b2b:	48 85 c0             	test   rax,rax
ffff800000103b2e:	74 12                	je     ffff800000103b42 <serial_write+0x56>
ffff800000103b30:	48 83 7d f8 00       	cmp    QWORD PTR [rbp-0x8],0x0
ffff800000103b35:	74 0b                	je     ffff800000103b42 <serial_write+0x56>
ffff800000103b37:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103b3b:	0f b6 00             	movzx  eax,BYTE PTR [rax]
ffff800000103b3e:	84 c0                	test   al,al
ffff800000103b40:	75 c4                	jne    ffff800000103b06 <serial_write+0x1a>

    return (size_t)(p - str);
ffff800000103b42:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103b46:	48 2b 45 e8          	sub    rax,QWORD PTR [rbp-0x18]
}
ffff800000103b4a:	c9                   	leave
ffff800000103b4b:	c3                   	ret

ffff800000103b4c <serial_init>:

void serial_init ()
{
ffff800000103b4c:	55                   	push   rbp
ffff800000103b4d:	48 89 e5             	mov    rbp,rsp
    outb (COM1 + R_INTR , 0);          // Disable interrupts
ffff800000103b50:	be 00 00 00 00       	mov    esi,0x0
ffff800000103b55:	bf f9 03 00 00       	mov    edi,0x3f9
ffff800000103b5a:	e8 8a 02 00 00       	call   ffff800000103de9 <outb>
    outb (COM1 + R_LCR  , 1 << 7);     // Enable DLAB
ffff800000103b5f:	be 80 00 00 00       	mov    esi,0x80
ffff800000103b64:	bf fb 03 00 00       	mov    edi,0x3fb
ffff800000103b69:	e8 7b 02 00 00       	call   ffff800000103de9 <outb>
    outb (COM1 + R_LSB  , 1);          // Set baud : 115200
ffff800000103b6e:	be 01 00 00 00       	mov    esi,0x1
ffff800000103b73:	bf f8 03 00 00       	mov    edi,0x3f8
ffff800000103b78:	e8 6c 02 00 00       	call   ffff800000103de9 <outb>
    outb (COM1 + R_MSB  , 0);          // High
ffff800000103b7d:	be 00 00 00 00       	mov    esi,0x0
ffff800000103b82:	bf f9 03 00 00       	mov    edi,0x3f9
ffff800000103b87:	e8 5d 02 00 00       	call   ffff800000103de9 <outb>
    outb (COM1 + R_LCR  , 0b11);       // 7 bits for data and 1 stop bit
ffff800000103b8c:	be 03 00 00 00       	mov    esi,0x3
ffff800000103b91:	bf fb 03 00 00       	mov    edi,0x3fb
ffff800000103b96:	e8 4e 02 00 00       	call   ffff800000103de9 <outb>
    outb (COM1 + R_FIFO , 0b11000001); // Enable FIFO and let trigger level 14
ffff800000103b9b:	be c1 00 00 00       	mov    esi,0xc1
ffff800000103ba0:	bf fa 03 00 00       	mov    edi,0x3fa
ffff800000103ba5:	e8 3f 02 00 00       	call   ffff800000103de9 <outb>

    outb (COM1 + R_MCR  , 0b11110);    // 开启环回,检测开始
ffff800000103baa:	be 1e 00 00 00       	mov    esi,0x1e
ffff800000103baf:	bf fc 03 00 00       	mov    edi,0x3fc
ffff800000103bb4:	e8 30 02 00 00       	call   ffff800000103de9 <outb>

    outb (COM1 + R_DATA , 0xae);
ffff800000103bb9:	be ae 00 00 00       	mov    esi,0xae
ffff800000103bbe:	bf f8 03 00 00       	mov    edi,0x3f8
ffff800000103bc3:	e8 21 02 00 00       	call   ffff800000103de9 <outb>
    if (inb (COM1 + R_DATA) != 0xae)
ffff800000103bc8:	bf f8 03 00 00       	mov    edi,0x3f8
ffff800000103bcd:	e8 fe 01 00 00       	call   ffff800000103dd0 <inb>
ffff800000103bd2:	3c ae                	cmp    al,0xae
ffff800000103bd4:	75 11                	jne    ffff800000103be7 <serial_init+0x9b>
    {
        return;
    }

    outb (COM1 + R_MCR, 0b100);        // 恢复 -> Out 1
ffff800000103bd6:	be 04 00 00 00       	mov    esi,0x4
ffff800000103bdb:	bf fc 03 00 00       	mov    edi,0x3fc
ffff800000103be0:	e8 04 02 00 00       	call   ffff800000103de9 <outb>
ffff800000103be5:	eb 01                	jmp    ffff800000103be8 <serial_init+0x9c>
        return;
ffff800000103be7:	90                   	nop
}
ffff800000103be8:	5d                   	pop    rbp
ffff800000103be9:	c3                   	ret

ffff800000103bea <input_clear>:

#include <irq.h>
#include <intr.h>

static void input_clear ()
{
ffff800000103bea:	55                   	push   rbp
ffff800000103beb:	48 89 e5             	mov    rbp,rsp
    while (inb(R_STAT) & S_IN_FULL) inb(R_DATA);
ffff800000103bee:	eb 0a                	jmp    ffff800000103bfa <input_clear+0x10>
ffff800000103bf0:	bf 60 00 00 00       	mov    edi,0x60
ffff800000103bf5:	e8 d6 01 00 00       	call   ffff800000103dd0 <inb>
ffff800000103bfa:	bf 64 00 00 00       	mov    edi,0x64
ffff800000103bff:	e8 cc 01 00 00       	call   ffff800000103dd0 <inb>
ffff800000103c04:	0f b6 c0             	movzx  eax,al
ffff800000103c07:	83 e0 01             	and    eax,0x1
ffff800000103c0a:	85 c0                	test   eax,eax
ffff800000103c0c:	75 e2                	jne    ffff800000103bf0 <input_clear+0x6>
}
ffff800000103c0e:	90                   	nop
ffff800000103c0f:	90                   	nop
ffff800000103c10:	5d                   	pop    rbp
ffff800000103c11:	c3                   	ret

ffff800000103c12 <keyboard_handler>:

__INTR_HANDLER (keyboard_handler)
{
ffff800000103c12:	55                   	push   rbp
ffff800000103c13:	48 89 e5             	mov    rbp,rsp
ffff800000103c16:	48 83 ec 30          	sub    rsp,0x30
ffff800000103c1a:	89 f8                	mov    eax,edi
ffff800000103c1c:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
ffff800000103c20:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
ffff800000103c24:	88 45 ec             	mov    BYTE PTR [rbp-0x14],al
    lapic_sendeoi();
ffff800000103c27:	b8 00 00 00 00       	mov    eax,0x0
ffff800000103c2c:	e8 7a cd ff ff       	call   ffff8000001009ab <lapic_sendeoi>

    u8 chr = 0;
ffff800000103c31:	c6 45 ff 00          	mov    BYTE PTR [rbp-0x1],0x0
    while (!(inb(R_STAT) & S_IN_FULL));
ffff800000103c35:	90                   	nop
ffff800000103c36:	bf 64 00 00 00       	mov    edi,0x64
ffff800000103c3b:	e8 90 01 00 00       	call   ffff800000103dd0 <inb>
ffff800000103c40:	0f b6 c0             	movzx  eax,al
ffff800000103c43:	83 e0 01             	and    eax,0x1
ffff800000103c46:	85 c0                	test   eax,eax
ffff800000103c48:	74 ec                	je     ffff800000103c36 <keyboard_handler+0x24>
    chr = inb(R_DATA);
ffff800000103c4a:	bf 60 00 00 00       	mov    edi,0x60
ffff800000103c4f:	e8 7c 01 00 00       	call   ffff800000103dd0 <inb>
ffff800000103c54:	88 45 ff             	mov    BYTE PTR [rbp-0x1],al

    DEBUGK ("pressed : %u\n", chr);
ffff800000103c57:	0f b6 45 ff          	movzx  eax,BYTE PTR [rbp-0x1]
ffff800000103c5b:	89 c1                	mov    ecx,eax
ffff800000103c5d:	48 8d 05 54 29 00 00 	lea    rax,[rip+0x2954]        # ffff8000001065b8 <lwstr+0x378>
ffff800000103c64:	48 89 c2             	mov    rdx,rax
ffff800000103c67:	be 39 00 00 00       	mov    esi,0x39
ffff800000103c6c:	48 8d 05 53 29 00 00 	lea    rax,[rip+0x2953]        # ffff8000001065c6 <lwstr+0x386>
ffff800000103c73:	48 89 c7             	mov    rdi,rax
ffff800000103c76:	b8 00 00 00 00       	mov    eax,0x0
ffff800000103c7b:	e8 42 c4 ff ff       	call   ffff8000001000c2 <debugk>
}
ffff800000103c80:	90                   	nop
ffff800000103c81:	c9                   	leave
ffff800000103c82:	c3                   	ret

ffff800000103c83 <keyboard_init>:

#include <textos/panic.h>

void keyboard_init ()
{
ffff800000103c83:	55                   	push   rbp
ffff800000103c84:	48 89 e5             	mov    rbp,rsp
    // 禁用所有设备
    outb(R_CMD, CMD_PORT1_OFF);
ffff800000103c87:	be ad 00 00 00       	mov    esi,0xad
ffff800000103c8c:	bf 64 00 00 00       	mov    edi,0x64
ffff800000103c91:	e8 53 01 00 00       	call   ffff800000103de9 <outb>
    outb(R_CMD, CMD_PORT2_OFF);
ffff800000103c96:	be a7 00 00 00       	mov    esi,0xa7
ffff800000103c9b:	bf 64 00 00 00       	mov    edi,0x64
ffff800000103ca0:	e8 44 01 00 00       	call   ffff800000103de9 <outb>

    input_clear();
ffff800000103ca5:	b8 00 00 00 00       	mov    eax,0x0
ffff800000103caa:	e8 3b ff ff ff       	call   ffff800000103bea <input_clear>

    // 自检,如果没有通过则不能进入系统.
    outb(R_CMD, CMD_PORT1_TEST);
ffff800000103caf:	be ab 00 00 00       	mov    esi,0xab
ffff800000103cb4:	bf 64 00 00 00       	mov    edi,0x64
ffff800000103cb9:	e8 2b 01 00 00       	call   ffff800000103de9 <outb>
    if (!(inb(R_STAT) & S_SYS))
ffff800000103cbe:	bf 64 00 00 00       	mov    edi,0x64
ffff800000103cc3:	e8 08 01 00 00       	call   ffff800000103dd0 <inb>
ffff800000103cc8:	0f b6 c0             	movzx  eax,al
ffff800000103ccb:	83 e0 04             	and    eax,0x4
ffff800000103cce:	85 c0                	test   eax,eax
ffff800000103cd0:	75 23                	jne    ffff800000103cf5 <keyboard_init+0x72>
        PANIC ("keyboard cannot pass self test!\n");
ffff800000103cd2:	48 8d 05 ff 28 00 00 	lea    rax,[rip+0x28ff]        # ffff8000001065d8 <lwstr+0x398>
ffff800000103cd9:	48 89 c2             	mov    rdx,rax
ffff800000103cdc:	be 49 00 00 00       	mov    esi,0x49
ffff800000103ce1:	48 8d 05 de 28 00 00 	lea    rax,[rip+0x28de]        # ffff8000001065c6 <lwstr+0x386>
ffff800000103ce8:	48 89 c7             	mov    rdi,rax
ffff800000103ceb:	b8 00 00 00 00       	mov    eax,0x0
ffff800000103cf0:	e8 f3 c4 ff ff       	call   ffff8000001001e8 <panic>
    
    input_clear();
ffff800000103cf5:	b8 00 00 00 00       	mov    eax,0x0
ffff800000103cfa:	e8 eb fe ff ff       	call   ffff800000103bea <input_clear>
    
    intr_register (INT_KEYBOARD, keyboard_handler);
ffff800000103cff:	48 8d 05 0c ff ff ff 	lea    rax,[rip+0xffffffffffffff0c]        # ffff800000103c12 <keyboard_handler>
ffff800000103d06:	48 89 c6             	mov    rsi,rax
ffff800000103d09:	bf 21 00 00 00       	mov    edi,0x21
ffff800000103d0e:	e8 cb 06 00 00       	call   ffff8000001043de <intr_register>
    ioapic_rteset (IRQ_KEYBOARD, _IOAPIC_RTE(INT_KEYBOARD));
ffff800000103d13:	be 21 00 00 00       	mov    esi,0x21
ffff800000103d18:	bf 01 00 00 00       	mov    edi,0x1
ffff800000103d1d:	e8 e7 cc ff ff       	call   ffff800000100a09 <ioapic_rteset>

    // 打开端口与中断
    outb(R_CMD, CMD_PORT1_ON);
ffff800000103d22:	be ae 00 00 00       	mov    esi,0xae
ffff800000103d27:	bf 64 00 00 00       	mov    edi,0x64
ffff800000103d2c:	e8 b8 00 00 00       	call   ffff800000103de9 <outb>
    outb(R_CMD, CMD_W_CTL);
ffff800000103d31:	be 60 00 00 00       	mov    esi,0x60
ffff800000103d36:	bf 64 00 00 00       	mov    edi,0x64
ffff800000103d3b:	e8 a9 00 00 00       	call   ffff800000103de9 <outb>
    outb(R_DATA, CTL_INT1_ON);
ffff800000103d40:	be 01 00 00 00       	mov    esi,0x1
ffff800000103d45:	bf 60 00 00 00       	mov    edi,0x60
ffff800000103d4a:	e8 9a 00 00 00       	call   ffff800000103de9 <outb>
}
ffff800000103d4f:	90                   	nop
ffff800000103d50:	5d                   	pop    rbp
ffff800000103d51:	c3                   	ret
ffff800000103d52:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
ffff800000103d59:	00 00 00 
ffff800000103d5c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

ffff800000103d60 <halt>:
ffff800000103d60:	f4                   	hlt
ffff800000103d61:	c3                   	ret

ffff800000103d62 <read_gdt>:
ffff800000103d62:	0f 01 07             	sgdt   [rdi]
ffff800000103d65:	c3                   	ret

ffff800000103d66 <load_gdt>:
ffff800000103d66:	0f 01 17             	lgdt   [rdi]
ffff800000103d69:	c3                   	ret

ffff800000103d6a <read_idt>:
ffff800000103d6a:	0f 01 0f             	sidt   [rdi]
ffff800000103d6d:	c3                   	ret

ffff800000103d6e <load_idt>:
ffff800000103d6e:	0f 01 1f             	lidt   [rdi]
ffff800000103d71:	c3                   	ret

ffff800000103d72 <reload_segs>:
ffff800000103d72:	66 b8 00 00          	mov    ax,0x0
ffff800000103d76:	8e d8                	mov    ds,eax
ffff800000103d78:	8e c0                	mov    es,eax
ffff800000103d7a:	8e e0                	mov    fs,eax
ffff800000103d7c:	8e e8                	mov    gs,eax
ffff800000103d7e:	48 89 e3             	mov    rbx,rsp
ffff800000103d81:	57                   	push   rdi
ffff800000103d82:	53                   	push   rbx
ffff800000103d83:	9c                   	pushf
ffff800000103d84:	56                   	push   rsi
ffff800000103d85:	48 8d 05 03 00 00 00 	lea    rax,[rip+0x3]        # ffff800000103d8f <reload_segs.ret>
ffff800000103d8c:	50                   	push   rax
ffff800000103d8d:	48 cf                	iretq

ffff800000103d8f <reload_segs.ret>:
ffff800000103d8f:	c3                   	ret

ffff800000103d90 <read_cr3>:
ffff800000103d90:	0f 20 d8             	mov    rax,cr3
ffff800000103d93:	c3                   	ret

ffff800000103d94 <write_cr3>:
ffff800000103d94:	0f 22 df             	mov    cr3,rdi
ffff800000103d97:	c3                   	ret

ffff800000103d98 <read_msr>:
ffff800000103d98:	89 f9                	mov    ecx,edi
ffff800000103d9a:	0f 32                	rdmsr
ffff800000103d9c:	48 c1 e2 20          	shl    rdx,0x20
ffff800000103da0:	48 09 d0             	or     rax,rdx
ffff800000103da3:	c3                   	ret

ffff800000103da4 <write_msr>:
ffff800000103da4:	89 f9                	mov    ecx,edi
ffff800000103da6:	89 f0                	mov    eax,esi
ffff800000103da8:	48 c1 ee 20          	shr    rsi,0x20
ffff800000103dac:	89 f2                	mov    edx,esi
ffff800000103dae:	0f 30                	wrmsr
ffff800000103db0:	c3                   	ret

ffff800000103db1 <__kstack_init>:
ffff800000103db1:	5b                   	pop    rbx
ffff800000103db2:	48 8d 05 67 d2 00 00 	lea    rax,[rip+0xd267]        # ffff800000111020 <exception_msg>
ffff800000103db9:	48 89 c5             	mov    rbp,rax
ffff800000103dbc:	48 89 c4             	mov    rsp,rax
ffff800000103dbf:	53                   	push   rbx
ffff800000103dc0:	c3                   	ret
ffff800000103dc1:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
ffff800000103dc8:	00 00 00 
ffff800000103dcb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

ffff800000103dd0 <inb>:
ffff800000103dd0:	48 31 c0             	xor    rax,rax
ffff800000103dd3:	66 89 fa             	mov    dx,di
ffff800000103dd6:	ec                   	in     al,dx
ffff800000103dd7:	c3                   	ret

ffff800000103dd8 <inw>:
ffff800000103dd8:	48 31 c0             	xor    rax,rax
ffff800000103ddb:	66 89 fa             	mov    dx,di
ffff800000103dde:	66 ed                	in     ax,dx
ffff800000103de0:	c3                   	ret

ffff800000103de1 <indw>:
ffff800000103de1:	48 31 c0             	xor    rax,rax
ffff800000103de4:	66 89 fa             	mov    dx,di
ffff800000103de7:	ed                   	in     eax,dx
ffff800000103de8:	c3                   	ret

ffff800000103de9 <outb>:
ffff800000103de9:	66 89 fa             	mov    dx,di
ffff800000103dec:	40 88 f0             	mov    al,sil
ffff800000103def:	ee                   	out    dx,al
ffff800000103df0:	c3                   	ret

ffff800000103df1 <outw>:
ffff800000103df1:	66 89 fa             	mov    dx,di
ffff800000103df4:	66 89 f0             	mov    ax,si
ffff800000103df7:	66 ef                	out    dx,ax
ffff800000103df9:	c3                   	ret

ffff800000103dfa <outdw>:
ffff800000103dfa:	66 89 fa             	mov    dx,di
ffff800000103dfd:	89 f0                	mov    eax,esi
ffff800000103dff:	ef                   	out    dx,eax
ffff800000103e00:	c3                   	ret

ffff800000103e01 <_gdt_set_entry>:

gdt_t gdts[GDT_MAX];
gdtr_t gdtr;

static void _gdt_set_entry (size_t i, u64 base, u32 limit, u8 access, u8 flgs)
{
ffff800000103e01:	55                   	push   rbp
ffff800000103e02:	48 89 e5             	mov    rbp,rsp
ffff800000103e05:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
ffff800000103e09:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
ffff800000103e0d:	89 55 dc             	mov    DWORD PTR [rbp-0x24],edx
ffff800000103e10:	89 c8                	mov    eax,ecx
ffff800000103e12:	44 89 c2             	mov    edx,r8d
ffff800000103e15:	88 45 d8             	mov    BYTE PTR [rbp-0x28],al
ffff800000103e18:	89 d0                	mov    eax,edx
ffff800000103e1a:	88 45 d4             	mov    BYTE PTR [rbp-0x2c],al
    gdt_t *entry = &gdts[i];
ffff800000103e1d:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000103e21:	48 8d 14 c5 00 00 00 	lea    rdx,[rax*8+0x0]
ffff800000103e28:	00 
ffff800000103e29:	48 8d 05 90 e4 00 00 	lea    rax,[rip+0xe490]        # ffff8000001122c0 <gdts>
ffff800000103e30:	48 01 d0             	add    rax,rdx
ffff800000103e33:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

    entry->base_low = base & 0xffffff;
ffff800000103e37:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000103e3b:	89 c2                	mov    edx,eax
ffff800000103e3d:	81 e2 ff ff ff 00    	and    edx,0xffffff
ffff800000103e43:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103e47:	89 d1                	mov    ecx,edx
ffff800000103e49:	0f b6 f1             	movzx  esi,cl
ffff800000103e4c:	0f b6 48 02          	movzx  ecx,BYTE PTR [rax+0x2]
ffff800000103e50:	83 e1 00             	and    ecx,0x0
ffff800000103e53:	09 f1                	or     ecx,esi
ffff800000103e55:	88 48 02             	mov    BYTE PTR [rax+0x2],cl
ffff800000103e58:	89 d1                	mov    ecx,edx
ffff800000103e5a:	c1 e9 08             	shr    ecx,0x8
ffff800000103e5d:	89 c9                	mov    ecx,ecx
ffff800000103e5f:	0f b6 f1             	movzx  esi,cl
ffff800000103e62:	0f b6 48 03          	movzx  ecx,BYTE PTR [rax+0x3]
ffff800000103e66:	83 e1 00             	and    ecx,0x0
ffff800000103e69:	09 f1                	or     ecx,esi
ffff800000103e6b:	88 48 03             	mov    BYTE PTR [rax+0x3],cl
ffff800000103e6e:	c1 ea 10             	shr    edx,0x10
ffff800000103e71:	89 d2                	mov    edx,edx
ffff800000103e73:	0f b6 ca             	movzx  ecx,dl
ffff800000103e76:	0f b6 50 04          	movzx  edx,BYTE PTR [rax+0x4]
ffff800000103e7a:	83 e2 00             	and    edx,0x0
ffff800000103e7d:	09 ca                	or     edx,ecx
ffff800000103e7f:	88 50 04             	mov    BYTE PTR [rax+0x4],dl
    entry->base_high = base >> 24 & 0xff;
ffff800000103e82:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000103e86:	48 c1 e8 18          	shr    rax,0x18
ffff800000103e8a:	89 c2                	mov    edx,eax
ffff800000103e8c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103e90:	88 50 07             	mov    BYTE PTR [rax+0x7],dl
    entry->limit_low = limit & 0xffff;
ffff800000103e93:	8b 45 dc             	mov    eax,DWORD PTR [rbp-0x24]
ffff800000103e96:	89 c2                	mov    edx,eax
ffff800000103e98:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103e9c:	0f b7 ca             	movzx  ecx,dx
ffff800000103e9f:	0f b6 f1             	movzx  esi,cl
ffff800000103ea2:	0f b6 08             	movzx  ecx,BYTE PTR [rax]
ffff800000103ea5:	83 e1 00             	and    ecx,0x0
ffff800000103ea8:	09 f1                	or     ecx,esi
ffff800000103eaa:	88 08                	mov    BYTE PTR [rax],cl
ffff800000103eac:	66 c1 ea 08          	shr    dx,0x8
ffff800000103eb0:	0f b7 ca             	movzx  ecx,dx
ffff800000103eb3:	0f b6 50 01          	movzx  edx,BYTE PTR [rax+0x1]
ffff800000103eb7:	83 e2 00             	and    edx,0x0
ffff800000103eba:	09 ca                	or     edx,ecx
ffff800000103ebc:	88 50 01             	mov    BYTE PTR [rax+0x1],dl
    entry->limit_high = limit >> 16 & 0xff;
ffff800000103ebf:	8b 45 dc             	mov    eax,DWORD PTR [rbp-0x24]
ffff800000103ec2:	c1 e8 10             	shr    eax,0x10
ffff800000103ec5:	83 e0 0f             	and    eax,0xf
ffff800000103ec8:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
ffff800000103ecc:	83 e0 0f             	and    eax,0xf
ffff800000103ecf:	89 c1                	mov    ecx,eax
ffff800000103ed1:	0f b6 42 06          	movzx  eax,BYTE PTR [rdx+0x6]
ffff800000103ed5:	83 e0 f0             	and    eax,0xfffffff0
ffff800000103ed8:	09 c8                	or     eax,ecx
ffff800000103eda:	88 42 06             	mov    BYTE PTR [rdx+0x6],al

    entry->flgs = flgs;
ffff800000103edd:	0f b6 45 d4          	movzx  eax,BYTE PTR [rbp-0x2c]
ffff800000103ee1:	83 e0 0f             	and    eax,0xf
ffff800000103ee4:	89 c2                	mov    edx,eax
ffff800000103ee6:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103eea:	89 d1                	mov    ecx,edx
ffff800000103eec:	c1 e1 04             	shl    ecx,0x4
ffff800000103eef:	0f b6 50 06          	movzx  edx,BYTE PTR [rax+0x6]
ffff800000103ef3:	83 e2 0f             	and    edx,0xf
ffff800000103ef6:	09 ca                	or     edx,ecx
ffff800000103ef8:	88 50 06             	mov    BYTE PTR [rax+0x6],dl
    entry->access.raw = access;
ffff800000103efb:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000103eff:	0f b6 55 d8          	movzx  edx,BYTE PTR [rbp-0x28]
ffff800000103f03:	88 50 05             	mov    BYTE PTR [rax+0x5],dl
}
ffff800000103f06:	90                   	nop
ffff800000103f07:	5d                   	pop    rbp
ffff800000103f08:	c3                   	ret

ffff800000103f09 <gdt_init>:

#define CODE_F (F_L | F_G)
#define DATA_F (F_DB | F_G)

void gdt_init ()
{
ffff800000103f09:	55                   	push   rbp
ffff800000103f0a:	48 89 e5             	mov    rbp,rsp
    memset (gdts, 0, GDT_MAX * sizeof (gdt_t));
ffff800000103f0d:	ba 80 00 00 00       	mov    edx,0x80
ffff800000103f12:	be 00 00 00 00       	mov    esi,0x0
ffff800000103f17:	48 8d 05 a2 e3 00 00 	lea    rax,[rip+0xe3a2]        # ffff8000001122c0 <gdts>
ffff800000103f1e:	48 89 c7             	mov    rdi,rax
ffff800000103f21:	e8 da d5 ff ff       	call   ffff800000101500 <memset>

    /* Keep the firt being 0 */

    _gdt_set_entry (KERN_CODE_SEG, 0, 0xFFFFF, KERN_CODE_A, CODE_F);
ffff800000103f26:	41 b8 0a 00 00 00    	mov    r8d,0xa
ffff800000103f2c:	b9 9a 00 00 00       	mov    ecx,0x9a
ffff800000103f31:	ba ff ff 0f 00       	mov    edx,0xfffff
ffff800000103f36:	be 00 00 00 00       	mov    esi,0x0
ffff800000103f3b:	bf 01 00 00 00       	mov    edi,0x1
ffff800000103f40:	e8 bc fe ff ff       	call   ffff800000103e01 <_gdt_set_entry>
    _gdt_set_entry (KERN_DATA_SEG, 0, 0xFFFFF, KERN_DATA_A, DATA_F);
ffff800000103f45:	41 b8 0c 00 00 00    	mov    r8d,0xc
ffff800000103f4b:	b9 92 00 00 00       	mov    ecx,0x92
ffff800000103f50:	ba ff ff 0f 00       	mov    edx,0xfffff
ffff800000103f55:	be 00 00 00 00       	mov    esi,0x0
ffff800000103f5a:	bf 02 00 00 00       	mov    edi,0x2
ffff800000103f5f:	e8 9d fe ff ff       	call   ffff800000103e01 <_gdt_set_entry>
    _gdt_set_entry (USER_CODE_SEG, 0, 0xFFFFF, USER_CODE_A, CODE_F);
ffff800000103f64:	41 b8 0a 00 00 00    	mov    r8d,0xa
ffff800000103f6a:	b9 fa 00 00 00       	mov    ecx,0xfa
ffff800000103f6f:	ba ff ff 0f 00       	mov    edx,0xfffff
ffff800000103f74:	be 00 00 00 00       	mov    esi,0x0
ffff800000103f79:	bf 03 00 00 00       	mov    edi,0x3
ffff800000103f7e:	e8 7e fe ff ff       	call   ffff800000103e01 <_gdt_set_entry>
    _gdt_set_entry (USER_DATA_SEG, 0, 0xFFFFF, USER_DATA_A, DATA_F);
ffff800000103f83:	41 b8 0c 00 00 00    	mov    r8d,0xc
ffff800000103f89:	b9 f2 00 00 00       	mov    ecx,0xf2
ffff800000103f8e:	ba ff ff 0f 00       	mov    edx,0xfffff
ffff800000103f93:	be 00 00 00 00       	mov    esi,0x0
ffff800000103f98:	bf 04 00 00 00       	mov    edi,0x4
ffff800000103f9d:	e8 5f fe ff ff       	call   ffff800000103e01 <_gdt_set_entry>

    gdtr.base = (u64)&gdts;
ffff800000103fa2:	48 8d 05 17 e3 00 00 	lea    rax,[rip+0xe317]        # ffff8000001122c0 <gdts>
ffff800000103fa9:	48 89 05 92 e3 00 00 	mov    QWORD PTR [rip+0xe392],rax        # ffff800000112342 <gdtr+0x2>
    gdtr.limit = GDT_MAX * sizeof(gdt_t);
ffff800000103fb0:	66 c7 05 87 e3 00 00 	mov    WORD PTR [rip+0xe387],0x80        # ffff800000112340 <gdtr>
ffff800000103fb7:	80 00 

    load_gdt (&gdtr);
ffff800000103fb9:	48 8d 05 80 e3 00 00 	lea    rax,[rip+0xe380]        # ffff800000112340 <gdtr>
ffff800000103fc0:	48 89 c7             	mov    rdi,rax
ffff800000103fc3:	e8 9e fd ff ff       	call   ffff800000103d66 <load_gdt>
    reload_segs (KERN_DATA_SEG << 3, KERN_CODE_SEG << 3);
ffff800000103fc8:	be 08 00 00 00       	mov    esi,0x8
ffff800000103fcd:	bf 10 00 00 00       	mov    edi,0x10
ffff800000103fd2:	e8 9b fd ff ff       	call   ffff800000103d72 <reload_segs>
}
ffff800000103fd7:	90                   	nop
ffff800000103fd8:	5d                   	pop    rbp
ffff800000103fd9:	c3                   	ret

ffff800000103fda <_idt_set_entry>:

static idt_t idts[HANDLER_MAX];
static idtr_t idtr;

static void _idt_set_entry (size_t i,u64 offset, u16 selector, u8 type, u8 dpl, u8 present)
{
ffff800000103fda:	55                   	push   rbp
ffff800000103fdb:	48 89 e5             	mov    rbp,rsp
ffff800000103fde:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
ffff800000103fe2:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
ffff800000103fe6:	89 c8                	mov    eax,ecx
ffff800000103fe8:	44 89 c6             	mov    esi,r8d
ffff800000103feb:	44 89 c9             	mov    ecx,r9d
ffff800000103fee:	66 89 55 dc          	mov    WORD PTR [rbp-0x24],dx
ffff800000103ff2:	88 45 d8             	mov    BYTE PTR [rbp-0x28],al
ffff800000103ff5:	89 f0                	mov    eax,esi
ffff800000103ff7:	88 45 d4             	mov    BYTE PTR [rbp-0x2c],al
ffff800000103ffa:	89 c8                	mov    eax,ecx
ffff800000103ffc:	88 45 d0             	mov    BYTE PTR [rbp-0x30],al
    idt_t *entry = &idts[i];
ffff800000103fff:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
ffff800000104003:	48 c1 e0 04          	shl    rax,0x4
ffff800000104007:	48 89 c2             	mov    rdx,rax
ffff80000010400a:	48 8d 05 4f eb 00 00 	lea    rax,[rip+0xeb4f]        # ffff800000112b60 <idts>
ffff800000104011:	48 01 d0             	add    rax,rdx
ffff800000104014:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

    entry->offset_low = offset & 0xffff;
ffff800000104018:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff80000010401c:	89 c2                	mov    edx,eax
ffff80000010401e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000104022:	0f b7 ca             	movzx  ecx,dx
ffff800000104025:	0f b6 f1             	movzx  esi,cl
ffff800000104028:	0f b6 08             	movzx  ecx,BYTE PTR [rax]
ffff80000010402b:	83 e1 00             	and    ecx,0x0
ffff80000010402e:	09 f1                	or     ecx,esi
ffff800000104030:	88 08                	mov    BYTE PTR [rax],cl
ffff800000104032:	66 c1 ea 08          	shr    dx,0x8
ffff800000104036:	0f b7 ca             	movzx  ecx,dx
ffff800000104039:	0f b6 50 01          	movzx  edx,BYTE PTR [rax+0x1]
ffff80000010403d:	83 e2 00             	and    edx,0x0
ffff800000104040:	09 ca                	or     edx,ecx
ffff800000104042:	88 50 01             	mov    BYTE PTR [rax+0x1],dl
    entry->offset_mid = offset >> 16 & 0xffff;
ffff800000104045:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff800000104049:	48 c1 e8 10          	shr    rax,0x10
ffff80000010404d:	89 c2                	mov    edx,eax
ffff80000010404f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000104053:	0f b7 ca             	movzx  ecx,dx
ffff800000104056:	0f b6 f1             	movzx  esi,cl
ffff800000104059:	0f b6 48 06          	movzx  ecx,BYTE PTR [rax+0x6]
ffff80000010405d:	83 e1 00             	and    ecx,0x0
ffff800000104060:	09 f1                	or     ecx,esi
ffff800000104062:	88 48 06             	mov    BYTE PTR [rax+0x6],cl
ffff800000104065:	66 c1 ea 08          	shr    dx,0x8
ffff800000104069:	0f b7 ca             	movzx  ecx,dx
ffff80000010406c:	0f b6 50 07          	movzx  edx,BYTE PTR [rax+0x7]
ffff800000104070:	83 e2 00             	and    edx,0x0
ffff800000104073:	09 ca                	or     edx,ecx
ffff800000104075:	88 50 07             	mov    BYTE PTR [rax+0x7],dl
    entry->offset_high = offset >> 32;
ffff800000104078:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
ffff80000010407c:	48 c1 e8 20          	shr    rax,0x20
ffff800000104080:	89 c2                	mov    edx,eax
ffff800000104082:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000104086:	89 d1                	mov    ecx,edx
ffff800000104088:	0f b6 f1             	movzx  esi,cl
ffff80000010408b:	0f b6 48 08          	movzx  ecx,BYTE PTR [rax+0x8]
ffff80000010408f:	83 e1 00             	and    ecx,0x0
ffff800000104092:	09 f1                	or     ecx,esi
ffff800000104094:	88 48 08             	mov    BYTE PTR [rax+0x8],cl
ffff800000104097:	89 d1                	mov    ecx,edx
ffff800000104099:	c1 e9 08             	shr    ecx,0x8
ffff80000010409c:	89 c9                	mov    ecx,ecx
ffff80000010409e:	0f b6 f1             	movzx  esi,cl
ffff8000001040a1:	0f b6 48 09          	movzx  ecx,BYTE PTR [rax+0x9]
ffff8000001040a5:	83 e1 00             	and    ecx,0x0
ffff8000001040a8:	09 f1                	or     ecx,esi
ffff8000001040aa:	88 48 09             	mov    BYTE PTR [rax+0x9],cl
ffff8000001040ad:	89 d1                	mov    ecx,edx
ffff8000001040af:	c1 e9 10             	shr    ecx,0x10
ffff8000001040b2:	89 c9                	mov    ecx,ecx
ffff8000001040b4:	0f b6 f1             	movzx  esi,cl
ffff8000001040b7:	0f b6 48 0a          	movzx  ecx,BYTE PTR [rax+0xa]
ffff8000001040bb:	83 e1 00             	and    ecx,0x0
ffff8000001040be:	09 f1                	or     ecx,esi
ffff8000001040c0:	88 48 0a             	mov    BYTE PTR [rax+0xa],cl
ffff8000001040c3:	c1 ea 18             	shr    edx,0x18
ffff8000001040c6:	89 d1                	mov    ecx,edx
ffff8000001040c8:	0f b6 50 0b          	movzx  edx,BYTE PTR [rax+0xb]
ffff8000001040cc:	83 e2 00             	and    edx,0x0
ffff8000001040cf:	09 ca                	or     edx,ecx
ffff8000001040d1:	88 50 0b             	mov    BYTE PTR [rax+0xb],dl
    entry->selector = selector;
ffff8000001040d4:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff8000001040d8:	0f b6 4d dc          	movzx  ecx,BYTE PTR [rbp-0x24]
ffff8000001040dc:	0f b6 50 02          	movzx  edx,BYTE PTR [rax+0x2]
ffff8000001040e0:	83 e2 00             	and    edx,0x0
ffff8000001040e3:	09 ca                	or     edx,ecx
ffff8000001040e5:	88 50 02             	mov    BYTE PTR [rax+0x2],dl
ffff8000001040e8:	0f b6 4d dd          	movzx  ecx,BYTE PTR [rbp-0x23]
ffff8000001040ec:	0f b6 50 03          	movzx  edx,BYTE PTR [rax+0x3]
ffff8000001040f0:	83 e2 00             	and    edx,0x0
ffff8000001040f3:	09 ca                	or     edx,ecx
ffff8000001040f5:	88 50 03             	mov    BYTE PTR [rax+0x3],dl

    entry->dpl  = dpl;
ffff8000001040f8:	0f b6 45 d4          	movzx  eax,BYTE PTR [rbp-0x2c]
ffff8000001040fc:	83 e0 03             	and    eax,0x3
ffff8000001040ff:	89 c2                	mov    edx,eax
ffff800000104101:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000104105:	83 e2 03             	and    edx,0x3
ffff800000104108:	89 d1                	mov    ecx,edx
ffff80000010410a:	c1 e1 05             	shl    ecx,0x5
ffff80000010410d:	0f b6 50 05          	movzx  edx,BYTE PTR [rax+0x5]
ffff800000104111:	83 e2 9f             	and    edx,0xffffff9f
ffff800000104114:	09 ca                	or     edx,ecx
ffff800000104116:	88 50 05             	mov    BYTE PTR [rax+0x5],dl
    entry->type = type;
ffff800000104119:	0f b6 45 d8          	movzx  eax,BYTE PTR [rbp-0x28]
ffff80000010411d:	83 e0 0f             	and    eax,0xf
ffff800000104120:	89 c2                	mov    edx,eax
ffff800000104122:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000104126:	89 d1                	mov    ecx,edx
ffff800000104128:	83 e1 0f             	and    ecx,0xf
ffff80000010412b:	0f b6 50 05          	movzx  edx,BYTE PTR [rax+0x5]
ffff80000010412f:	83 e2 f0             	and    edx,0xfffffff0
ffff800000104132:	09 ca                	or     edx,ecx
ffff800000104134:	88 50 05             	mov    BYTE PTR [rax+0x5],dl

    entry->ist  = 0;
ffff800000104137:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010413b:	0f b6 50 04          	movzx  edx,BYTE PTR [rax+0x4]
ffff80000010413f:	83 e2 fc             	and    edx,0xfffffffc
ffff800000104142:	88 50 04             	mov    BYTE PTR [rax+0x4],dl
    entry->present = 1;
ffff800000104145:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000104149:	0f b6 50 05          	movzx  edx,BYTE PTR [rax+0x5]
ffff80000010414d:	83 ca 80             	or     edx,0xffffff80
ffff800000104150:	88 50 05             	mov    BYTE PTR [rax+0x5],dl
}
ffff800000104153:	90                   	nop
ffff800000104154:	5d                   	pop    rbp
ffff800000104155:	c3                   	ret

ffff800000104156 <msgget>:

static const char *rev_msg  = "--- Intel reserved. Do not use\0";
static const char *user_msg = "--- User defined (Non-reserved) Interrupts\0";

static inline const char *msgget (u8 Vector)
{
ffff800000104156:	55                   	push   rbp
ffff800000104157:	48 89 e5             	mov    rbp,rsp
ffff80000010415a:	89 f8                	mov    eax,edi
ffff80000010415c:	88 45 fc             	mov    BYTE PTR [rbp-0x4],al
    if (Vector < 22)
ffff80000010415f:	80 7d fc 15          	cmp    BYTE PTR [rbp-0x4],0x15
ffff800000104163:	77 1b                	ja     ffff800000104180 <msgget+0x2a>
        return exception_msg[Vector];
ffff800000104165:	0f b6 45 fc          	movzx  eax,BYTE PTR [rbp-0x4]
ffff800000104169:	48 98                	cdqe
ffff80000010416b:	48 8d 14 c5 00 00 00 	lea    rdx,[rax*8+0x0]
ffff800000104172:	00 
ffff800000104173:	48 8d 05 a6 ce 00 00 	lea    rax,[rip+0xcea6]        # ffff800000111020 <exception_msg>
ffff80000010417a:	48 8b 04 02          	mov    rax,QWORD PTR [rdx+rax*1]
ffff80000010417e:	eb 16                	jmp    ffff800000104196 <msgget+0x40>
    else if (Vector > 31)
ffff800000104180:	80 7d fc 1f          	cmp    BYTE PTR [rbp-0x4],0x1f
ffff800000104184:	76 09                	jbe    ffff80000010418f <msgget+0x39>
        return user_msg;
ffff800000104186:	48 8b 05 4b cf 00 00 	mov    rax,QWORD PTR [rip+0xcf4b]        # ffff8000001110d8 <user_msg>
ffff80000010418d:	eb 07                	jmp    ffff800000104196 <msgget+0x40>

    return rev_msg;
ffff80000010418f:	48 8b 05 3a cf 00 00 	mov    rax,QWORD PTR [rip+0xcf3a]        # ffff8000001110d0 <rev_msg>
}
ffff800000104196:	5d                   	pop    rbp
ffff800000104197:	c3                   	ret

ffff800000104198 <intr_common>:

#include <io.h>
#include <irq.h>

__INTR_HANDLER (intr_common)
{
ffff800000104198:	55                   	push   rbp
ffff800000104199:	48 89 e5             	mov    rbp,rsp
ffff80000010419c:	48 83 ec 30          	sub    rsp,0x30
ffff8000001041a0:	89 f8                	mov    eax,edi
ffff8000001041a2:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
ffff8000001041a6:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
ffff8000001041aa:	88 45 ec             	mov    BYTE PTR [rbp-0x14],al
    printk ("intr occurred !!! - [%03x] %s ->\n", vector, msgget (vector));
ffff8000001041ad:	0f b6 45 ec          	movzx  eax,BYTE PTR [rbp-0x14]
ffff8000001041b1:	89 c7                	mov    edi,eax
ffff8000001041b3:	e8 9e ff ff ff       	call   ffff800000104156 <msgget>
ffff8000001041b8:	48 89 c2             	mov    rdx,rax
ffff8000001041bb:	0f b6 45 ec          	movzx  eax,BYTE PTR [rbp-0x14]
ffff8000001041bf:	89 c6                	mov    esi,eax
ffff8000001041c1:	48 8d 05 f8 26 00 00 	lea    rax,[rip+0x26f8]        # ffff8000001068c0 <lwstr+0x680>
ffff8000001041c8:	48 89 c7             	mov    rdi,rax
ffff8000001041cb:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001041d0:	e8 25 cb ff ff       	call   ffff800000100cfa <printk>
    printk ("  rax=%016llx rbx=%016llx rcx=%016llx rdx=%016llx\n", frame->rax, frame->rbx, frame->rcx, frame->rdx);
ffff8000001041d5:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001041d9:	48 8b 70 58          	mov    rsi,QWORD PTR [rax+0x58]
ffff8000001041dd:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001041e1:	48 8b 48 60          	mov    rcx,QWORD PTR [rax+0x60]
ffff8000001041e5:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001041e9:	48 8b 50 68          	mov    rdx,QWORD PTR [rax+0x68]
ffff8000001041ed:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001041f1:	48 8b 40 70          	mov    rax,QWORD PTR [rax+0x70]
ffff8000001041f5:	49 89 f0             	mov    r8,rsi
ffff8000001041f8:	48 89 c6             	mov    rsi,rax
ffff8000001041fb:	48 8d 05 e6 26 00 00 	lea    rax,[rip+0x26e6]        # ffff8000001068e8 <lwstr+0x6a8>
ffff800000104202:	48 89 c7             	mov    rdi,rax
ffff800000104205:	b8 00 00 00 00       	mov    eax,0x0
ffff80000010420a:	e8 eb ca ff ff       	call   ffff800000100cfa <printk>
    printk ("  rsi=%016llx rdi=%016llx rbp=%016llx rsp=%016llx\n", frame->rsi, frame->rdi, frame->rbp, frame->rsp);
ffff80000010420f:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000104213:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
ffff80000010421a:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff80000010421e:	48 8b 48 50          	mov    rcx,QWORD PTR [rax+0x50]
ffff800000104222:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000104226:	48 8b 50 40          	mov    rdx,QWORD PTR [rax+0x40]
ffff80000010422a:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff80000010422e:	48 8b 40 48          	mov    rax,QWORD PTR [rax+0x48]
ffff800000104232:	49 89 f0             	mov    r8,rsi
ffff800000104235:	48 89 c6             	mov    rsi,rax
ffff800000104238:	48 8d 05 e1 26 00 00 	lea    rax,[rip+0x26e1]        # ffff800000106920 <lwstr+0x6e0>
ffff80000010423f:	48 89 c7             	mov    rdi,rax
ffff800000104242:	b8 00 00 00 00       	mov    eax,0x0
ffff800000104247:	e8 ae ca ff ff       	call   ffff800000100cfa <printk>
    printk ("  r8 =%016llx r9 =%016llx r10=%016llx r11=%016llx\n", frame->r8 , frame->r9 , frame->r10, frame->r11);
ffff80000010424c:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000104250:	48 8b 70 20          	mov    rsi,QWORD PTR [rax+0x20]
ffff800000104254:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000104258:	48 8b 48 28          	mov    rcx,QWORD PTR [rax+0x28]
ffff80000010425c:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000104260:	48 8b 50 30          	mov    rdx,QWORD PTR [rax+0x30]
ffff800000104264:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000104268:	48 8b 40 38          	mov    rax,QWORD PTR [rax+0x38]
ffff80000010426c:	49 89 f0             	mov    r8,rsi
ffff80000010426f:	48 89 c6             	mov    rsi,rax
ffff800000104272:	48 8d 05 df 26 00 00 	lea    rax,[rip+0x26df]        # ffff800000106958 <lwstr+0x718>
ffff800000104279:	48 89 c7             	mov    rdi,rax
ffff80000010427c:	b8 00 00 00 00       	mov    eax,0x0
ffff800000104281:	e8 74 ca ff ff       	call   ffff800000100cfa <printk>
    printk ("  r12=%016llx r13=%016llx r14=%016llx r15=%016llx\n", frame->r12, frame->r13, frame->r14, frame->r15);
ffff800000104286:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff80000010428a:	48 8b 30             	mov    rsi,QWORD PTR [rax]
ffff80000010428d:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000104291:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
ffff800000104295:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff800000104299:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
ffff80000010429d:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001042a1:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
ffff8000001042a5:	49 89 f0             	mov    r8,rsi
ffff8000001042a8:	48 89 c6             	mov    rsi,rax
ffff8000001042ab:	48 8d 05 de 26 00 00 	lea    rax,[rip+0x26de]        # ffff800000106990 <lwstr+0x750>
ffff8000001042b2:	48 89 c7             	mov    rdi,rax
ffff8000001042b5:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001042ba:	e8 3b ca ff ff       	call   ffff800000100cfa <printk>
    printk ("  err=%016llx rip=%016llx rfl=%08llx\n", frame->rip, frame->rflags, errcode);
ffff8000001042bf:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001042c3:	48 8b 90 98 00 00 00 	mov    rdx,QWORD PTR [rax+0x98]
ffff8000001042ca:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
ffff8000001042ce:	48 8b 80 88 00 00 00 	mov    rax,QWORD PTR [rax+0x88]
ffff8000001042d5:	48 8b 4d e0          	mov    rcx,QWORD PTR [rbp-0x20]
ffff8000001042d9:	48 89 c6             	mov    rsi,rax
ffff8000001042dc:	48 8d 05 e5 26 00 00 	lea    rax,[rip+0x26e5]        # ffff8000001069c8 <lwstr+0x788>
ffff8000001042e3:	48 89 c7             	mov    rdi,rax
ffff8000001042e6:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001042eb:	e8 0a ca ff ff       	call   ffff800000100cfa <printk>
    printk ("<-\n");
ffff8000001042f0:	48 8d 05 f7 26 00 00 	lea    rax,[rip+0x26f7]        # ffff8000001069ee <lwstr+0x7ae>
ffff8000001042f7:	48 89 c7             	mov    rdi,rax
ffff8000001042fa:	b8 00 00 00 00       	mov    eax,0x0
ffff8000001042ff:	e8 f6 c9 ff ff       	call   ffff800000100cfa <printk>
    
    int r = 1;
ffff800000104304:	c7 45 fc 01 00 00 00 	mov    DWORD PTR [rbp-0x4],0x1
    if (vector != INT_TIMER)
ffff80000010430b:	80 7d ec 20          	cmp    BYTE PTR [rbp-0x14],0x20
ffff80000010430f:	74 0f                	je     ffff800000104320 <intr_common+0x188>
        outb(0xf4, 0x00);
ffff800000104311:	be 00 00 00 00       	mov    esi,0x0
ffff800000104316:	bf f4 00 00 00       	mov    edi,0xf4
ffff80000010431b:	e8 c9 fa ff ff       	call   ffff800000103de9 <outb>
}
ffff800000104320:	90                   	nop
ffff800000104321:	c9                   	leave
ffff800000104322:	c3                   	ret

ffff800000104323 <idt_init>:
extern u8 intr_entries; // a start point of the whole table

ihandler_t intr_handlers[HANDLER_MAX];

void idt_init ()
{
ffff800000104323:	55                   	push   rbp
ffff800000104324:	48 89 e5             	mov    rbp,rsp
ffff800000104327:	48 83 ec 10          	sub    rsp,0x10
    memset (idts, 0, HANDLER_MAX * sizeof(idt_t));
ffff80000010432b:	ba 00 10 00 00       	mov    edx,0x1000
ffff800000104330:	be 00 00 00 00       	mov    esi,0x0
ffff800000104335:	48 8d 05 24 e8 00 00 	lea    rax,[rip+0xe824]        # ffff800000112b60 <idts>
ffff80000010433c:	48 89 c7             	mov    rdi,rax
ffff80000010433f:	e8 bc d1 ff ff       	call   ffff800000101500 <memset>

    for (size_t i = 0 ; i < HANDLER_MAX ; i++)
ffff800000104344:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
ffff80000010434b:	00 
ffff80000010434c:	eb 5d                	jmp    ffff8000001043ab <idt_init+0x88>
    {
        _IDT_SET_ENTRY (i, (u64)(&intr_entries + ENTRY_SIZ * i));
ffff80000010434e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff800000104352:	48 c1 e0 04          	shl    rax,0x4
ffff800000104356:	48 89 c2             	mov    rdx,rax
ffff800000104359:	48 8d 05 15 01 00 00 	lea    rax,[rip+0x115]        # ffff800000104475 <..@7.head>
ffff800000104360:	48 01 d0             	add    rax,rdx
ffff800000104363:	48 89 c6             	mov    rsi,rax
ffff800000104366:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010436a:	41 b9 01 00 00 00    	mov    r9d,0x1
ffff800000104370:	41 b8 00 00 00 00    	mov    r8d,0x0
ffff800000104376:	b9 0e 00 00 00       	mov    ecx,0xe
ffff80000010437b:	ba 08 00 00 00       	mov    edx,0x8
ffff800000104380:	48 89 c7             	mov    rdi,rax
ffff800000104383:	e8 52 fc ff ff       	call   ffff800000103fda <_idt_set_entry>
        intr_handlers[i] = (ihandler_t)intr_common;
ffff800000104388:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
ffff80000010438c:	48 8d 14 c5 00 00 00 	lea    rdx,[rax*8+0x0]
ffff800000104393:	00 
ffff800000104394:	48 8d 05 c5 df 00 00 	lea    rax,[rip+0xdfc5]        # ffff800000112360 <intr_handlers>
ffff80000010439b:	48 8d 0d f6 fd ff ff 	lea    rcx,[rip+0xfffffffffffffdf6]        # ffff800000104198 <intr_common>
ffff8000001043a2:	48 89 0c 02          	mov    QWORD PTR [rdx+rax*1],rcx
    for (size_t i = 0 ; i < HANDLER_MAX ; i++)
ffff8000001043a6:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
ffff8000001043ab:	48 81 7d f8 ff 00 00 	cmp    QWORD PTR [rbp-0x8],0xff
ffff8000001043b2:	00 
ffff8000001043b3:	76 99                	jbe    ffff80000010434e <idt_init+0x2b>
    }

    idtr.base = (u64)&idts;
ffff8000001043b5:	48 8d 05 a4 e7 00 00 	lea    rax,[rip+0xe7a4]        # ffff800000112b60 <idts>
ffff8000001043bc:	48 89 05 9f f7 00 00 	mov    QWORD PTR [rip+0xf79f],rax        # ffff800000113b62 <idtr+0x2>
    idtr.limit = HANDLER_MAX * sizeof(idt_t) - 1;
ffff8000001043c3:	66 c7 05 94 f7 00 00 	mov    WORD PTR [rip+0xf794],0xfff        # ffff800000113b60 <idtr>
ffff8000001043ca:	ff 0f 

    load_idt (&idtr);
ffff8000001043cc:	48 8d 05 8d f7 00 00 	lea    rax,[rip+0xf78d]        # ffff800000113b60 <idtr>
ffff8000001043d3:	48 89 c7             	mov    rdi,rax
ffff8000001043d6:	e8 93 f9 ff ff       	call   ffff800000103d6e <load_idt>
}
ffff8000001043db:	90                   	nop
ffff8000001043dc:	c9                   	leave
ffff8000001043dd:	c3                   	ret

ffff8000001043de <intr_register>:

void intr_register (u8 vector, ihandler_t handler)
{
ffff8000001043de:	55                   	push   rbp
ffff8000001043df:	48 89 e5             	mov    rbp,rsp
ffff8000001043e2:	89 f8                	mov    eax,edi
ffff8000001043e4:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
ffff8000001043e8:	88 45 fc             	mov    BYTE PTR [rbp-0x4],al
    intr_handlers[vector] = handler;
ffff8000001043eb:	0f b6 45 fc          	movzx  eax,BYTE PTR [rbp-0x4]
ffff8000001043ef:	48 98                	cdqe
ffff8000001043f1:	48 8d 0c c5 00 00 00 	lea    rcx,[rax*8+0x0]
ffff8000001043f8:	00 
ffff8000001043f9:	48 8d 15 60 df 00 00 	lea    rdx,[rip+0xdf60]        # ffff800000112360 <intr_handlers>
ffff800000104400:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
ffff800000104404:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
}
ffff800000104408:	90                   	nop
ffff800000104409:	5d                   	pop    rbp
ffff80000010440a:	c3                   	ret
ffff80000010440b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

ffff800000104410 <timer_handler0>:
ffff800000104410:	48 b8 b0 80 00 00 00 	movabs rax,0xffffff00000080b0
ffff800000104417:	ff ff ff 
ffff80000010441a:	c7 00 00 00 00 00    	mov    DWORD PTR [rax],0x0
ffff800000104420:	c3                   	ret

ffff800000104421 <intr_caller>:
ffff800000104421:	50                   	push   rax
ffff800000104422:	53                   	push   rbx
ffff800000104423:	51                   	push   rcx
ffff800000104424:	52                   	push   rdx
ffff800000104425:	55                   	push   rbp
ffff800000104426:	56                   	push   rsi
ffff800000104427:	57                   	push   rdi
ffff800000104428:	41 50                	push   r8
ffff80000010442a:	41 51                	push   r9
ffff80000010442c:	41 52                	push   r10
ffff80000010442e:	41 53                	push   r11
ffff800000104430:	41 54                	push   r12
ffff800000104432:	41 55                	push   r13
ffff800000104434:	41 56                	push   r14
ffff800000104436:	41 57                	push   r15
ffff800000104438:	48 8b 7c 24 78       	mov    rdi,QWORD PTR [rsp+0x78]
ffff80000010443d:	48 8b b4 24 80 00 00 	mov    rsi,QWORD PTR [rsp+0x80]
ffff800000104444:	00 
ffff800000104445:	48 89 e2             	mov    rdx,rsp
ffff800000104448:	48 b8 60 23 11 00 00 	movabs rax,0xffff800000112360
ffff80000010444f:	80 ff ff 
ffff800000104452:	48 8d 04 f8          	lea    rax,[rax+rdi*8]
ffff800000104456:	ff 10                	call   QWORD PTR [rax]

ffff800000104458 <intr_exit>:
ffff800000104458:	41 5f                	pop    r15
ffff80000010445a:	41 5e                	pop    r14
ffff80000010445c:	41 5d                	pop    r13
ffff80000010445e:	41 5c                	pop    r12
ffff800000104460:	41 5b                	pop    r11
ffff800000104462:	41 5a                	pop    r10
ffff800000104464:	41 59                	pop    r9
ffff800000104466:	41 58                	pop    r8
ffff800000104468:	5f                   	pop    rdi
ffff800000104469:	5e                   	pop    rsi
ffff80000010446a:	5d                   	pop    rbp
ffff80000010446b:	5a                   	pop    rdx
ffff80000010446c:	59                   	pop    rcx
ffff80000010446d:	5b                   	pop    rbx
ffff80000010446e:	58                   	pop    rax
ffff80000010446f:	48 83 c4 10          	add    rsp,0x10
ffff800000104473:	48 cf                	iretq

ffff800000104475 <..@7.head>:
ffff800000104475:	68 1d 09 00 00 6a 00 eb a3 00 00 00 00 00 00 00     h....j..........

ffff800000104485 <..@9.head>:
ffff800000104485:	68 1d 09 00 00 6a 01 eb 93 00 00 00 00 00 00 00     h....j..........

ffff800000104495 <..@11.head>:
ffff800000104495:	68 1d 09 00 00 6a 02 eb 83 00 00 00 00 00 00 00     h....j..........

ffff8000001044a5 <..@13.head>:
ffff8000001044a5:	68 1d 09 00 00 6a 03 e9 70 ff ff ff 00 00 00 00     h....j..p.......

ffff8000001044b5 <..@15.head>:
ffff8000001044b5:	68 1d 09 00 00 6a 04 e9 60 ff ff ff 00 00 00 00     h....j..`.......

ffff8000001044c5 <..@17.head>:
ffff8000001044c5:	68 1d 09 00 00 6a 05 e9 50 ff ff ff 00 00 00 00     h....j..P.......

ffff8000001044d5 <..@19.head>:
ffff8000001044d5:	68 1d 09 00 00 6a 06 e9 40 ff ff ff 00 00 00 00     h....j..@.......

ffff8000001044e5 <..@21.head>:
ffff8000001044e5:	68 1d 09 00 00 6a 07 e9 30 ff ff ff 00 00 00 00     h....j..0.......

ffff8000001044f5 <..@23.head>:
ffff8000001044f5:	6a 08 e9 25 ff ff ff 00 00 00 00 00 00 00 00 00     j..%............

ffff800000104505 <..@25.head>:
ffff800000104505:	68 1d 09 00 00 6a 09 e9 10 ff ff ff 00 00 00 00     h....j..........

ffff800000104515 <..@27.head>:
ffff800000104515:	6a 0a e9 05 ff ff ff 00 00 00 00 00 00 00 00 00     j...............

ffff800000104525 <..@29.head>:
ffff800000104525:	6a 0b e9 f5 fe ff ff 00 00 00 00 00 00 00 00 00     j...............

ffff800000104535 <..@31.head>:
ffff800000104535:	6a 0c e9 e5 fe ff ff 00 00 00 00 00 00 00 00 00     j...............

ffff800000104545 <..@33.head>:
ffff800000104545:	6a 0d e9 d5 fe ff ff 00 00 00 00 00 00 00 00 00     j...............

ffff800000104555 <..@35.head>:
ffff800000104555:	6a 0e e9 c5 fe ff ff 00 00 00 00 00 00 00 00 00     j...............

ffff800000104565 <..@37.head>:
ffff800000104565:	68 1d 09 00 00 6a 0f e9 b0 fe ff ff 00 00 00 00     h....j..........

ffff800000104575 <..@39.head>:
ffff800000104575:	68 1d 09 00 00 6a 10 e9 a0 fe ff ff 00 00 00 00     h....j..........

ffff800000104585 <..@41.head>:
ffff800000104585:	6a 11 e9 95 fe ff ff 00 00 00 00 00 00 00 00 00     j...............

ffff800000104595 <..@43.head>:
ffff800000104595:	68 1d 09 00 00 6a 12 e9 80 fe ff ff 00 00 00 00     h....j..........

ffff8000001045a5 <..@45.head>:
ffff8000001045a5:	68 1d 09 00 00 6a 13 e9 70 fe ff ff 00 00 00 00     h....j..p.......

ffff8000001045b5 <..@47.head>:
ffff8000001045b5:	68 1d 09 00 00 6a 14 e9 60 fe ff ff 00 00 00 00     h....j..`.......

ffff8000001045c5 <..@49.head>:
ffff8000001045c5:	6a 15 e9 55 fe ff ff 00 00 00 00 00 00 00 00 00     j..U............

ffff8000001045d5 <..@51.head>:
ffff8000001045d5:	68 1d 09 00 00 6a 16 e9 40 fe ff ff 00 00 00 00     h....j..@.......

ffff8000001045e5 <..@53.head>:
ffff8000001045e5:	68 1d 09 00 00 6a 17 e9 30 fe ff ff 00 00 00 00     h....j..0.......

ffff8000001045f5 <..@55.head>:
ffff8000001045f5:	68 1d 09 00 00 6a 18 e9 20 fe ff ff 00 00 00 00     h....j.. .......

ffff800000104605 <..@57.head>:
ffff800000104605:	68 1d 09 00 00 6a 19 e9 10 fe ff ff 00 00 00 00     h....j..........

ffff800000104615 <..@59.head>:
ffff800000104615:	68 1d 09 00 00 6a 1a e9 00 fe ff ff 00 00 00 00     h....j..........

ffff800000104625 <..@61.head>:
ffff800000104625:	68 1d 09 00 00 6a 1b e9 f0 fd ff ff 00 00 00 00     h....j..........

ffff800000104635 <..@63.head>:
ffff800000104635:	68 1d 09 00 00 6a 1c e9 e0 fd ff ff 00 00 00 00     h....j..........

ffff800000104645 <..@65.head>:
ffff800000104645:	68 1d 09 00 00 6a 1d e9 d0 fd ff ff 00 00 00 00     h....j..........

ffff800000104655 <..@67.head>:
ffff800000104655:	68 1d 09 00 00 6a 1e e9 c0 fd ff ff 00 00 00 00     h....j..........

ffff800000104665 <..@69.head>:
ffff800000104665:	68 1d 09 00 00 6a 1f e9 b0 fd ff ff 00 00 00 00     h....j..........

ffff800000104675 <..@71.head>:
ffff800000104675:	68 1d 09 00 00 6a 20 e9 a0 fd ff ff 00 00 00 00     h....j .........

ffff800000104685 <..@73.head>:
ffff800000104685:	68 1d 09 00 00 6a 21 e9 90 fd ff ff 00 00 00 00     h....j!.........

ffff800000104695 <..@75.head>:
ffff800000104695:	68 1d 09 00 00 6a 22 e9 80 fd ff ff 00 00 00 00     h....j".........

ffff8000001046a5 <..@77.head>:
ffff8000001046a5:	68 1d 09 00 00 6a 23 e9 70 fd ff ff 00 00 00 00     h....j#.p.......

ffff8000001046b5 <..@79.head>:
ffff8000001046b5:	68 1d 09 00 00 6a 24 e9 60 fd ff ff 00 00 00 00     h....j$.`.......

ffff8000001046c5 <..@81.head>:
ffff8000001046c5:	68 1d 09 00 00 6a 25 e9 50 fd ff ff 00 00 00 00     h....j%.P.......

ffff8000001046d5 <..@83.head>:
ffff8000001046d5:	68 1d 09 00 00 6a 26 e9 40 fd ff ff 00 00 00 00     h....j&.@.......

ffff8000001046e5 <..@85.head>:
ffff8000001046e5:	68 1d 09 00 00 6a 27 e9 30 fd ff ff 00 00 00 00     h....j'.0.......

ffff8000001046f5 <..@87.head>:
ffff8000001046f5:	68 1d 09 00 00 6a 28 e9 20 fd ff ff 00 00 00 00     h....j(. .......

ffff800000104705 <..@89.head>:
ffff800000104705:	68 1d 09 00 00 6a 29 e9 10 fd ff ff 00 00 00 00     h....j).........

ffff800000104715 <..@91.head>:
ffff800000104715:	68 1d 09 00 00 6a 2a e9 00 fd ff ff 00 00 00 00     h....j*.........

ffff800000104725 <..@93.head>:
ffff800000104725:	68 1d 09 00 00 6a 2b e9 f0 fc ff ff 00 00 00 00     h....j+.........

ffff800000104735 <..@95.head>:
ffff800000104735:	68 1d 09 00 00 6a 2c e9 e0 fc ff ff 00 00 00 00     h....j,.........

ffff800000104745 <..@97.head>:
ffff800000104745:	68 1d 09 00 00 6a 2d e9 d0 fc ff ff 00 00 00 00     h....j-.........

ffff800000104755 <..@99.head>:
ffff800000104755:	68 1d 09 00 00 6a 2e e9 c0 fc ff ff 00 00 00 00     h....j..........

ffff800000104765 <..@101.head>:
ffff800000104765:	68 1d 09 00 00 6a 2f e9 b0 fc ff ff 00 00 00 00     h....j/.........

ffff800000104775 <..@103.head>:
ffff800000104775:	68 1d 09 00 00 6a 30 e9 a0 fc ff ff 00 00 00 00     h....j0.........

ffff800000104785 <..@105.head>:
ffff800000104785:	68 1d 09 00 00 6a 31 e9 90 fc ff ff 00 00 00 00     h....j1.........

ffff800000104795 <..@107.head>:
ffff800000104795:	68 1d 09 00 00 6a 32 e9 80 fc ff ff 00 00 00 00     h....j2.........

ffff8000001047a5 <..@109.head>:
ffff8000001047a5:	68 1d 09 00 00 6a 33 e9 70 fc ff ff 00 00 00 00     h....j3.p.......

ffff8000001047b5 <..@111.head>:
ffff8000001047b5:	68 1d 09 00 00 6a 34 e9 60 fc ff ff 00 00 00 00     h....j4.`.......

ffff8000001047c5 <..@113.head>:
ffff8000001047c5:	68 1d 09 00 00 6a 35 e9 50 fc ff ff 00 00 00 00     h....j5.P.......

ffff8000001047d5 <..@115.head>:
ffff8000001047d5:	68 1d 09 00 00 6a 36 e9 40 fc ff ff 00 00 00 00     h....j6.@.......

ffff8000001047e5 <..@117.head>:
ffff8000001047e5:	68 1d 09 00 00 6a 37 e9 30 fc ff ff 00 00 00 00     h....j7.0.......

ffff8000001047f5 <..@119.head>:
ffff8000001047f5:	68 1d 09 00 00 6a 38 e9 20 fc ff ff 00 00 00 00     h....j8. .......

ffff800000104805 <..@121.head>:
ffff800000104805:	68 1d 09 00 00 6a 39 e9 10 fc ff ff 00 00 00 00     h....j9.........

ffff800000104815 <..@123.head>:
ffff800000104815:	68 1d 09 00 00 6a 3a e9 00 fc ff ff 00 00 00 00     h....j:.........

ffff800000104825 <..@125.head>:
ffff800000104825:	68 1d 09 00 00 6a 3b e9 f0 fb ff ff 00 00 00 00     h....j;.........

ffff800000104835 <..@127.head>:
ffff800000104835:	68 1d 09 00 00 6a 3c e9 e0 fb ff ff 00 00 00 00     h....j<.........

ffff800000104845 <..@129.head>:
ffff800000104845:	68 1d 09 00 00 6a 3d e9 d0 fb ff ff 00 00 00 00     h....j=.........

ffff800000104855 <..@131.head>:
ffff800000104855:	68 1d 09 00 00 6a 3e e9 c0 fb ff ff 00 00 00 00     h....j>.........

ffff800000104865 <..@133.head>:
ffff800000104865:	68 1d 09 00 00 6a 3f e9 b0 fb ff ff 00 00 00 00     h....j?.........

ffff800000104875 <..@135.head>:
ffff800000104875:	68 1d 09 00 00 6a 40 e9 a0 fb ff ff 00 00 00 00     h....j@.........

ffff800000104885 <..@137.head>:
ffff800000104885:	68 1d 09 00 00 6a 41 e9 90 fb ff ff 00 00 00 00     h....jA.........

ffff800000104895 <..@139.head>:
ffff800000104895:	68 1d 09 00 00 6a 42 e9 80 fb ff ff 00 00 00 00     h....jB.........

ffff8000001048a5 <..@141.head>:
ffff8000001048a5:	68 1d 09 00 00 6a 43 e9 70 fb ff ff 00 00 00 00     h....jC.p.......

ffff8000001048b5 <..@143.head>:
ffff8000001048b5:	68 1d 09 00 00 6a 44 e9 60 fb ff ff 00 00 00 00     h....jD.`.......

ffff8000001048c5 <..@145.head>:
ffff8000001048c5:	68 1d 09 00 00 6a 45 e9 50 fb ff ff 00 00 00 00     h....jE.P.......

ffff8000001048d5 <..@147.head>:
ffff8000001048d5:	68 1d 09 00 00 6a 46 e9 40 fb ff ff 00 00 00 00     h....jF.@.......

ffff8000001048e5 <..@149.head>:
ffff8000001048e5:	68 1d 09 00 00 6a 47 e9 30 fb ff ff 00 00 00 00     h....jG.0.......

ffff8000001048f5 <..@151.head>:
ffff8000001048f5:	68 1d 09 00 00 6a 48 e9 20 fb ff ff 00 00 00 00     h....jH. .......

ffff800000104905 <..@153.head>:
ffff800000104905:	68 1d 09 00 00 6a 49 e9 10 fb ff ff 00 00 00 00     h....jI.........

ffff800000104915 <..@155.head>:
ffff800000104915:	68 1d 09 00 00 6a 4a e9 00 fb ff ff 00 00 00 00     h....jJ.........

ffff800000104925 <..@157.head>:
ffff800000104925:	68 1d 09 00 00 6a 4b e9 f0 fa ff ff 00 00 00 00     h....jK.........

ffff800000104935 <..@159.head>:
ffff800000104935:	68 1d 09 00 00 6a 4c e9 e0 fa ff ff 00 00 00 00     h....jL.........

ffff800000104945 <..@161.head>:
ffff800000104945:	68 1d 09 00 00 6a 4d e9 d0 fa ff ff 00 00 00 00     h....jM.........

ffff800000104955 <..@163.head>:
ffff800000104955:	68 1d 09 00 00 6a 4e e9 c0 fa ff ff 00 00 00 00     h....jN.........

ffff800000104965 <..@165.head>:
ffff800000104965:	68 1d 09 00 00 6a 4f e9 b0 fa ff ff 00 00 00 00     h....jO.........

ffff800000104975 <..@167.head>:
ffff800000104975:	68 1d 09 00 00 6a 50 e9 a0 fa ff ff 00 00 00 00     h....jP.........

ffff800000104985 <..@169.head>:
ffff800000104985:	68 1d 09 00 00 6a 51 e9 90 fa ff ff 00 00 00 00     h....jQ.........

ffff800000104995 <..@171.head>:
ffff800000104995:	68 1d 09 00 00 6a 52 e9 80 fa ff ff 00 00 00 00     h....jR.........

ffff8000001049a5 <..@173.head>:
ffff8000001049a5:	68 1d 09 00 00 6a 53 e9 70 fa ff ff 00 00 00 00     h....jS.p.......

ffff8000001049b5 <..@175.head>:
ffff8000001049b5:	68 1d 09 00 00 6a 54 e9 60 fa ff ff 00 00 00 00     h....jT.`.......

ffff8000001049c5 <..@177.head>:
ffff8000001049c5:	68 1d 09 00 00 6a 55 e9 50 fa ff ff 00 00 00 00     h....jU.P.......

ffff8000001049d5 <..@179.head>:
ffff8000001049d5:	68 1d 09 00 00 6a 56 e9 40 fa ff ff 00 00 00 00     h....jV.@.......

ffff8000001049e5 <..@181.head>:
ffff8000001049e5:	68 1d 09 00 00 6a 57 e9 30 fa ff ff 00 00 00 00     h....jW.0.......

ffff8000001049f5 <..@183.head>:
ffff8000001049f5:	68 1d 09 00 00 6a 58 e9 20 fa ff ff 00 00 00 00     h....jX. .......

ffff800000104a05 <..@185.head>:
ffff800000104a05:	68 1d 09 00 00 6a 59 e9 10 fa ff ff 00 00 00 00     h....jY.........

ffff800000104a15 <..@187.head>:
ffff800000104a15:	68 1d 09 00 00 6a 5a e9 00 fa ff ff 00 00 00 00     h....jZ.........

ffff800000104a25 <..@189.head>:
ffff800000104a25:	68 1d 09 00 00 6a 5b e9 f0 f9 ff ff 00 00 00 00     h....j[.........

ffff800000104a35 <..@191.head>:
ffff800000104a35:	68 1d 09 00 00 6a 5c e9 e0 f9 ff ff 00 00 00 00     h....j\.........

ffff800000104a45 <..@193.head>:
ffff800000104a45:	68 1d 09 00 00 6a 5d e9 d0 f9 ff ff 00 00 00 00     h....j].........

ffff800000104a55 <..@195.head>:
ffff800000104a55:	68 1d 09 00 00 6a 5e e9 c0 f9 ff ff 00 00 00 00     h....j^.........

ffff800000104a65 <..@197.head>:
ffff800000104a65:	68 1d 09 00 00 6a 5f e9 b0 f9 ff ff 00 00 00 00     h....j_.........

ffff800000104a75 <..@199.head>:
ffff800000104a75:	68 1d 09 00 00 6a 60 e9 a0 f9 ff ff 00 00 00 00     h....j`.........

ffff800000104a85 <..@201.head>:
ffff800000104a85:	68 1d 09 00 00 6a 61 e9 90 f9 ff ff 00 00 00 00     h....ja.........

ffff800000104a95 <..@203.head>:
ffff800000104a95:	68 1d 09 00 00 6a 62 e9 80 f9 ff ff 00 00 00 00     h....jb.........

ffff800000104aa5 <..@205.head>:
ffff800000104aa5:	68 1d 09 00 00 6a 63 e9 70 f9 ff ff 00 00 00 00     h....jc.p.......

ffff800000104ab5 <..@207.head>:
ffff800000104ab5:	68 1d 09 00 00 6a 64 e9 60 f9 ff ff 00 00 00 00     h....jd.`.......

ffff800000104ac5 <..@209.head>:
ffff800000104ac5:	68 1d 09 00 00 6a 65 e9 50 f9 ff ff 00 00 00 00     h....je.P.......

ffff800000104ad5 <..@211.head>:
ffff800000104ad5:	68 1d 09 00 00 6a 66 e9 40 f9 ff ff 00 00 00 00     h....jf.@.......

ffff800000104ae5 <..@213.head>:
ffff800000104ae5:	68 1d 09 00 00 6a 67 e9 30 f9 ff ff 00 00 00 00     h....jg.0.......

ffff800000104af5 <..@215.head>:
ffff800000104af5:	68 1d 09 00 00 6a 68 e9 20 f9 ff ff 00 00 00 00     h....jh. .......

ffff800000104b05 <..@217.head>:
ffff800000104b05:	68 1d 09 00 00 6a 69 e9 10 f9 ff ff 00 00 00 00     h....ji.........

ffff800000104b15 <..@219.head>:
ffff800000104b15:	68 1d 09 00 00 6a 6a e9 00 f9 ff ff 00 00 00 00     h....jj.........

ffff800000104b25 <..@221.head>:
ffff800000104b25:	68 1d 09 00 00 6a 6b e9 f0 f8 ff ff 00 00 00 00     h....jk.........

ffff800000104b35 <..@223.head>:
ffff800000104b35:	68 1d 09 00 00 6a 6c e9 e0 f8 ff ff 00 00 00 00     h....jl.........

ffff800000104b45 <..@225.head>:
ffff800000104b45:	68 1d 09 00 00 6a 6d e9 d0 f8 ff ff 00 00 00 00     h....jm.........

ffff800000104b55 <..@227.head>:
ffff800000104b55:	68 1d 09 00 00 6a 6e e9 c0 f8 ff ff 00 00 00 00     h....jn.........

ffff800000104b65 <..@229.head>:
ffff800000104b65:	68 1d 09 00 00 6a 6f e9 b0 f8 ff ff 00 00 00 00     h....jo.........

ffff800000104b75 <..@231.head>:
ffff800000104b75:	68 1d 09 00 00 6a 70 e9 a0 f8 ff ff 00 00 00 00     h....jp.........

ffff800000104b85 <..@233.head>:
ffff800000104b85:	68 1d 09 00 00 6a 71 e9 90 f8 ff ff 00 00 00 00     h....jq.........

ffff800000104b95 <..@235.head>:
ffff800000104b95:	68 1d 09 00 00 6a 72 e9 80 f8 ff ff 00 00 00 00     h....jr.........

ffff800000104ba5 <..@237.head>:
ffff800000104ba5:	68 1d 09 00 00 6a 73 e9 70 f8 ff ff 00 00 00 00     h....js.p.......

ffff800000104bb5 <..@239.head>:
ffff800000104bb5:	68 1d 09 00 00 6a 74 e9 60 f8 ff ff 00 00 00 00     h....jt.`.......

ffff800000104bc5 <..@241.head>:
ffff800000104bc5:	68 1d 09 00 00 6a 75 e9 50 f8 ff ff 00 00 00 00     h....ju.P.......

ffff800000104bd5 <..@243.head>:
ffff800000104bd5:	68 1d 09 00 00 6a 76 e9 40 f8 ff ff 00 00 00 00     h....jv.@.......

ffff800000104be5 <..@245.head>:
ffff800000104be5:	68 1d 09 00 00 6a 77 e9 30 f8 ff ff 00 00 00 00     h....jw.0.......

ffff800000104bf5 <..@247.head>:
ffff800000104bf5:	68 1d 09 00 00 6a 78 e9 20 f8 ff ff 00 00 00 00     h....jx. .......

ffff800000104c05 <..@249.head>:
ffff800000104c05:	68 1d 09 00 00 6a 79 e9 10 f8 ff ff 00 00 00 00     h....jy.........

ffff800000104c15 <..@251.head>:
ffff800000104c15:	68 1d 09 00 00 6a 7a e9 00 f8 ff ff 00 00 00 00     h....jz.........

ffff800000104c25 <..@253.head>:
ffff800000104c25:	68 1d 09 00 00 6a 7b e9 f0 f7 ff ff 00 00 00 00     h....j{.........

ffff800000104c35 <..@255.head>:
ffff800000104c35:	68 1d 09 00 00 6a 7c e9 e0 f7 ff ff 00 00 00 00     h....j|.........

ffff800000104c45 <..@257.head>:
ffff800000104c45:	68 1d 09 00 00 6a 7d e9 d0 f7 ff ff 00 00 00 00     h....j}.........

ffff800000104c55 <..@259.head>:
ffff800000104c55:	68 1d 09 00 00 6a 7e e9 c0 f7 ff ff 00 00 00 00     h....j~.........

ffff800000104c65 <..@261.head>:
ffff800000104c65:	68 1d 09 00 00 6a 7f e9 b0 f7 ff ff 00 00 00 00     h....j..........

ffff800000104c75 <..@263.head>:
ffff800000104c75:	68 1d 09 00 00 68 80 00 00 00 e9 9d f7 ff ff 00     h....h..........

ffff800000104c85 <..@265.head>:
ffff800000104c85:	68 1d 09 00 00 68 81 00 00 00 e9 8d f7 ff ff 00     h....h..........

ffff800000104c95 <..@267.head>:
ffff800000104c95:	68 1d 09 00 00 68 82 00 00 00 e9 7d f7 ff ff 00     h....h.....}....

ffff800000104ca5 <..@269.head>:
ffff800000104ca5:	68 1d 09 00 00 68 83 00 00 00 e9 6d f7 ff ff 00     h....h.....m....

ffff800000104cb5 <..@271.head>:
ffff800000104cb5:	68 1d 09 00 00 68 84 00 00 00 e9 5d f7 ff ff 00     h....h.....]....

ffff800000104cc5 <..@273.head>:
ffff800000104cc5:	68 1d 09 00 00 68 85 00 00 00 e9 4d f7 ff ff 00     h....h.....M....

ffff800000104cd5 <..@275.head>:
ffff800000104cd5:	68 1d 09 00 00 68 86 00 00 00 e9 3d f7 ff ff 00     h....h.....=....

ffff800000104ce5 <..@277.head>:
ffff800000104ce5:	68 1d 09 00 00 68 87 00 00 00 e9 2d f7 ff ff 00     h....h.....-....

ffff800000104cf5 <..@279.head>:
ffff800000104cf5:	68 1d 09 00 00 68 88 00 00 00 e9 1d f7 ff ff 00     h....h..........

ffff800000104d05 <..@281.head>:
ffff800000104d05:	68 1d 09 00 00 68 89 00 00 00 e9 0d f7 ff ff 00     h....h..........

ffff800000104d15 <..@283.head>:
ffff800000104d15:	68 1d 09 00 00 68 8a 00 00 00 e9 fd f6 ff ff 00     h....h..........

ffff800000104d25 <..@285.head>:
ffff800000104d25:	68 1d 09 00 00 68 8b 00 00 00 e9 ed f6 ff ff 00     h....h..........

ffff800000104d35 <..@287.head>:
ffff800000104d35:	68 1d 09 00 00 68 8c 00 00 00 e9 dd f6 ff ff 00     h....h..........

ffff800000104d45 <..@289.head>:
ffff800000104d45:	68 1d 09 00 00 68 8d 00 00 00 e9 cd f6 ff ff 00     h....h..........

ffff800000104d55 <..@291.head>:
ffff800000104d55:	68 1d 09 00 00 68 8e 00 00 00 e9 bd f6 ff ff 00     h....h..........

ffff800000104d65 <..@293.head>:
ffff800000104d65:	68 1d 09 00 00 68 8f 00 00 00 e9 ad f6 ff ff 00     h....h..........

ffff800000104d75 <..@295.head>:
ffff800000104d75:	68 1d 09 00 00 68 90 00 00 00 e9 9d f6 ff ff 00     h....h..........

ffff800000104d85 <..@297.head>:
ffff800000104d85:	68 1d 09 00 00 68 91 00 00 00 e9 8d f6 ff ff 00     h....h..........

ffff800000104d95 <..@299.head>:
ffff800000104d95:	68 1d 09 00 00 68 92 00 00 00 e9 7d f6 ff ff 00     h....h.....}....

ffff800000104da5 <..@301.head>:
ffff800000104da5:	68 1d 09 00 00 68 93 00 00 00 e9 6d f6 ff ff 00     h....h.....m....

ffff800000104db5 <..@303.head>:
ffff800000104db5:	68 1d 09 00 00 68 94 00 00 00 e9 5d f6 ff ff 00     h....h.....]....

ffff800000104dc5 <..@305.head>:
ffff800000104dc5:	68 1d 09 00 00 68 95 00 00 00 e9 4d f6 ff ff 00     h....h.....M....

ffff800000104dd5 <..@307.head>:
ffff800000104dd5:	68 1d 09 00 00 68 96 00 00 00 e9 3d f6 ff ff 00     h....h.....=....

ffff800000104de5 <..@309.head>:
ffff800000104de5:	68 1d 09 00 00 68 97 00 00 00 e9 2d f6 ff ff 00     h....h.....-....

ffff800000104df5 <..@311.head>:
ffff800000104df5:	68 1d 09 00 00 68 98 00 00 00 e9 1d f6 ff ff 00     h....h..........

ffff800000104e05 <..@313.head>:
ffff800000104e05:	68 1d 09 00 00 68 99 00 00 00 e9 0d f6 ff ff 00     h....h..........

ffff800000104e15 <..@315.head>:
ffff800000104e15:	68 1d 09 00 00 68 9a 00 00 00 e9 fd f5 ff ff 00     h....h..........

ffff800000104e25 <..@317.head>:
ffff800000104e25:	68 1d 09 00 00 68 9b 00 00 00 e9 ed f5 ff ff 00     h....h..........

ffff800000104e35 <..@319.head>:
ffff800000104e35:	68 1d 09 00 00 68 9c 00 00 00 e9 dd f5 ff ff 00     h....h..........

ffff800000104e45 <..@321.head>:
ffff800000104e45:	68 1d 09 00 00 68 9d 00 00 00 e9 cd f5 ff ff 00     h....h..........

ffff800000104e55 <..@323.head>:
ffff800000104e55:	68 1d 09 00 00 68 9e 00 00 00 e9 bd f5 ff ff 00     h....h..........

ffff800000104e65 <..@325.head>:
ffff800000104e65:	68 1d 09 00 00 68 9f 00 00 00 e9 ad f5 ff ff 00     h....h..........

ffff800000104e75 <..@327.head>:
ffff800000104e75:	68 1d 09 00 00 68 a0 00 00 00 e9 9d f5 ff ff 00     h....h..........

ffff800000104e85 <..@329.head>:
ffff800000104e85:	68 1d 09 00 00 68 a1 00 00 00 e9 8d f5 ff ff 00     h....h..........

ffff800000104e95 <..@331.head>:
ffff800000104e95:	68 1d 09 00 00 68 a2 00 00 00 e9 7d f5 ff ff 00     h....h.....}....

ffff800000104ea5 <..@333.head>:
ffff800000104ea5:	68 1d 09 00 00 68 a3 00 00 00 e9 6d f5 ff ff 00     h....h.....m....

ffff800000104eb5 <..@335.head>:
ffff800000104eb5:	68 1d 09 00 00 68 a4 00 00 00 e9 5d f5 ff ff 00     h....h.....]....

ffff800000104ec5 <..@337.head>:
ffff800000104ec5:	68 1d 09 00 00 68 a5 00 00 00 e9 4d f5 ff ff 00     h....h.....M....

ffff800000104ed5 <..@339.head>:
ffff800000104ed5:	68 1d 09 00 00 68 a6 00 00 00 e9 3d f5 ff ff 00     h....h.....=....

ffff800000104ee5 <..@341.head>:
ffff800000104ee5:	68 1d 09 00 00 68 a7 00 00 00 e9 2d f5 ff ff 00     h....h.....-....

ffff800000104ef5 <..@343.head>:
ffff800000104ef5:	68 1d 09 00 00 68 a8 00 00 00 e9 1d f5 ff ff 00     h....h..........

ffff800000104f05 <..@345.head>:
ffff800000104f05:	68 1d 09 00 00 68 a9 00 00 00 e9 0d f5 ff ff 00     h....h..........

ffff800000104f15 <..@347.head>:
ffff800000104f15:	68 1d 09 00 00 68 aa 00 00 00 e9 fd f4 ff ff 00     h....h..........

ffff800000104f25 <..@349.head>:
ffff800000104f25:	68 1d 09 00 00 68 ab 00 00 00 e9 ed f4 ff ff 00     h....h..........

ffff800000104f35 <..@351.head>:
ffff800000104f35:	68 1d 09 00 00 68 ac 00 00 00 e9 dd f4 ff ff 00     h....h..........

ffff800000104f45 <..@353.head>:
ffff800000104f45:	68 1d 09 00 00 68 ad 00 00 00 e9 cd f4 ff ff 00     h....h..........

ffff800000104f55 <..@355.head>:
ffff800000104f55:	68 1d 09 00 00 68 ae 00 00 00 e9 bd f4 ff ff 00     h....h..........

ffff800000104f65 <..@357.head>:
ffff800000104f65:	68 1d 09 00 00 68 af 00 00 00 e9 ad f4 ff ff 00     h....h..........

ffff800000104f75 <..@359.head>:
ffff800000104f75:	68 1d 09 00 00 68 b0 00 00 00 e9 9d f4 ff ff 00     h....h..........

ffff800000104f85 <..@361.head>:
ffff800000104f85:	68 1d 09 00 00 68 b1 00 00 00 e9 8d f4 ff ff 00     h....h..........

ffff800000104f95 <..@363.head>:
ffff800000104f95:	68 1d 09 00 00 68 b2 00 00 00 e9 7d f4 ff ff 00     h....h.....}....

ffff800000104fa5 <..@365.head>:
ffff800000104fa5:	68 1d 09 00 00 68 b3 00 00 00 e9 6d f4 ff ff 00     h....h.....m....

ffff800000104fb5 <..@367.head>:
ffff800000104fb5:	68 1d 09 00 00 68 b4 00 00 00 e9 5d f4 ff ff 00     h....h.....]....

ffff800000104fc5 <..@369.head>:
ffff800000104fc5:	68 1d 09 00 00 68 b5 00 00 00 e9 4d f4 ff ff 00     h....h.....M....

ffff800000104fd5 <..@371.head>:
ffff800000104fd5:	68 1d 09 00 00 68 b6 00 00 00 e9 3d f4 ff ff 00     h....h.....=....

ffff800000104fe5 <..@373.head>:
ffff800000104fe5:	68 1d 09 00 00 68 b7 00 00 00 e9 2d f4 ff ff 00     h....h.....-....

ffff800000104ff5 <..@375.head>:
ffff800000104ff5:	68 1d 09 00 00 68 b8 00 00 00 e9 1d f4 ff ff 00     h....h..........

ffff800000105005 <..@377.head>:
ffff800000105005:	68 1d 09 00 00 68 b9 00 00 00 e9 0d f4 ff ff 00     h....h..........

ffff800000105015 <..@379.head>:
ffff800000105015:	68 1d 09 00 00 68 ba 00 00 00 e9 fd f3 ff ff 00     h....h..........

ffff800000105025 <..@381.head>:
ffff800000105025:	68 1d 09 00 00 68 bb 00 00 00 e9 ed f3 ff ff 00     h....h..........

ffff800000105035 <..@383.head>:
ffff800000105035:	68 1d 09 00 00 68 bc 00 00 00 e9 dd f3 ff ff 00     h....h..........

ffff800000105045 <..@385.head>:
ffff800000105045:	68 1d 09 00 00 68 bd 00 00 00 e9 cd f3 ff ff 00     h....h..........

ffff800000105055 <..@387.head>:
ffff800000105055:	68 1d 09 00 00 68 be 00 00 00 e9 bd f3 ff ff 00     h....h..........

ffff800000105065 <..@389.head>:
ffff800000105065:	68 1d 09 00 00 68 bf 00 00 00 e9 ad f3 ff ff 00     h....h..........

ffff800000105075 <..@391.head>:
ffff800000105075:	68 1d 09 00 00 68 c0 00 00 00 e9 9d f3 ff ff 00     h....h..........

ffff800000105085 <..@393.head>:
ffff800000105085:	68 1d 09 00 00 68 c1 00 00 00 e9 8d f3 ff ff 00     h....h..........

ffff800000105095 <..@395.head>:
ffff800000105095:	68 1d 09 00 00 68 c2 00 00 00 e9 7d f3 ff ff 00     h....h.....}....

ffff8000001050a5 <..@397.head>:
ffff8000001050a5:	68 1d 09 00 00 68 c3 00 00 00 e9 6d f3 ff ff 00     h....h.....m....

ffff8000001050b5 <..@399.head>:
ffff8000001050b5:	68 1d 09 00 00 68 c4 00 00 00 e9 5d f3 ff ff 00     h....h.....]....

ffff8000001050c5 <..@401.head>:
ffff8000001050c5:	68 1d 09 00 00 68 c5 00 00 00 e9 4d f3 ff ff 00     h....h.....M....

ffff8000001050d5 <..@403.head>:
ffff8000001050d5:	68 1d 09 00 00 68 c6 00 00 00 e9 3d f3 ff ff 00     h....h.....=....

ffff8000001050e5 <..@405.head>:
ffff8000001050e5:	68 1d 09 00 00 68 c7 00 00 00 e9 2d f3 ff ff 00     h....h.....-....

ffff8000001050f5 <..@407.head>:
ffff8000001050f5:	68 1d 09 00 00 68 c8 00 00 00 e9 1d f3 ff ff 00     h....h..........

ffff800000105105 <..@409.head>:
ffff800000105105:	68 1d 09 00 00 68 c9 00 00 00 e9 0d f3 ff ff 00     h....h..........

ffff800000105115 <..@411.head>:
ffff800000105115:	68 1d 09 00 00 68 ca 00 00 00 e9 fd f2 ff ff 00     h....h..........

ffff800000105125 <..@413.head>:
ffff800000105125:	68 1d 09 00 00 68 cb 00 00 00 e9 ed f2 ff ff 00     h....h..........

ffff800000105135 <..@415.head>:
ffff800000105135:	68 1d 09 00 00 68 cc 00 00 00 e9 dd f2 ff ff 00     h....h..........

ffff800000105145 <..@417.head>:
ffff800000105145:	68 1d 09 00 00 68 cd 00 00 00 e9 cd f2 ff ff 00     h....h..........

ffff800000105155 <..@419.head>:
ffff800000105155:	68 1d 09 00 00 68 ce 00 00 00 e9 bd f2 ff ff 00     h....h..........

ffff800000105165 <..@421.head>:
ffff800000105165:	68 1d 09 00 00 68 cf 00 00 00 e9 ad f2 ff ff 00     h....h..........

ffff800000105175 <..@423.head>:
ffff800000105175:	68 1d 09 00 00 68 d0 00 00 00 e9 9d f2 ff ff 00     h....h..........

ffff800000105185 <..@425.head>:
ffff800000105185:	68 1d 09 00 00 68 d1 00 00 00 e9 8d f2 ff ff 00     h....h..........

ffff800000105195 <..@427.head>:
ffff800000105195:	68 1d 09 00 00 68 d2 00 00 00 e9 7d f2 ff ff 00     h....h.....}....

ffff8000001051a5 <..@429.head>:
ffff8000001051a5:	68 1d 09 00 00 68 d3 00 00 00 e9 6d f2 ff ff 00     h....h.....m....

ffff8000001051b5 <..@431.head>:
ffff8000001051b5:	68 1d 09 00 00 68 d4 00 00 00 e9 5d f2 ff ff 00     h....h.....]....

ffff8000001051c5 <..@433.head>:
ffff8000001051c5:	68 1d 09 00 00 68 d5 00 00 00 e9 4d f2 ff ff 00     h....h.....M....

ffff8000001051d5 <..@435.head>:
ffff8000001051d5:	68 1d 09 00 00 68 d6 00 00 00 e9 3d f2 ff ff 00     h....h.....=....

ffff8000001051e5 <..@437.head>:
ffff8000001051e5:	68 1d 09 00 00 68 d7 00 00 00 e9 2d f2 ff ff 00     h....h.....-....

ffff8000001051f5 <..@439.head>:
ffff8000001051f5:	68 1d 09 00 00 68 d8 00 00 00 e9 1d f2 ff ff 00     h....h..........

ffff800000105205 <..@441.head>:
ffff800000105205:	68 1d 09 00 00 68 d9 00 00 00 e9 0d f2 ff ff 00     h....h..........

ffff800000105215 <..@443.head>:
ffff800000105215:	68 1d 09 00 00 68 da 00 00 00 e9 fd f1 ff ff 00     h....h..........

ffff800000105225 <..@445.head>:
ffff800000105225:	68 1d 09 00 00 68 db 00 00 00 e9 ed f1 ff ff 00     h....h..........

ffff800000105235 <..@447.head>:
ffff800000105235:	68 1d 09 00 00 68 dc 00 00 00 e9 dd f1 ff ff 00     h....h..........

ffff800000105245 <..@449.head>:
ffff800000105245:	68 1d 09 00 00 68 dd 00 00 00 e9 cd f1 ff ff 00     h....h..........

ffff800000105255 <..@451.head>:
ffff800000105255:	68 1d 09 00 00 68 de 00 00 00 e9 bd f1 ff ff 00     h....h..........

ffff800000105265 <..@453.head>:
ffff800000105265:	68 1d 09 00 00 68 df 00 00 00 e9 ad f1 ff ff 00     h....h..........

ffff800000105275 <..@455.head>:
ffff800000105275:	68 1d 09 00 00 68 e0 00 00 00 e9 9d f1 ff ff 00     h....h..........

ffff800000105285 <..@457.head>:
ffff800000105285:	68 1d 09 00 00 68 e1 00 00 00 e9 8d f1 ff ff 00     h....h..........

ffff800000105295 <..@459.head>:
ffff800000105295:	68 1d 09 00 00 68 e2 00 00 00 e9 7d f1 ff ff 00     h....h.....}....

ffff8000001052a5 <..@461.head>:
ffff8000001052a5:	68 1d 09 00 00 68 e3 00 00 00 e9 6d f1 ff ff 00     h....h.....m....

ffff8000001052b5 <..@463.head>:
ffff8000001052b5:	68 1d 09 00 00 68 e4 00 00 00 e9 5d f1 ff ff 00     h....h.....]....

ffff8000001052c5 <..@465.head>:
ffff8000001052c5:	68 1d 09 00 00 68 e5 00 00 00 e9 4d f1 ff ff 00     h....h.....M....

ffff8000001052d5 <..@467.head>:
ffff8000001052d5:	68 1d 09 00 00 68 e6 00 00 00 e9 3d f1 ff ff 00     h....h.....=....

ffff8000001052e5 <..@469.head>:
ffff8000001052e5:	68 1d 09 00 00 68 e7 00 00 00 e9 2d f1 ff ff 00     h....h.....-....

ffff8000001052f5 <..@471.head>:
ffff8000001052f5:	68 1d 09 00 00 68 e8 00 00 00 e9 1d f1 ff ff 00     h....h..........

ffff800000105305 <..@473.head>:
ffff800000105305:	68 1d 09 00 00 68 e9 00 00 00 e9 0d f1 ff ff 00     h....h..........

ffff800000105315 <..@475.head>:
ffff800000105315:	68 1d 09 00 00 68 ea 00 00 00 e9 fd f0 ff ff 00     h....h..........

ffff800000105325 <..@477.head>:
ffff800000105325:	68 1d 09 00 00 68 eb 00 00 00 e9 ed f0 ff ff 00     h....h..........

ffff800000105335 <..@479.head>:
ffff800000105335:	68 1d 09 00 00 68 ec 00 00 00 e9 dd f0 ff ff 00     h....h..........

ffff800000105345 <..@481.head>:
ffff800000105345:	68 1d 09 00 00 68 ed 00 00 00 e9 cd f0 ff ff 00     h....h..........

ffff800000105355 <..@483.head>:
ffff800000105355:	68 1d 09 00 00 68 ee 00 00 00 e9 bd f0 ff ff 00     h....h..........

ffff800000105365 <..@485.head>:
ffff800000105365:	68 1d 09 00 00 68 ef 00 00 00 e9 ad f0 ff ff 00     h....h..........

ffff800000105375 <..@487.head>:
ffff800000105375:	68 1d 09 00 00 68 f0 00 00 00 e9 9d f0 ff ff 00     h....h..........

ffff800000105385 <..@489.head>:
ffff800000105385:	68 1d 09 00 00 68 f1 00 00 00 e9 8d f0 ff ff 00     h....h..........

ffff800000105395 <..@491.head>:
ffff800000105395:	68 1d 09 00 00 68 f2 00 00 00 e9 7d f0 ff ff 00     h....h.....}....

ffff8000001053a5 <..@493.head>:
ffff8000001053a5:	68 1d 09 00 00 68 f3 00 00 00 e9 6d f0 ff ff 00     h....h.....m....

ffff8000001053b5 <..@495.head>:
ffff8000001053b5:	68 1d 09 00 00 68 f4 00 00 00 e9 5d f0 ff ff 00     h....h.....]....

ffff8000001053c5 <..@497.head>:
ffff8000001053c5:	68 1d 09 00 00 68 f5 00 00 00 e9 4d f0 ff ff 00     h....h.....M....

ffff8000001053d5 <..@499.head>:
ffff8000001053d5:	68 1d 09 00 00 68 f6 00 00 00 e9 3d f0 ff ff 00     h....h.....=....

ffff8000001053e5 <..@501.head>:
ffff8000001053e5:	68 1d 09 00 00 68 f7 00 00 00 e9 2d f0 ff ff 00     h....h.....-....

ffff8000001053f5 <..@503.head>:
ffff8000001053f5:	68 1d 09 00 00 68 f8 00 00 00 e9 1d f0 ff ff 00     h....h..........

ffff800000105405 <..@505.head>:
ffff800000105405:	68 1d 09 00 00 68 f9 00 00 00 e9 0d f0 ff ff 00     h....h..........

ffff800000105415 <..@507.head>:
ffff800000105415:	68 1d 09 00 00 68 fa 00 00 00 e9 fd ef ff ff 00     h....h..........

ffff800000105425 <..@509.head>:
ffff800000105425:	68 1d 09 00 00 68 fb 00 00 00 e9 ed ef ff ff 00     h....h..........

ffff800000105435 <..@511.head>:
ffff800000105435:	68 1d 09 00 00 68 fc 00 00 00 e9 dd ef ff ff 00     h....h..........

ffff800000105445 <..@513.head>:
ffff800000105445:	68 1d 09 00 00 68 fd 00 00 00 e9 cd ef ff ff 00     h....h..........

ffff800000105455 <..@515.head>:
ffff800000105455:	68 1d 09 00 00 68 fe 00 00 00 e9 bd ef ff ff 00     h....h..........

ffff800000105465 <..@517.head>:
ffff800000105465:	68 1d 09 00 00 68 ff 00 00 00 e9 ad ef ff ff 00     h....h..........
ffff800000105475:	66 2e 0f 1f 84 00 00 00 00 00 90                    f..........

ffff800000105480 <intr_get>:
ffff800000105480:	9c                   	pushf
ffff800000105481:	58                   	pop    rax
ffff800000105482:	48 c1 e8 09          	shr    rax,0x9
ffff800000105486:	48 83 e0 01          	and    rax,0x1
ffff80000010548a:	c3                   	ret
